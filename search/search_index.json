{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"specfab documentation Spectral CPO model of polycrystalline materials that can: Model lattice rotation, discontinuous DRX, and rotation/continuous DRX. Calculate CPO-induced viscous and elastic anisotropies using stress/strain homogenizations. Calculate CPO-induced elastic and electromagnetic wave velocities. Convert between structure tensors and spectral expansions coefficients. Integrate with finite-element codes such as Elmer and FEniCS. \u2014 Made by Nicholas M. Rathmann and David A. Lilien \ud83d\udc68\u200d\ud83d\udcbb","title":"\ud83d\udcd6 About"},{"location":"#specfab-documentation","text":"Spectral CPO model of polycrystalline materials that can: Model lattice rotation, discontinuous DRX, and rotation/continuous DRX. Calculate CPO-induced viscous and elastic anisotropies using stress/strain homogenizations. Calculate CPO-induced elastic and electromagnetic wave velocities. Convert between structure tensors and spectral expansions coefficients. Integrate with finite-element codes such as Elmer and FEniCS. \u2014 Made by Nicholas M. Rathmann and David A. Lilien \ud83d\udc68\u200d\ud83d\udcbb","title":"specfab documentation"},{"location":"constitutive-elastic/","text":"Elastic constitutive equations Linear elastic constituve equations are supported in both forward and inverse (reverse) form. Transversely isotropic The stiffness matrix is for the special case \\({\\bf c}=\\hat{{\\bf z}}\\) (allowing easy interpretation): \\[ {\\bf C} = \\begin{bmatrix}\\gamma & \\lambda & \\hat{\\lambda}\\lambda & 0 & 0 & 0 \\\\\\lambda & \\gamma & \\hat{\\lambda}\\lambda & 0 & 0 & 0 \\\\\\hat{\\lambda}\\lambda & \\hat{\\lambda}\\lambda & \\hat{\\gamma}\\gamma & 0 & 0 & 0 \\\\0&0&0& \\hat{\\mu}\\mu & 0 & 0\\\\0&0&0& 0 & \\hat{\\mu}\\mu & 0\\\\0&0&0& 0 & 0 & \\mu\\\\\\end{bmatrix} . \\] API Forward form: E = sf.elas_fwd_tranisotropic(S, lam, mu, Elam, Emu, Egam, m) Inverse form: S = sf.elas_rev_tranisotropic(E, lam, mu, Elam, Emu, Egam, m) Arguments Description S , E Stress and strain tensor (3x3) lam , mu Isotropic Lam\u00e9 parameters \\(\\lambda\\) and \\(\\mu\\) Elam , Emu , Egam Anisotropic enhancement factors \\(\\hat{\\lambda}\\) , \\(\\hat{\\mu}\\) , and \\(\\hat{\\gamma}\\) m Rotational symmetry axis \\(\\bf{m}\\) Notice: P-wave modulus is not a free parameter but given by \\(\\gamma \\equiv \\lambda + 2\\mu\\) . Tip: convert \\(C_{ij}\\) to Lam\u00e9 parameters Cij = (C11,C33,C55, C12,C13) (lam,mu, Elam,Emu,Egam) = sf.Cij_to_Lame_tranisotropic(Cij) Orthotropic The stiffness matrix is for the special case \\(({\\bf m}_1,{\\bf m}_2,{\\bf m}_3)=(\\hat{{\\bf x}},\\hat{{\\bf y}},\\hat{{\\bf z}})\\) (allowing easy interpretation): \\[ {\\bf C} = \\small\\begin{bmatrix} \\lambda_{11} + 2\\mu_1 & \\lambda_{12} & \\lambda_{13} & 0 & 0 & 0 \\\\ \\lambda_{12} & \\lambda_{22} + 2\\mu_2 & \\lambda_{23} & 0 & 0 & 0 \\\\ \\lambda_{13 }& \\lambda_{23} & \\lambda_{33} + 2\\mu_3 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & \\dfrac{\\mu_2+\\mu_3}{2} & 0 & 0 \\\\ 0 & 0 & 0 & 0 & \\dfrac{\\mu_3+\\mu_1}{2} & 0 \\\\ 0 & 0 & 0 & 0 & 0 & \\dfrac{\\mu_1+\\mu_2}{2} \\end{bmatrix} . \\] API Forward form: E = sf.elas_fwd_orthotropic(S, lame, m1,m2,m3) Inverse form: S = sf.elas_rev_orthotropic(E, lame, m1,m2,m3) Arguments Description S , E Stress and strain tensor (3x3) lame Tuple of anisotropic Lam\u00e9 parameters \\((\\lambda_{11},\\lambda_{22},\\lambda_{33}, \\lambda_{23},\\lambda_{13},\\lambda_{12}, \\mu_{1}, \\mu_{2}, \\mu_{3})\\) m1 , m2 , m3 Reflection symmetry axes \\(\\bf{m}_1\\) , \\(\\bf{m}_2\\) , and \\(\\bf{m}_3\\) Tip: convert \\(C_{ij}\\) to Lam\u00e9 parameters Cij = (C11,C22,C33,C44,C55,C66, C23,C13,C12) (lam11,lam22,lam33, lam23,lam13,lam12, mu1,mu2,mu3) = sf.Cij_to_Lame_orthotropic(Cij)","title":"Elastic constitutive eqns."},{"location":"constitutive-elastic/#elastic-constitutive-equations","text":"Linear elastic constituve equations are supported in both forward and inverse (reverse) form.","title":"Elastic constitutive equations"},{"location":"constitutive-elastic/#transversely-isotropic","text":"The stiffness matrix is for the special case \\({\\bf c}=\\hat{{\\bf z}}\\) (allowing easy interpretation): \\[ {\\bf C} = \\begin{bmatrix}\\gamma & \\lambda & \\hat{\\lambda}\\lambda & 0 & 0 & 0 \\\\\\lambda & \\gamma & \\hat{\\lambda}\\lambda & 0 & 0 & 0 \\\\\\hat{\\lambda}\\lambda & \\hat{\\lambda}\\lambda & \\hat{\\gamma}\\gamma & 0 & 0 & 0 \\\\0&0&0& \\hat{\\mu}\\mu & 0 & 0\\\\0&0&0& 0 & \\hat{\\mu}\\mu & 0\\\\0&0&0& 0 & 0 & \\mu\\\\\\end{bmatrix} . \\]","title":"Transversely isotropic"},{"location":"constitutive-elastic/#api","text":"Forward form: E = sf.elas_fwd_tranisotropic(S, lam, mu, Elam, Emu, Egam, m) Inverse form: S = sf.elas_rev_tranisotropic(E, lam, mu, Elam, Emu, Egam, m) Arguments Description S , E Stress and strain tensor (3x3) lam , mu Isotropic Lam\u00e9 parameters \\(\\lambda\\) and \\(\\mu\\) Elam , Emu , Egam Anisotropic enhancement factors \\(\\hat{\\lambda}\\) , \\(\\hat{\\mu}\\) , and \\(\\hat{\\gamma}\\) m Rotational symmetry axis \\(\\bf{m}\\) Notice: P-wave modulus is not a free parameter but given by \\(\\gamma \\equiv \\lambda + 2\\mu\\) . Tip: convert \\(C_{ij}\\) to Lam\u00e9 parameters Cij = (C11,C33,C55, C12,C13) (lam,mu, Elam,Emu,Egam) = sf.Cij_to_Lame_tranisotropic(Cij)","title":"API"},{"location":"constitutive-elastic/#orthotropic","text":"The stiffness matrix is for the special case \\(({\\bf m}_1,{\\bf m}_2,{\\bf m}_3)=(\\hat{{\\bf x}},\\hat{{\\bf y}},\\hat{{\\bf z}})\\) (allowing easy interpretation): \\[ {\\bf C} = \\small\\begin{bmatrix} \\lambda_{11} + 2\\mu_1 & \\lambda_{12} & \\lambda_{13} & 0 & 0 & 0 \\\\ \\lambda_{12} & \\lambda_{22} + 2\\mu_2 & \\lambda_{23} & 0 & 0 & 0 \\\\ \\lambda_{13 }& \\lambda_{23} & \\lambda_{33} + 2\\mu_3 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & \\dfrac{\\mu_2+\\mu_3}{2} & 0 & 0 \\\\ 0 & 0 & 0 & 0 & \\dfrac{\\mu_3+\\mu_1}{2} & 0 \\\\ 0 & 0 & 0 & 0 & 0 & \\dfrac{\\mu_1+\\mu_2}{2} \\end{bmatrix} . \\]","title":"Orthotropic"},{"location":"constitutive-elastic/#api_1","text":"Forward form: E = sf.elas_fwd_orthotropic(S, lame, m1,m2,m3) Inverse form: S = sf.elas_rev_orthotropic(E, lame, m1,m2,m3) Arguments Description S , E Stress and strain tensor (3x3) lame Tuple of anisotropic Lam\u00e9 parameters \\((\\lambda_{11},\\lambda_{22},\\lambda_{33}, \\lambda_{23},\\lambda_{13},\\lambda_{12}, \\mu_{1}, \\mu_{2}, \\mu_{3})\\) m1 , m2 , m3 Reflection symmetry axes \\(\\bf{m}_1\\) , \\(\\bf{m}_2\\) , and \\(\\bf{m}_3\\) Tip: convert \\(C_{ij}\\) to Lam\u00e9 parameters Cij = (C11,C22,C33,C44,C55,C66, C23,C13,C12) (lam11,lam22,lam33, lam23,lam13,lam12, mu1,mu2,mu3) = sf.Cij_to_Lame_orthotropic(Cij)","title":"API"},{"location":"constitutive-viscoplastic/","text":"Viscoplastic constitutive equations Anisotropic power law rheologies are supported in both forward and inverse (reverse) form. All rheologies assume incompressibility ( \\(\\text{tr}({\\dot{\\boldsymbol\\epsilon}})=0\\) ) and are based on classical creep equations where the effective stress \\(\\tau_\\mathrm{E}\\) has a quadratic form with respect to the invariants \\(I_i\\) of the stress tensor. The bulk viscous anisotropy is prescribed in terms of logitudinal and shear strain-rate enhancement factors with respect to the rheological symmetry axes \\({\\bf m}_i\\) , termed eigenenhancements \\(E_{ij}\\) . Source of viscous anisotropy The source of viscous anisotropy is irrelevant for the rheologies that follow. Although specfab is primarily concerned with the effect of CPO development on rheology, the source of viscous anisotropy could equally well be due to aligned cracks, etc. Isotropic Rheological symmetry Invariants $$ \\color{DarkCyan}{I_1 = \\mathrm{tr}({\\boldsymbol\\tau})},\\quad I_2 = \\mathrm{tr}({\\boldsymbol\\tau}^2),\\quad \\color{DarkCyan}{I_3 = \\mathrm{tr}({\\boldsymbol\\tau}^3)}, $$ \\(\\color{DarkCyan}{^*\\text{vanish for incompressible, classical creep.}}\\) The isotropic rheology is commonly written as \\[ {\\dot{\\boldsymbol\\epsilon}} = A \\tau_\\mathrm{E}^{n-1} {\\boldsymbol\\tau} , \\\\ \\tau_\\mathrm{E}^2 = I_2 , \\hspace{3em} \\] where the flow rate factor \\(A\\) and power law exponent \\(n\\) are free rheological parameters. Glen flow law When applied to glacier ice, this rheology is typically referred to as the Glen flow law for isotropic ice. In this case, it is customary to set \\(\\tau_\\mathrm{E}^2 = I_2/2\\) (divided by 1/2) instead of \\(\\tau_\\mathrm{E}^2 = I_2\\) . If the below anisotropic rheologies are used to model glacier ice, one should therefore set \\(\\tau_\\mathrm{E}^2 \\rightarrow \\tau_\\mathrm{E}^2/2\\) to ensure that the definition of \\(A\\) is consistent with the Glen flow law. Transversely isotropic Rheological symmetry Invariants $$ \\color{DarkCyan}{I_1 = \\mathrm{tr}({\\boldsymbol\\tau})},\\quad I_2 = \\mathrm{tr}({\\boldsymbol\\tau}^2),\\quad \\color{DarkCyan}{I_3 = \\mathrm{tr}({\\boldsymbol\\tau}^3)},$$ $$ I_4 = {\\boldsymbol\\tau}:{\\bf m}^2, \\quad I_5 = ({\\boldsymbol\\tau}\\cdot{\\boldsymbol\\tau}):{\\bf m}^2,$$ \\(\\color{DarkCyan}{^*\\text{vanish for incompressible, classical creep.}}\\) The transversely isotropic rheology is commonly written as \\[ {\\dot{\\boldsymbol\\epsilon}} = A \\tau_\\mathrm{E}^{n-1} \\Big[ {\\boldsymbol\\tau} - \\lambda_{mm} I_4{\\bf I} + \\left(3\\lambda_{mm}-4\\lambda_{mt}\\right) I_4{\\bf m}^2 + 2\\lambda_{mt} ({\\boldsymbol\\tau}\\cdot{\\bf m}^2 + {\\bf m}^2\\cdot{\\boldsymbol\\tau}) \\Big] , \\\\ \\tau_\\mathrm{E}^2 = I_2 + \\left(3\\lambda_{mm}-4\\lambda_{mt}\\right) I_4^2 + 4\\lambda_{mt} I_5 , \\hspace{16em} \\] where \\(A\\) is the flow rate factor, \\(n\\) is the power law exponent, and \\(\\lambda_i\\) are material parameters. Written in terms of the eigenenhancements, the material parameters are \\[ \\lambda_{mm} = \\frac{E_{mm}^{2/(n+1)}-1}{2} ,\\quad \\lambda_{mt} = \\frac{E_{mt}^{2/(n+1)}-1}{2} . \\] Alternative form Unlike the isotropic rheology, the transversely isotropic rheology allows to scale the strain rate components depending on the stress projection along \\(\\bf m\\) and in the transverse plane of isotropy. Realizing this, the rheology takes a particularly simple form if rewritten it in terms of the normal- and shear-stress projectors : \\[ {\\bf P}_{mm} = {\\bf m}^2 - {\\bf I}/3, \\hspace{7em} \\\\ {\\bf P}_{mt} = \\frac{{\\boldsymbol\\tau}\\cdot{\\bf m}^2 + {\\bf m}^2\\cdot{\\boldsymbol\\tau}}{2} - \\boldsymbol\\tau:{\\bf m}^4 , \\] so that \\[ {\\dot{\\boldsymbol\\epsilon}} = A \\tau_\\mathrm{E}^{n-1} \\Big[ {\\boldsymbol\\tau} + 3\\lambda_{mm} I_{mm} {\\bf P}_{mm} + 4\\lambda_{mt} {\\bf P}_{mt} \\Big] , \\\\ \\tau_\\mathrm{E}^2 = I_2 + 3\\lambda_{mm}I_{mm}^2 + 4\\lambda_{mt} I_{mt} , \\hspace{6em} \\] where the invariant \\(I_{mm}\\) is equal to the normal stress acting in the plane with the unit normal \\(\\bf m\\) : \\[ I_{mm} = {\\bf P}_{mm} : {\\boldsymbol\\tau} , \\] and \\(I_{mt}\\) is equal to the square of the shear stress resolved in the transverse plane of isotropy, \\(\\tau^2_\\mathrm{RSS}\\) : \\[ I_{mt} = {\\bf P}_{mt} : {\\boldsymbol\\tau} = ({\\boldsymbol\\tau}\\cdot{\\boldsymbol\\tau}):{\\bf m}^2 - {\\boldsymbol\\tau}:{\\bf m}^4:{\\boldsymbol\\tau} = \\tau^2_\\mathrm{RSS} . \\] Free parameters In addition to \\(A\\) and \\(n\\) , the transversely isotropic rheology has three additional rheological parameters that must be specified: \\(\\bf m\\) , \\(E_{mm}\\) , \\(E_{mt}\\) . Special cases Isotropic limit In the limit of unit enhancements, \\(E_{mm},E_{mt}=1\\) , the isotropic rheology is trivially recovered since \\(\\lambda_{mm},\\lambda_{mt}=0\\) . Schmid limit In the case that \\(E_{mm}=1\\) and \\(E_{mt}\\gg 1\\) , the rheology reduces to the transversely isotropic Schmid rheology that permits only shear deformation in the \\(\\bf m\\) \u2014 \\(\\bf t\\) plane. \\[ {\\dot{\\boldsymbol\\epsilon}} = A \\tau_\\mathrm{E}^{n-1} \\left( \\frac{{\\boldsymbol\\tau}\\cdot{\\bf m}^2 + {\\bf m}^2\\cdot{\\boldsymbol\\tau}}{2} - \\boldsymbol\\tau:{\\bf m}^4 \\right), \\\\ \\tau_\\mathrm{E}^2 = \\tau_\\mathrm{RSS}^2 \\hspace{14em} \\] where a factor of \\((4\\lambda_{mt})^{(n+1)/2}\\) was absorbed into \\(A\\) . API Forward rheology: D = sf.rheo_fwd_tranisotropic(S, A, n, m, Eij) Inverse rheology: S = sf.rheo_rev_tranisotropic(D, A, n, m, Eij) Arguments Description S , D Deviatoric stress tensor and strain rate tensor (3x3) A , n Flow-rate factor \\(A\\) and power law exponent \\(n\\) m Rotational symmetry axis \\(\\bf{m}\\) Eij Tuple of eigenenhancements (Emm, Emt) Orthotropic Rheological symmetry Invariants $$ ... $$ \ud83d\udea7 Being rewritten, soon available again.","title":"Viscoplastic constitutive eqns."},{"location":"constitutive-viscoplastic/#viscoplastic-constitutive-equations","text":"Anisotropic power law rheologies are supported in both forward and inverse (reverse) form. All rheologies assume incompressibility ( \\(\\text{tr}({\\dot{\\boldsymbol\\epsilon}})=0\\) ) and are based on classical creep equations where the effective stress \\(\\tau_\\mathrm{E}\\) has a quadratic form with respect to the invariants \\(I_i\\) of the stress tensor. The bulk viscous anisotropy is prescribed in terms of logitudinal and shear strain-rate enhancement factors with respect to the rheological symmetry axes \\({\\bf m}_i\\) , termed eigenenhancements \\(E_{ij}\\) . Source of viscous anisotropy The source of viscous anisotropy is irrelevant for the rheologies that follow. Although specfab is primarily concerned with the effect of CPO development on rheology, the source of viscous anisotropy could equally well be due to aligned cracks, etc.","title":"Viscoplastic constitutive equations"},{"location":"constitutive-viscoplastic/#isotropic","text":"Rheological symmetry Invariants $$ \\color{DarkCyan}{I_1 = \\mathrm{tr}({\\boldsymbol\\tau})},\\quad I_2 = \\mathrm{tr}({\\boldsymbol\\tau}^2),\\quad \\color{DarkCyan}{I_3 = \\mathrm{tr}({\\boldsymbol\\tau}^3)}, $$ \\(\\color{DarkCyan}{^*\\text{vanish for incompressible, classical creep.}}\\) The isotropic rheology is commonly written as \\[ {\\dot{\\boldsymbol\\epsilon}} = A \\tau_\\mathrm{E}^{n-1} {\\boldsymbol\\tau} , \\\\ \\tau_\\mathrm{E}^2 = I_2 , \\hspace{3em} \\] where the flow rate factor \\(A\\) and power law exponent \\(n\\) are free rheological parameters. Glen flow law When applied to glacier ice, this rheology is typically referred to as the Glen flow law for isotropic ice. In this case, it is customary to set \\(\\tau_\\mathrm{E}^2 = I_2/2\\) (divided by 1/2) instead of \\(\\tau_\\mathrm{E}^2 = I_2\\) . If the below anisotropic rheologies are used to model glacier ice, one should therefore set \\(\\tau_\\mathrm{E}^2 \\rightarrow \\tau_\\mathrm{E}^2/2\\) to ensure that the definition of \\(A\\) is consistent with the Glen flow law.","title":"Isotropic"},{"location":"constitutive-viscoplastic/#transversely-isotropic","text":"Rheological symmetry Invariants $$ \\color{DarkCyan}{I_1 = \\mathrm{tr}({\\boldsymbol\\tau})},\\quad I_2 = \\mathrm{tr}({\\boldsymbol\\tau}^2),\\quad \\color{DarkCyan}{I_3 = \\mathrm{tr}({\\boldsymbol\\tau}^3)},$$ $$ I_4 = {\\boldsymbol\\tau}:{\\bf m}^2, \\quad I_5 = ({\\boldsymbol\\tau}\\cdot{\\boldsymbol\\tau}):{\\bf m}^2,$$ \\(\\color{DarkCyan}{^*\\text{vanish for incompressible, classical creep.}}\\) The transversely isotropic rheology is commonly written as \\[ {\\dot{\\boldsymbol\\epsilon}} = A \\tau_\\mathrm{E}^{n-1} \\Big[ {\\boldsymbol\\tau} - \\lambda_{mm} I_4{\\bf I} + \\left(3\\lambda_{mm}-4\\lambda_{mt}\\right) I_4{\\bf m}^2 + 2\\lambda_{mt} ({\\boldsymbol\\tau}\\cdot{\\bf m}^2 + {\\bf m}^2\\cdot{\\boldsymbol\\tau}) \\Big] , \\\\ \\tau_\\mathrm{E}^2 = I_2 + \\left(3\\lambda_{mm}-4\\lambda_{mt}\\right) I_4^2 + 4\\lambda_{mt} I_5 , \\hspace{16em} \\] where \\(A\\) is the flow rate factor, \\(n\\) is the power law exponent, and \\(\\lambda_i\\) are material parameters. Written in terms of the eigenenhancements, the material parameters are \\[ \\lambda_{mm} = \\frac{E_{mm}^{2/(n+1)}-1}{2} ,\\quad \\lambda_{mt} = \\frac{E_{mt}^{2/(n+1)}-1}{2} . \\]","title":"Transversely isotropic"},{"location":"constitutive-viscoplastic/#alternative-form","text":"Unlike the isotropic rheology, the transversely isotropic rheology allows to scale the strain rate components depending on the stress projection along \\(\\bf m\\) and in the transverse plane of isotropy. Realizing this, the rheology takes a particularly simple form if rewritten it in terms of the normal- and shear-stress projectors : \\[ {\\bf P}_{mm} = {\\bf m}^2 - {\\bf I}/3, \\hspace{7em} \\\\ {\\bf P}_{mt} = \\frac{{\\boldsymbol\\tau}\\cdot{\\bf m}^2 + {\\bf m}^2\\cdot{\\boldsymbol\\tau}}{2} - \\boldsymbol\\tau:{\\bf m}^4 , \\] so that \\[ {\\dot{\\boldsymbol\\epsilon}} = A \\tau_\\mathrm{E}^{n-1} \\Big[ {\\boldsymbol\\tau} + 3\\lambda_{mm} I_{mm} {\\bf P}_{mm} + 4\\lambda_{mt} {\\bf P}_{mt} \\Big] , \\\\ \\tau_\\mathrm{E}^2 = I_2 + 3\\lambda_{mm}I_{mm}^2 + 4\\lambda_{mt} I_{mt} , \\hspace{6em} \\] where the invariant \\(I_{mm}\\) is equal to the normal stress acting in the plane with the unit normal \\(\\bf m\\) : \\[ I_{mm} = {\\bf P}_{mm} : {\\boldsymbol\\tau} , \\] and \\(I_{mt}\\) is equal to the square of the shear stress resolved in the transverse plane of isotropy, \\(\\tau^2_\\mathrm{RSS}\\) : \\[ I_{mt} = {\\bf P}_{mt} : {\\boldsymbol\\tau} = ({\\boldsymbol\\tau}\\cdot{\\boldsymbol\\tau}):{\\bf m}^2 - {\\boldsymbol\\tau}:{\\bf m}^4:{\\boldsymbol\\tau} = \\tau^2_\\mathrm{RSS} . \\] Free parameters In addition to \\(A\\) and \\(n\\) , the transversely isotropic rheology has three additional rheological parameters that must be specified: \\(\\bf m\\) , \\(E_{mm}\\) , \\(E_{mt}\\) .","title":"Alternative form"},{"location":"constitutive-viscoplastic/#special-cases","text":"Isotropic limit In the limit of unit enhancements, \\(E_{mm},E_{mt}=1\\) , the isotropic rheology is trivially recovered since \\(\\lambda_{mm},\\lambda_{mt}=0\\) . Schmid limit In the case that \\(E_{mm}=1\\) and \\(E_{mt}\\gg 1\\) , the rheology reduces to the transversely isotropic Schmid rheology that permits only shear deformation in the \\(\\bf m\\) \u2014 \\(\\bf t\\) plane. \\[ {\\dot{\\boldsymbol\\epsilon}} = A \\tau_\\mathrm{E}^{n-1} \\left( \\frac{{\\boldsymbol\\tau}\\cdot{\\bf m}^2 + {\\bf m}^2\\cdot{\\boldsymbol\\tau}}{2} - \\boldsymbol\\tau:{\\bf m}^4 \\right), \\\\ \\tau_\\mathrm{E}^2 = \\tau_\\mathrm{RSS}^2 \\hspace{14em} \\] where a factor of \\((4\\lambda_{mt})^{(n+1)/2}\\) was absorbed into \\(A\\) .","title":"Special cases"},{"location":"constitutive-viscoplastic/#api","text":"Forward rheology: D = sf.rheo_fwd_tranisotropic(S, A, n, m, Eij) Inverse rheology: S = sf.rheo_rev_tranisotropic(D, A, n, m, Eij) Arguments Description S , D Deviatoric stress tensor and strain rate tensor (3x3) A , n Flow-rate factor \\(A\\) and power law exponent \\(n\\) m Rotational symmetry axis \\(\\bf{m}\\) Eij Tuple of eigenenhancements (Emm, Emt)","title":"API"},{"location":"constitutive-viscoplastic/#orthotropic","text":"Rheological symmetry Invariants $$ ... $$ \ud83d\udea7 Being rewritten, soon available again.","title":"Orthotropic"},{"location":"cpo-idealized/","text":"Idealized CPOs If concerned with the distribution of a single crystallographic axis, three types of idealized CPO states can be said to exist: Unidirectional CPO : all axes are perfectly aligned, i.e. perfect single maximum. Planar CPO : all axes are perfectly distributed on a plane, i.e. a great circle on \\(S^2\\) . Circle CPO : all axes are perfectly distributed on a small circle on \\(S^2\\) . Each of these can be expanded as a spherical harmonics series by using the sifting property of the delta function \\(\\delta({\\hat {\\bf r}})\\) . Unidirectional Consider the case where slip-plane normals are perfectly aligned with \\({\\hat {\\bf r}}_0\\) such that \\(n({\\hat {\\bf r}}) = \\delta({\\hat {\\bf r}}- {\\hat {\\bf r}}_0)\\) where \\({\\hat {\\bf r}}(\\theta,\\phi)\\) is an arbitrary radial unit vector. The corresponding expansion coefficients follow from the evaluating overlap integral \\[ n_l^m = \\int_{S^2} \\delta(\\hat{{\\bf r}}-{\\hat {\\bf r}}_0) (Y_l^m(\\hat{{\\bf r}}))^* \\,\\mathrm{d}\\Omega = (Y_l^m({\\hat {\\bf r}}_0))^* . \\] In the figure below, the resulting unidirectional distribution is shown (rightmost inset), where the white area represents the subspace of admissible CPOs when expressed in terms of the normalized coefficients of lowest order: \\(\\hat{n}_2^0 = n_2^0/n_0^0\\) and \\(\\hat{n}_4^0 = n_4^0/n_0^0\\) . The code below demonstrates how to generate the distribution with specfab. import numpy as np from specfabpy import specfab as sf L = 8 lm, nlm_len = sf.init(L) m = [0,0,1] # symmetry axis of distribution colat = 0 # 0 = unidirectional distribution, pi/2 = planar distribution, and anything in between is a small circle distribution nlm = sf.nlm_ideal(m, colat, L) # note: only l<=12 coefs are determined even if L>12 Planar and circle Planar and circle distributions follow from averaging the delta function over a desired co-latitude \\(\\theta\\) \u2014 i.e., the co-latitude where \\(n(\\hat{{\\bf r}})\\) should be sharply defined \u2014 in which case all zonal structure vanishes ( \\(m\\neq 0\\) components vanish) and we are left with \\[ n_l^m(\\theta) = \\begin{cases} Y_l^0(\\theta, \\phi=0) \\qquad\\text{if}\\quad m=0\\\\ 0 \\qquad\\qquad\\qquad\\quad \\text{if} \\quad m\\neq 0 \\end{cases} . \\] Here, \\({\\hat {\\bf r}}_0\\) is to be understood as the rotational symmetry axis of \\(n(\\hat{{\\bf r}})\\) , and the co-latitude is defined w.r.t. \\({\\hat {\\bf r}}_0\\) , not \\(\\hat{{\\bf z}}\\) . The above figure also shows the resulting \\(n(\\hat{{\\bf r}})\\) for different \\(\\theta\\) , calculated using the same code as above but with a nonzero colat .","title":"Idealized CPO states"},{"location":"cpo-idealized/#idealized-cpos","text":"If concerned with the distribution of a single crystallographic axis, three types of idealized CPO states can be said to exist: Unidirectional CPO : all axes are perfectly aligned, i.e. perfect single maximum. Planar CPO : all axes are perfectly distributed on a plane, i.e. a great circle on \\(S^2\\) . Circle CPO : all axes are perfectly distributed on a small circle on \\(S^2\\) . Each of these can be expanded as a spherical harmonics series by using the sifting property of the delta function \\(\\delta({\\hat {\\bf r}})\\) .","title":"Idealized CPOs"},{"location":"cpo-idealized/#unidirectional","text":"Consider the case where slip-plane normals are perfectly aligned with \\({\\hat {\\bf r}}_0\\) such that \\(n({\\hat {\\bf r}}) = \\delta({\\hat {\\bf r}}- {\\hat {\\bf r}}_0)\\) where \\({\\hat {\\bf r}}(\\theta,\\phi)\\) is an arbitrary radial unit vector. The corresponding expansion coefficients follow from the evaluating overlap integral \\[ n_l^m = \\int_{S^2} \\delta(\\hat{{\\bf r}}-{\\hat {\\bf r}}_0) (Y_l^m(\\hat{{\\bf r}}))^* \\,\\mathrm{d}\\Omega = (Y_l^m({\\hat {\\bf r}}_0))^* . \\] In the figure below, the resulting unidirectional distribution is shown (rightmost inset), where the white area represents the subspace of admissible CPOs when expressed in terms of the normalized coefficients of lowest order: \\(\\hat{n}_2^0 = n_2^0/n_0^0\\) and \\(\\hat{n}_4^0 = n_4^0/n_0^0\\) . The code below demonstrates how to generate the distribution with specfab. import numpy as np from specfabpy import specfab as sf L = 8 lm, nlm_len = sf.init(L) m = [0,0,1] # symmetry axis of distribution colat = 0 # 0 = unidirectional distribution, pi/2 = planar distribution, and anything in between is a small circle distribution nlm = sf.nlm_ideal(m, colat, L) # note: only l<=12 coefs are determined even if L>12","title":"Unidirectional"},{"location":"cpo-idealized/#planar-and-circle","text":"Planar and circle distributions follow from averaging the delta function over a desired co-latitude \\(\\theta\\) \u2014 i.e., the co-latitude where \\(n(\\hat{{\\bf r}})\\) should be sharply defined \u2014 in which case all zonal structure vanishes ( \\(m\\neq 0\\) components vanish) and we are left with \\[ n_l^m(\\theta) = \\begin{cases} Y_l^0(\\theta, \\phi=0) \\qquad\\text{if}\\quad m=0\\\\ 0 \\qquad\\qquad\\qquad\\quad \\text{if} \\quad m\\neq 0 \\end{cases} . \\] Here, \\({\\hat {\\bf r}}_0\\) is to be understood as the rotational symmetry axis of \\(n(\\hat{{\\bf r}})\\) , and the co-latitude is defined w.r.t. \\({\\hat {\\bf r}}_0\\) , not \\(\\hat{{\\bf z}}\\) . The above figure also shows the resulting \\(n(\\hat{{\\bf r}})\\) for different \\(\\theta\\) , calculated using the same code as above but with a nonzero colat .","title":"Planar and circle"},{"location":"cpo-matrix-model/","text":"Matrix model of CPO dynamics CPO evolution is modelled as a matrix problem involving the state vectors of \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) . Recall that \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) may either be understood as the grain number-density or mass-density distribution in orientation space, the integrals of which give the total number of grains ( \\(N\\) ) or the bulk density ( \\(\\rho\\) ), respectively. Because the models of crystal processes included in specfab conserve the normalization, the two different views produce the same result. Glacier ice Polycrystalline ice Ensemble of slip elements For polycrystalline glacier ice, \\(n(\\theta,\\phi)\\) is simply the distribution of (easy) slip-plane normals since \\({\\bf n}={\\bf c}\\) . Given the expansion \\[ n({\\bf x},t,\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}n_{l}^{m}({\\bf x},t) Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip-plane normals)}, \\] CPO evolution can be written as a matrix problem involving the state vector \\[ {\\bf s} = [n_0^0,n_2^{-2},n_2^{-1},n_2^{0},n_2^{1},n_2^{2},n_4^{-4},\\cdots,n_4^{4},\\cdots,n_L^{-L},\\cdots,n_L^{L}]^{\\mathrm{T}} \\quad\\text{(state vector)}, \\] such that \\[ \\frac{\\mathrm{D}{\\bf s}}{\\mathrm{D} t} = {\\bf M} \\cdot {\\bf s} \\quad\\text{(state evolution)}, \\] where the operator (matrix) \\({\\bf M}\\) represents the effect of a given CPO process, which may depend on stress, strain-rate, temperature, etc. The total effect of multiple processes acting simultaneously is simply \\[ {\\bf M} = {\\bf M_{\\mathrm{LROT}}} + {\\bf M_{\\mathrm{DDRX}}} + {\\bf M_{\\mathrm{CDRX}}} + \\cdots \\quad\\text{(operator)}. \\] Validation If the CPO is rotated into an approximately rotationally-symmetric frame about the \\(z\\) -axis, then only \\(n_l^0\\) components are nonzero. This conveniently allows validating modelled CPO processes by comparing modelled to observed correlations between, e.g., the lowest-order normalized components \\(\\hat{n}_2^0 = n_2^0/n_0^0\\) and \\(\\hat{n}_4^0 = n_4^0/n_0^0\\) . The below plot from Lilien et al. (2023) shows the observed correlation structure (markers) compared to the above CPO model(s) for different modes of deformation, suggesting that modelled CPO processes capture observations reasonably well. Olivine Polycrystalline olivine Ensemble of slip elements For polycrystalline olivine, the distributions \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) refer to certain crystallographic axes ( \\({\\bf m}'_i\\) ) depending on the fabric type; i.e. thermodynamic conditions, water content, and stress magnitude that control which of the crystallographic slip systems is activated. Given the expansions \\[ n({\\bf x},t,\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}n_{l}^{m}({\\bf x},t) Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip-plane normals)}, \\\\ b({\\bf x},t,\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}b_{l}^{m}({\\bf x},t) Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip directions)}, \\] CPO evolution can be written as two independent matrix problems involving the CPO state vector fields \\[ {\\bf s}_n = [n_0^0,n_2^{-2},n_2^{-1},n_2^{0},n_2^{1},n_2^{2},n_4^{-4},\\cdots,n_4^{4},\\cdots,n_L^{-L},\\cdots,n_L^{L}]^{\\mathrm{T}} \\quad\\text{($n$ state vector)}, \\\\ {\\bf s}_b = [b_0^0,b_2^{-2},b_2^{-1},b_2^{0},b_2^{1},b_2^{2},b_4^{-4},\\cdots,b_4^{4},\\cdots,b_L^{-L},\\cdots,b_L^{L}]^{\\mathrm{T}} \\quad\\text{($b$ state vector)}, \\] such that \\[ \\frac{\\mathrm{D}{\\bf s}_n}{\\mathrm{D} t} = {\\bf M}_n \\cdot {\\bf s}_n \\quad\\text{($n$ state evolution)}, \\\\ \\frac{\\mathrm{D}{\\bf s}_b}{\\mathrm{D} t} = {\\bf M}_b \\cdot {\\bf s}_b \\quad\\text{($b$ state evolution)}, \\] where the operators (matrices) \\({\\bf M}_n\\) and \\({\\bf M}_b\\) represents the net effect of CPO processes, similar to the above example for glacier ice. Supported crystal processes So far, only lattice rotation is supported for olivine. Validation Validation is provided in Rathmann et al. (2024) similar to that above for glacier ice.","title":"Matrix model"},{"location":"cpo-matrix-model/#matrix-model-of-cpo-dynamics","text":"CPO evolution is modelled as a matrix problem involving the state vectors of \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) . Recall that \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) may either be understood as the grain number-density or mass-density distribution in orientation space, the integrals of which give the total number of grains ( \\(N\\) ) or the bulk density ( \\(\\rho\\) ), respectively. Because the models of crystal processes included in specfab conserve the normalization, the two different views produce the same result.","title":"Matrix model of CPO dynamics"},{"location":"cpo-matrix-model/#glacier-ice","text":"Polycrystalline ice Ensemble of slip elements For polycrystalline glacier ice, \\(n(\\theta,\\phi)\\) is simply the distribution of (easy) slip-plane normals since \\({\\bf n}={\\bf c}\\) . Given the expansion \\[ n({\\bf x},t,\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}n_{l}^{m}({\\bf x},t) Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip-plane normals)}, \\] CPO evolution can be written as a matrix problem involving the state vector \\[ {\\bf s} = [n_0^0,n_2^{-2},n_2^{-1},n_2^{0},n_2^{1},n_2^{2},n_4^{-4},\\cdots,n_4^{4},\\cdots,n_L^{-L},\\cdots,n_L^{L}]^{\\mathrm{T}} \\quad\\text{(state vector)}, \\] such that \\[ \\frac{\\mathrm{D}{\\bf s}}{\\mathrm{D} t} = {\\bf M} \\cdot {\\bf s} \\quad\\text{(state evolution)}, \\] where the operator (matrix) \\({\\bf M}\\) represents the effect of a given CPO process, which may depend on stress, strain-rate, temperature, etc. The total effect of multiple processes acting simultaneously is simply \\[ {\\bf M} = {\\bf M_{\\mathrm{LROT}}} + {\\bf M_{\\mathrm{DDRX}}} + {\\bf M_{\\mathrm{CDRX}}} + \\cdots \\quad\\text{(operator)}. \\]","title":"Glacier ice"},{"location":"cpo-matrix-model/#validation","text":"If the CPO is rotated into an approximately rotationally-symmetric frame about the \\(z\\) -axis, then only \\(n_l^0\\) components are nonzero. This conveniently allows validating modelled CPO processes by comparing modelled to observed correlations between, e.g., the lowest-order normalized components \\(\\hat{n}_2^0 = n_2^0/n_0^0\\) and \\(\\hat{n}_4^0 = n_4^0/n_0^0\\) . The below plot from Lilien et al. (2023) shows the observed correlation structure (markers) compared to the above CPO model(s) for different modes of deformation, suggesting that modelled CPO processes capture observations reasonably well.","title":"Validation"},{"location":"cpo-matrix-model/#olivine","text":"Polycrystalline olivine Ensemble of slip elements For polycrystalline olivine, the distributions \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) refer to certain crystallographic axes ( \\({\\bf m}'_i\\) ) depending on the fabric type; i.e. thermodynamic conditions, water content, and stress magnitude that control which of the crystallographic slip systems is activated. Given the expansions \\[ n({\\bf x},t,\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}n_{l}^{m}({\\bf x},t) Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip-plane normals)}, \\\\ b({\\bf x},t,\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}b_{l}^{m}({\\bf x},t) Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip directions)}, \\] CPO evolution can be written as two independent matrix problems involving the CPO state vector fields \\[ {\\bf s}_n = [n_0^0,n_2^{-2},n_2^{-1},n_2^{0},n_2^{1},n_2^{2},n_4^{-4},\\cdots,n_4^{4},\\cdots,n_L^{-L},\\cdots,n_L^{L}]^{\\mathrm{T}} \\quad\\text{($n$ state vector)}, \\\\ {\\bf s}_b = [b_0^0,b_2^{-2},b_2^{-1},b_2^{0},b_2^{1},b_2^{2},b_4^{-4},\\cdots,b_4^{4},\\cdots,b_L^{-L},\\cdots,b_L^{L}]^{\\mathrm{T}} \\quad\\text{($b$ state vector)}, \\] such that \\[ \\frac{\\mathrm{D}{\\bf s}_n}{\\mathrm{D} t} = {\\bf M}_n \\cdot {\\bf s}_n \\quad\\text{($n$ state evolution)}, \\\\ \\frac{\\mathrm{D}{\\bf s}_b}{\\mathrm{D} t} = {\\bf M}_b \\cdot {\\bf s}_b \\quad\\text{($b$ state evolution)}, \\] where the operators (matrices) \\({\\bf M}_n\\) and \\({\\bf M}_b\\) represents the net effect of CPO processes, similar to the above example for glacier ice. Supported crystal processes So far, only lattice rotation is supported for olivine.","title":"Olivine"},{"location":"cpo-matrix-model/#validation_1","text":"Validation is provided in Rathmann et al. (2024) similar to that above for glacier ice.","title":"Validation"},{"location":"cpo-plot/","text":"Plot CPO The orientation distribution can be plotted as follows: import numpy as np import matplotlib.pyplot as plt from specfabpy import specfab as sf from specfabpy import plotting as sfplt lm, nlm_len = sf.init(6) ### Synthetic CPO to be plotted a2 = np.diag([0,0,1]) # CPO characterized by a^(2) nlm = sf.a2_to_nlm(a2) # vector of expansion coefficients ### Setup axes and projection geo, prj = sfplt.getprojection(rotation=45, inclination=45) fig = plt.figure(figsize=(2,2)) ax = plt.subplot(111, projection=prj) ax.set_global() # ensure entire S^2 is shown ### Plot lvlset = 'iso-up' # default level set: lowest tick/level is the value of an isotropic distribution lvlset = (np.linspace(0,0.8,9), lambda x,p:'%.1f'%x) # custom level set: (list of levels, how to format colorbar tick labels) sfplt.plotODF(nlm, lm, ax, cmap='Greys', lvlset=lvlset) # plot distribution (see src/specfabpy/plotting.py for API) sfplt.plotcoordaxes(ax, geo, color=sfplt.c_dred) # plot coordinate axes (see src/specfabpy/plotting.py for API) plt.savefig('ODF-plot.png', dpi=175, pad_inches=0.1, bbox_inches='tight')","title":"Plot CPO"},{"location":"cpo-plot/#plot-cpo","text":"The orientation distribution can be plotted as follows: import numpy as np import matplotlib.pyplot as plt from specfabpy import specfab as sf from specfabpy import plotting as sfplt lm, nlm_len = sf.init(6) ### Synthetic CPO to be plotted a2 = np.diag([0,0,1]) # CPO characterized by a^(2) nlm = sf.a2_to_nlm(a2) # vector of expansion coefficients ### Setup axes and projection geo, prj = sfplt.getprojection(rotation=45, inclination=45) fig = plt.figure(figsize=(2,2)) ax = plt.subplot(111, projection=prj) ax.set_global() # ensure entire S^2 is shown ### Plot lvlset = 'iso-up' # default level set: lowest tick/level is the value of an isotropic distribution lvlset = (np.linspace(0,0.8,9), lambda x,p:'%.1f'%x) # custom level set: (list of levels, how to format colorbar tick labels) sfplt.plotODF(nlm, lm, ax, cmap='Greys', lvlset=lvlset) # plot distribution (see src/specfabpy/plotting.py for API) sfplt.plotcoordaxes(ax, geo, color=sfplt.c_dred) # plot coordinate axes (see src/specfabpy/plotting.py for API) plt.savefig('ODF-plot.png', dpi=175, pad_inches=0.1, bbox_inches='tight')","title":"Plot CPO"},{"location":"cpo-regularization/","text":"Regularization As \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) becomes anisotropic due to CPO processes, the coefficients \\(n_l^m\\) and \\(b_l^m\\) associated with high wavenumber modes (large \\(l\\) and \\(m\\) , and thus small-scale structure) must increase in magnitude relative to the low wavenumber coefficients (small \\(l\\) and \\(m\\) ). One way to visualize this is by the angular power spectrum (and similarly for \\(b(\\theta,\\phi)\\) ) \\[ S(l) = \\frac{1}{2l + 1} \\sum_{m=-l}^l \\left\\vert n_l^m \\right\\vert^2 , \\] which grows with time. In the animation above, the left-hand panel shows how the power spectrum evolves under lattice rotation (unconfined vertical compression) compared to the end-member case of a delta function (dashed line). If the expansion series is truncated at \\(l=L\\) , then \\(l{\\gt}L\\) modes cannot evolve, and the truncated solution will reach an unphysical quasi-steady state. To prevent this, regularization must be introduced. Specfab uses Laplacian hyper diffusion ( \\(k>1\\) ) as regularization in \\(S^2\\) \\[ \\frac{\\mathrm{D} n_l^m}{\\mathrm{D} t} = \\sqrt{\\frac{{\\dot{\\boldsymbol\\epsilon}}:{\\dot{\\boldsymbol\\epsilon}}}{2}} {\\nu}[l(l+1)]^{k} n_l^m \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}}{\\mathrm{D} t} = {\\bf M_{\\mathrm{REG}}} \\cdot {\\bf s} , \\] that can be added to the fabric evolution operator \\({\\bf M}\\) as follows: M += sf.M_REG(nlm, D) # D = strainrate tensor This allows the growth of high wavenumber modes to be disproportionately damped (green line compared to red line in animation above). The dependency on the strain-rate tensor guarantees the same behavior irrespective of strain rate magnitude. Strength of regularization Extra spectral width As a rule-of-thumb, regularization affects the highest ( \\(l=L\\) ) and next-highest ( \\(l=L-2\\) ) harmonics and can therefore not be expected to evolve freely. This, in turn, means that the structure tensors \\({\\bf a}^{(2)}\\) and \\({\\bf a}^{(4)}\\) , and hence derived enhancement factors , might be affected by regularization unless extra spectral width is dedicated by setting \\(L{\\geq}8\\) .","title":"Regularization"},{"location":"cpo-regularization/#regularization","text":"As \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) becomes anisotropic due to CPO processes, the coefficients \\(n_l^m\\) and \\(b_l^m\\) associated with high wavenumber modes (large \\(l\\) and \\(m\\) , and thus small-scale structure) must increase in magnitude relative to the low wavenumber coefficients (small \\(l\\) and \\(m\\) ). One way to visualize this is by the angular power spectrum (and similarly for \\(b(\\theta,\\phi)\\) ) \\[ S(l) = \\frac{1}{2l + 1} \\sum_{m=-l}^l \\left\\vert n_l^m \\right\\vert^2 , \\] which grows with time. In the animation above, the left-hand panel shows how the power spectrum evolves under lattice rotation (unconfined vertical compression) compared to the end-member case of a delta function (dashed line). If the expansion series is truncated at \\(l=L\\) , then \\(l{\\gt}L\\) modes cannot evolve, and the truncated solution will reach an unphysical quasi-steady state. To prevent this, regularization must be introduced. Specfab uses Laplacian hyper diffusion ( \\(k>1\\) ) as regularization in \\(S^2\\) \\[ \\frac{\\mathrm{D} n_l^m}{\\mathrm{D} t} = \\sqrt{\\frac{{\\dot{\\boldsymbol\\epsilon}}:{\\dot{\\boldsymbol\\epsilon}}}{2}} {\\nu}[l(l+1)]^{k} n_l^m \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}}{\\mathrm{D} t} = {\\bf M_{\\mathrm{REG}}} \\cdot {\\bf s} , \\] that can be added to the fabric evolution operator \\({\\bf M}\\) as follows: M += sf.M_REG(nlm, D) # D = strainrate tensor This allows the growth of high wavenumber modes to be disproportionately damped (green line compared to red line in animation above). The dependency on the strain-rate tensor guarantees the same behavior irrespective of strain rate magnitude. Strength of regularization Extra spectral width As a rule-of-thumb, regularization affects the highest ( \\(l=L\\) ) and next-highest ( \\(l=L-2\\) ) harmonics and can therefore not be expected to evolve freely. This, in turn, means that the structure tensors \\({\\bf a}^{(2)}\\) and \\({\\bf a}^{(4)}\\) , and hence derived enhancement factors , might be affected by regularization unless extra spectral width is dedicated by setting \\(L{\\geq}8\\) .","title":"Regularization"},{"location":"cpo-representation/","text":"Representation The Crystallographic Preferred Orientation (CPO) of polycrystalline materials is represented by the distribution of crystal axes in orientation space, \\(S^2\\) , weighted by grain size. Supported grain symmetries, are: Grain symmetry CPO components Definition Transversely isotropic \\(n(\\theta,\\phi)\\) Distribution of slip-plane normals Orthotropic \\(n(\\theta,\\phi),\\,b(\\theta,\\phi)\\) Distribution of slip-plane normals and slip directions Depending on which crystallographic slip system is preferentially activated, \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) refer to the distributions of different crystallographic axes. Glacier ice Polycrystalline ice Ensemble of slip elements Since ice grains are approximately transversely isotropic, tracking \\(n(\\theta,\\phi)\\) (the \\(c\\) -axis distribution) is sufficient for representing the CPO of glacier ice. Olivine Polycrystalline olivine Ensemble of slip elements For orthotropic grains such as olivine, both \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) distributions must be tracked to represent the CPO. Notice : \\(n\\) and \\(b\\) represent the distributions of a particular crystallographic axes, depending on fabric type (A\u2014E type). Background In specfab , CPOs are defined as the orientation distribution of grains without any reference to grain topology, grain shape, or the spatial arrangement of grains. More precisely, this means statistically describing the directions in which the slip-plane normal and slip direction of grains ( \\(n\\) - and \\(b\\) -axes) are pointing, while also taking into account how massive each grain is (weighted by grain size). The mass-density orientation distribution function \\(\\rho^{*}({\\bf n},{\\bf b})\\) describes how grain mass is distributed in the space of possible grain orientations ( Faria, 2006 ), where \\({\\bf n}(\\theta,\\phi)\\) and \\({\\bf b}(\\theta,\\phi)\\) are arbitrary \\(n\\) - and \\(b\\) -axes (radial unit vectors). Since \\(\\rho^{*}\\) is by definition normalized by the polycrystal volume, integrating \\(\\rho^{*}\\) over all possible grain orientations recovers the mass density of the polycrystal (e.g., \\(\\rho=917\\) kg/m \\(^3\\) for glacier ice): $$ \\rho = \\int_{S^2} \\int_{S^2} \\rho^{*}({\\bf n},{\\bf b}) \\,\\mathrm{d}^2{\\bf b}\\, \\mathrm{d}^2{\\bf n} , $$ where integration is restricted to the surface of the unit sphere \\(S^2\\) and \\(\\mathrm{d}^2{\\bf n}=\\sin(\\theta)\\,\\mathrm{d}{\\theta}\\,\\mathrm{d}{\\phi}\\) is the infinitesimal solid angle in spherical coordinates (similarly for \\({\\bf b}\\) ). Ambiguity Notice that defining the CPO in this way introduces some ambiguity. The contribution to \\(\\rho^{*}({\\bf n},{\\bf b})\\) from two grains with identical mass \\(m\\) and orientation is indistinguishable from a single grain with the same orientation but twice the mass, \\(2m\\) . Nonetheless, how well \\(\\rho^{*}({\\bf n},{\\bf b})\\) represents a CPO should ultimately be judged by whether it contains the information necessary to calculate CPO-induced properties to some desired accuracy (say, bulk mechanical anisotropy); not by how simplified it is to disregard the spatial (topological) information of grains. Glacier ice In the case of ice, specfab treats for simplicity all monocrystal properties as isotropic in the basal plane (transverse isotropy). This popular approach simplifies the problem significantly: since it does not matter in which direction \\(b\\) -axes (crystal \\(a\\) -axes) point, there is no need to track how they are distributed. Let therefore \\(n(\\theta,\\phi)\\) be the corresponding normalized, marginal distribution function of the grain mass-density in the space of possible \\(n\\) -axis orientations (crystal \\(c\\) -axis orientations): $$ n(\\theta,\\phi) = \\frac{\\int_{S^2} \\rho^{*}({\\bf n},{\\bf b})\\,\\mathrm{d}^2{\\bf b}}{\\rho} . $$ Olivine More complicated minerals like olivine are represented by also tracking the marginal distribution of slip directions: $$ b(\\theta,\\phi) = \\frac{\\int_{S^2} \\rho^{*}({\\bf n},{\\bf b})\\,\\mathrm{d}^2{\\bf n}}{\\rho} . $$ If needed, the joint distribution function \\(\\rho^{*}({\\bf n},{\\bf b})\\) can be estimated from its marginal distributions following the identity for conditional probability density functions and some assumptions . Mass or number density distributions? The normalized, marginal distributions \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) are typically referred to as Mass Orientation Distribution Functions (MODFs) or Orientation Mass Distributions (OMDs). In the literature, number-density distributions, rather than mass-density, frequently appear. In this case, \\(n(\\theta,\\phi)/N\\) and \\(b(\\theta,\\phi)/N\\) are referred to as the normalized Orientation Distribution Functions (ODFs) of slip-plane normals and slip directions, respectively, where \\(N = \\int_{S^2} n(\\theta,\\phi) \\,\\mathrm{d}^2{\\bf n}\\) is the total number of grains. In the models of crystal processes available in specfab , the normalization is conserved and the two views give, in effect, the same result. The mass-density interpretation representation rests, however, on stronger physical grounds, since mass is conserved whereas grain numbers are not. Harmonic expansion The distributions \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) are represented as an expansion series in spherical harmonics \\[ n(\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}n_{l}^{m}Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip-plane normals)}, \\] \\[ b(\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}b_{l}^{m}Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip directions)}. \\] The CPO state is therefore described by the state vectors of complex-valued expansion coefficients \\[ {\\bf s}_n = [n_0^0,n_2^{-2},n_2^{-1},n_2^{0},n_2^{1},n_2^{2},n_4^{-4},\\cdots,n_4^{4},\\cdots,n_L^{-L},\\cdots,n_L^{L}] \\quad\\text{($n$ state vector)}, \\] \\[ {\\bf s}_b = [b_0^0,b_2^{-2},b_2^{-1},b_2^{0},b_2^{1},b_2^{2},b_4^{-4},\\cdots,b_4^{4},\\cdots,b_L^{-L},\\cdots,b_L^{L}] \\quad\\text{($b$ state vector)}, \\] where the magnitude and complex phase of each coefficient determines the size and rotation that a given harmonic contributes with. Reduced form Not all expansion coefficients are independent for real-valued expansion series, but must fulfill \\[ n_l^{-m}=(-1)^m(n_l^m)^* , \\] \\[ b_l^{-m}=(-1)^m(b_l^m)^* . \\] This can be taken advantage of for large problems where many (e.g. gridded) CPOs must be stored in memory, thereby reducing the dimensionality of the problem. The vectors of reduced expansion coefficients are defined as \\[ \\tilde{{\\bf s}}_n = [n_0^0,n_2^{0},n_2^{1},n_2^{2},n_4^{0},\\cdots,n_4^{4},\\cdots,n_L^{0},\\cdots,n_L^{L}] \\quad\\text{(reduced $n$ state vector)}. \\] \\[ \\tilde{{\\bf s}}_b = [b_0^0,b_2^{0},b_2^{1},b_2^{2},b_4^{0},\\cdots,b_4^{4},\\cdots,b_L^{0},\\cdots,b_L^{L}] \\quad\\text{(reduced $b$ state vector)}. \\] Converting between full and reduced forms is done as follows (similarly for \\(\\tilde{{\\bf s}}_b\\) ): import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(6) ### Construct an arbitrary fabric a2 = np.diag([0.1,0.2,0.7]) # arbitrary second-order structure tensor nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients nlm[:sf.L2len] = sf.a2_to_nlm(a2) # l<=2 expansion coefficients from a2 print('original:', nlm) ### Get reduced form of coefficient array, rnlm rnlm_len = sf.get_rnlm_len() rnlm = np.zeros((rnlm_len), dtype=np.complex64) # array of reduced expansion coefficients rnlm[:] = sf.nlm_to_rnlm(nlm, rnlm_len) # reduced form print('reduced:', rnlm) ### Recover full form (nlm) from reduced form (rnlm) nlm[:] = sf.rnlm_to_nlm(rnlm, nlm_len) print('recovered:', nlm)","title":"Representation"},{"location":"cpo-representation/#representation","text":"The Crystallographic Preferred Orientation (CPO) of polycrystalline materials is represented by the distribution of crystal axes in orientation space, \\(S^2\\) , weighted by grain size. Supported grain symmetries, are: Grain symmetry CPO components Definition Transversely isotropic \\(n(\\theta,\\phi)\\) Distribution of slip-plane normals Orthotropic \\(n(\\theta,\\phi),\\,b(\\theta,\\phi)\\) Distribution of slip-plane normals and slip directions Depending on which crystallographic slip system is preferentially activated, \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) refer to the distributions of different crystallographic axes. Glacier ice Polycrystalline ice Ensemble of slip elements Since ice grains are approximately transversely isotropic, tracking \\(n(\\theta,\\phi)\\) (the \\(c\\) -axis distribution) is sufficient for representing the CPO of glacier ice. Olivine Polycrystalline olivine Ensemble of slip elements For orthotropic grains such as olivine, both \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) distributions must be tracked to represent the CPO. Notice : \\(n\\) and \\(b\\) represent the distributions of a particular crystallographic axes, depending on fabric type (A\u2014E type).","title":"Representation"},{"location":"cpo-representation/#background","text":"In specfab , CPOs are defined as the orientation distribution of grains without any reference to grain topology, grain shape, or the spatial arrangement of grains. More precisely, this means statistically describing the directions in which the slip-plane normal and slip direction of grains ( \\(n\\) - and \\(b\\) -axes) are pointing, while also taking into account how massive each grain is (weighted by grain size). The mass-density orientation distribution function \\(\\rho^{*}({\\bf n},{\\bf b})\\) describes how grain mass is distributed in the space of possible grain orientations ( Faria, 2006 ), where \\({\\bf n}(\\theta,\\phi)\\) and \\({\\bf b}(\\theta,\\phi)\\) are arbitrary \\(n\\) - and \\(b\\) -axes (radial unit vectors). Since \\(\\rho^{*}\\) is by definition normalized by the polycrystal volume, integrating \\(\\rho^{*}\\) over all possible grain orientations recovers the mass density of the polycrystal (e.g., \\(\\rho=917\\) kg/m \\(^3\\) for glacier ice): $$ \\rho = \\int_{S^2} \\int_{S^2} \\rho^{*}({\\bf n},{\\bf b}) \\,\\mathrm{d}^2{\\bf b}\\, \\mathrm{d}^2{\\bf n} , $$ where integration is restricted to the surface of the unit sphere \\(S^2\\) and \\(\\mathrm{d}^2{\\bf n}=\\sin(\\theta)\\,\\mathrm{d}{\\theta}\\,\\mathrm{d}{\\phi}\\) is the infinitesimal solid angle in spherical coordinates (similarly for \\({\\bf b}\\) ). Ambiguity Notice that defining the CPO in this way introduces some ambiguity. The contribution to \\(\\rho^{*}({\\bf n},{\\bf b})\\) from two grains with identical mass \\(m\\) and orientation is indistinguishable from a single grain with the same orientation but twice the mass, \\(2m\\) . Nonetheless, how well \\(\\rho^{*}({\\bf n},{\\bf b})\\) represents a CPO should ultimately be judged by whether it contains the information necessary to calculate CPO-induced properties to some desired accuracy (say, bulk mechanical anisotropy); not by how simplified it is to disregard the spatial (topological) information of grains. Glacier ice In the case of ice, specfab treats for simplicity all monocrystal properties as isotropic in the basal plane (transverse isotropy). This popular approach simplifies the problem significantly: since it does not matter in which direction \\(b\\) -axes (crystal \\(a\\) -axes) point, there is no need to track how they are distributed. Let therefore \\(n(\\theta,\\phi)\\) be the corresponding normalized, marginal distribution function of the grain mass-density in the space of possible \\(n\\) -axis orientations (crystal \\(c\\) -axis orientations): $$ n(\\theta,\\phi) = \\frac{\\int_{S^2} \\rho^{*}({\\bf n},{\\bf b})\\,\\mathrm{d}^2{\\bf b}}{\\rho} . $$ Olivine More complicated minerals like olivine are represented by also tracking the marginal distribution of slip directions: $$ b(\\theta,\\phi) = \\frac{\\int_{S^2} \\rho^{*}({\\bf n},{\\bf b})\\,\\mathrm{d}^2{\\bf n}}{\\rho} . $$ If needed, the joint distribution function \\(\\rho^{*}({\\bf n},{\\bf b})\\) can be estimated from its marginal distributions following the identity for conditional probability density functions and some assumptions .","title":"Background"},{"location":"cpo-representation/#mass-or-number-density-distributions","text":"The normalized, marginal distributions \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) are typically referred to as Mass Orientation Distribution Functions (MODFs) or Orientation Mass Distributions (OMDs). In the literature, number-density distributions, rather than mass-density, frequently appear. In this case, \\(n(\\theta,\\phi)/N\\) and \\(b(\\theta,\\phi)/N\\) are referred to as the normalized Orientation Distribution Functions (ODFs) of slip-plane normals and slip directions, respectively, where \\(N = \\int_{S^2} n(\\theta,\\phi) \\,\\mathrm{d}^2{\\bf n}\\) is the total number of grains. In the models of crystal processes available in specfab , the normalization is conserved and the two views give, in effect, the same result. The mass-density interpretation representation rests, however, on stronger physical grounds, since mass is conserved whereas grain numbers are not.","title":"Mass or number density distributions?"},{"location":"cpo-representation/#harmonic-expansion","text":"The distributions \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) are represented as an expansion series in spherical harmonics \\[ n(\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}n_{l}^{m}Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip-plane normals)}, \\] \\[ b(\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}b_{l}^{m}Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip directions)}. \\] The CPO state is therefore described by the state vectors of complex-valued expansion coefficients \\[ {\\bf s}_n = [n_0^0,n_2^{-2},n_2^{-1},n_2^{0},n_2^{1},n_2^{2},n_4^{-4},\\cdots,n_4^{4},\\cdots,n_L^{-L},\\cdots,n_L^{L}] \\quad\\text{($n$ state vector)}, \\] \\[ {\\bf s}_b = [b_0^0,b_2^{-2},b_2^{-1},b_2^{0},b_2^{1},b_2^{2},b_4^{-4},\\cdots,b_4^{4},\\cdots,b_L^{-L},\\cdots,b_L^{L}] \\quad\\text{($b$ state vector)}, \\] where the magnitude and complex phase of each coefficient determines the size and rotation that a given harmonic contributes with.","title":"Harmonic expansion"},{"location":"cpo-representation/#reduced-form","text":"Not all expansion coefficients are independent for real-valued expansion series, but must fulfill \\[ n_l^{-m}=(-1)^m(n_l^m)^* , \\] \\[ b_l^{-m}=(-1)^m(b_l^m)^* . \\] This can be taken advantage of for large problems where many (e.g. gridded) CPOs must be stored in memory, thereby reducing the dimensionality of the problem. The vectors of reduced expansion coefficients are defined as \\[ \\tilde{{\\bf s}}_n = [n_0^0,n_2^{0},n_2^{1},n_2^{2},n_4^{0},\\cdots,n_4^{4},\\cdots,n_L^{0},\\cdots,n_L^{L}] \\quad\\text{(reduced $n$ state vector)}. \\] \\[ \\tilde{{\\bf s}}_b = [b_0^0,b_2^{0},b_2^{1},b_2^{2},b_4^{0},\\cdots,b_4^{4},\\cdots,b_L^{0},\\cdots,b_L^{L}] \\quad\\text{(reduced $b$ state vector)}. \\] Converting between full and reduced forms is done as follows (similarly for \\(\\tilde{{\\bf s}}_b\\) ): import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(6) ### Construct an arbitrary fabric a2 = np.diag([0.1,0.2,0.7]) # arbitrary second-order structure tensor nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients nlm[:sf.L2len] = sf.a2_to_nlm(a2) # l<=2 expansion coefficients from a2 print('original:', nlm) ### Get reduced form of coefficient array, rnlm rnlm_len = sf.get_rnlm_len() rnlm = np.zeros((rnlm_len), dtype=np.complex64) # array of reduced expansion coefficients rnlm[:] = sf.nlm_to_rnlm(nlm, rnlm_len) # reduced form print('reduced:', rnlm) ### Recover full form (nlm) from reduced form (rnlm) nlm[:] = sf.rnlm_to_nlm(rnlm, nlm_len) print('recovered:', nlm)","title":"Reduced form"},{"location":"cpo-rotation/","text":"Rotate CPO Rotating the harmonic expansion series by \\(\\theta\\) about the \\(y\\) -axis, followed by \\(\\phi\\) about the \\(z\\) -axis, can be done in the following way: import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(8) ### Construct an arbitrary fabric to rotate a2 = np.diag([0, 0, 1]) # arbitrary second-order structure tensor nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients nlm[:sf.L2len] = sf.a2_to_nlm(a2) # l<=2 expansion coefficients ### Rotate ODF # Note: assumes L=<12 (rotation for larger L is not implemented) theta = np.deg2rad(-45) phi = np.deg2rad(45) nlm_rot1 = sf.rotate_nlm(nlm, theta, 0) # first rotate around y axis in xz plane nlm_rot2 = sf.rotate_nlm(nlm_rot1, 0, phi) # next rotate around z axis in xy plane nlm_rot3 = sf.rotate_nlm(nlm_rot2, -theta, -phi) # rotate back","title":"Rotate CPO"},{"location":"cpo-rotation/#rotate-cpo","text":"Rotating the harmonic expansion series by \\(\\theta\\) about the \\(y\\) -axis, followed by \\(\\phi\\) about the \\(z\\) -axis, can be done in the following way: import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(8) ### Construct an arbitrary fabric to rotate a2 = np.diag([0, 0, 1]) # arbitrary second-order structure tensor nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients nlm[:sf.L2len] = sf.a2_to_nlm(a2) # l<=2 expansion coefficients ### Rotate ODF # Note: assumes L=<12 (rotation for larger L is not implemented) theta = np.deg2rad(-45) phi = np.deg2rad(45) nlm_rot1 = sf.rotate_nlm(nlm, theta, 0) # first rotate around y axis in xz plane nlm_rot2 = sf.rotate_nlm(nlm_rot1, 0, phi) # next rotate around z axis in xy plane nlm_rot3 = sf.rotate_nlm(nlm_rot2, -theta, -phi) # rotate back","title":"Rotate CPO"},{"location":"cpo-structuretensors/","text":"Structure tensors Structure tensors \\({\\bf a}^{(k)}\\) are defined as the mean of the \\(k\\) -th repeated outer product of a crystallographic axis with itself, say \\(\\bf n\\) : \\[ {\\bf a}^{(k)} := \\langle {\\bf n}^k \\rangle. \\] In the case of a discrete ensemble of \\(N\\) grains with slip plane normals \\({\\bf n}_i\\) for \\(i=1,\\cdots,N\\) , the structure tensors are \\[ {\\bf a}^{(k)} = \\dfrac{\\sum_i w_i {\\bf n}_i^k}{\\sum_i w_i}, \\] where \\(w_i\\) is the weight attributed to the \\(i\\) -th grain, typically its size. Alternatively, if the distribution function \\(n(\\theta,\\phi)\\) of \\({\\bf n}\\) -axes is known, the structure tensors are \\[ {\\bf a}^{(k)} = \\dfrac{\\int_{S^2} n \\hat{{\\bf r}}^k \\, \\mathrm{d}\\Omega}{\\int_{S^2} n \\, \\mathrm{d}\\Omega} , \\] where \\(\\mathrm{d}\\Omega = \\sin(\\theta) \\mathrm{d}\\theta \\mathrm{d}\\phi\\) is the infinitesimal solid angle and \\(\\hat{{\\bf r}}(\\theta,\\phi)\\) is the radial unit vector. Principal frame Since \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) are antipodally symmetric, odd moments (odd \\(k\\) ) vanish identically. Hence, \\({\\bf a}^{(2)}(n)\\) and \\({\\bf a}^{(2)}(b)\\) measure the variance of \\(\\bf n\\) - and \\(\\bf b\\) -axes, respectively, around the three coordinate axes. Posing \\({\\bf a}^{(2)}\\) in its principal frame \\[ {\\bf a}^{(2)} = \\left[\\begin{matrix} \\lambda_1 & 0 & 0\\\\ 0 & \\lambda_2 & 0\\\\ 0 & 0 & \\lambda_3\\\\ \\end{matrix}\\right] \\] therefore has a similar interpretation as in PCA: the first principal component (eigenvector \\({\\bf m}_1\\) ) is the direction that maximizes the variance (eigenvalue \\(\\lambda_1\\) ) of the projected data (red curve), the second component is the direction orthogonal to the first component that maximizes the variance of the projected data, and so on with the third component. Convert to spectral Converting between spectral and tensorial representations is a linear problem in the sense that \\[ {\\bf a}^{(k)} = {\\bf f}(\\hat{n}_2^{m}, \\hat{n}_4^{m}, \\cdots, \\hat{n}_k^{m}) , \\qquad\\text{(for all $m$)} \\] where \\({\\bf f}\\) is linear in its arguments and \\(\\hat{n}_l^m = n_l^m/n_0^0\\) . In the case of \\({\\bf a}^{(2)}\\) , the relation is simple: \\[ {\\bf a}^{(2)} = \\frac{{\\bf I}}{3} + \\sqrt{\\frac{2}{15}} \\left[\\begin{matrix} \\operatorname{Re}[\\hat{n}_2^2] - \\dfrac{1}{2}\\sqrt{\\dfrac{2}{3}} \\hat{n}_2^0 & -\\operatorname{Im}[\\hat{n}_2^2] & -\\operatorname{Re}[\\hat{n}_2^1] \\\\ & -\\operatorname{Re}[\\hat{n}_2^2] - \\dfrac{1}{2}\\sqrt{\\dfrac{2}{3}} \\hat{n}_2^0 & \\operatorname{Im}[\\hat{n}_2^1] \\\\ \\mathrm{sym.} & & \\sqrt{\\dfrac{2}{3}} \\hat{n}_2^0 \\end{matrix}\\right] , \\] but for higher-order structure tensors the expressions are long (not shown). The above applies to \\(b(\\theta,\\phi)\\) as well. The following code example shows how to convert between the two CPO representations: import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(8) nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients ### a2 to nlm a2 = np.diag([0.0,0.25,0.75]) # arbitrary second-order structure tensor nlm[:sf.L2len] = sf.a2_to_nlm(a2) # l<=2 expansion coefficients a2 = sf.a2(nlm) # nlm back to a2 print('a2 is: ', a2) ### a4 to nlm p = np.array([0,0,1]) # unidirectional CPO a4 = np.einsum('i,j,k,l', p,p,p,p) # a4 for ODF = deltafunc(r-p) nlm[:sf.L4len] = sf.a4_to_nlm(a4) # l<=4 expansion coefficients a4 = sf.a4(nlm) # nlm back to a4 print('a4 is: ', a4) ### a6 to nlm p = np.array([0,0,1]) # unidirectional CPO a6 = np.einsum('i,j,k,l,m,n', p,p,p,p,p,p) # a6 for ODF = deltafunc(r-p) nlm[:sf.L6len] = sf.a6_to_nlm(a6) # l<=6 expansion coefficients a6 = sf.a6(nlm) # nlm back to a6 print('a6 is: ', a6) Construct from measurements The harmonic expansion coefficients of any CPO can be determined from discrete measurements of its crystallographic axes. This requires constructing the corresponding structure tensors (of each crystallographic axis), from which the expansion coefficients may be derived. In the case of glacier ice where \\({\\bf n} = {\\bf c}\\) , this can be done as follows: import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(8) ### Replace with your own array/list of measured c-axes # caxes = [[c1x,c1y,c1z], [c2x,c2y,c2z], ...] ### Determine sixth-order structure tensor, a6 a6 = np.zeros((3,3,3,3,3,3)) for c in caxes a6 += np.einsum('i,j,k,l,m,n', c,c,c,c,c,c) # sixth outer product of c-axis with itself a6 /= len(caxes) # normalize by number of c-axes (grains) if grain sizes are not known ### Determine spectral expansion coefficients nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients nlm[:sf.L6len] = sf.a6_to_nlm(a6) # l<=6 expansion coefficients Note that constructing \\({\\bf a}^{(6)}\\) is to be preferred over \\({\\bf a}^{(4)}\\) and \\({\\bf a}^{(2)}\\) , since it contains more information on the fine-scale structure of the distribution: \\({\\bf a}^{(6)}\\) encodes information about the expansion coefficients \\(l\\leq 6\\) , \\({\\bf a}^{(4)}\\) about \\(l\\leq 4\\) , and \\({\\bf a}^{(2)}\\) about \\(l\\leq 2\\) .","title":"Structure tensors"},{"location":"cpo-structuretensors/#structure-tensors","text":"Structure tensors \\({\\bf a}^{(k)}\\) are defined as the mean of the \\(k\\) -th repeated outer product of a crystallographic axis with itself, say \\(\\bf n\\) : \\[ {\\bf a}^{(k)} := \\langle {\\bf n}^k \\rangle. \\] In the case of a discrete ensemble of \\(N\\) grains with slip plane normals \\({\\bf n}_i\\) for \\(i=1,\\cdots,N\\) , the structure tensors are \\[ {\\bf a}^{(k)} = \\dfrac{\\sum_i w_i {\\bf n}_i^k}{\\sum_i w_i}, \\] where \\(w_i\\) is the weight attributed to the \\(i\\) -th grain, typically its size. Alternatively, if the distribution function \\(n(\\theta,\\phi)\\) of \\({\\bf n}\\) -axes is known, the structure tensors are \\[ {\\bf a}^{(k)} = \\dfrac{\\int_{S^2} n \\hat{{\\bf r}}^k \\, \\mathrm{d}\\Omega}{\\int_{S^2} n \\, \\mathrm{d}\\Omega} , \\] where \\(\\mathrm{d}\\Omega = \\sin(\\theta) \\mathrm{d}\\theta \\mathrm{d}\\phi\\) is the infinitesimal solid angle and \\(\\hat{{\\bf r}}(\\theta,\\phi)\\) is the radial unit vector.","title":"Structure tensors"},{"location":"cpo-structuretensors/#principal-frame","text":"Since \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) are antipodally symmetric, odd moments (odd \\(k\\) ) vanish identically. Hence, \\({\\bf a}^{(2)}(n)\\) and \\({\\bf a}^{(2)}(b)\\) measure the variance of \\(\\bf n\\) - and \\(\\bf b\\) -axes, respectively, around the three coordinate axes. Posing \\({\\bf a}^{(2)}\\) in its principal frame \\[ {\\bf a}^{(2)} = \\left[\\begin{matrix} \\lambda_1 & 0 & 0\\\\ 0 & \\lambda_2 & 0\\\\ 0 & 0 & \\lambda_3\\\\ \\end{matrix}\\right] \\] therefore has a similar interpretation as in PCA: the first principal component (eigenvector \\({\\bf m}_1\\) ) is the direction that maximizes the variance (eigenvalue \\(\\lambda_1\\) ) of the projected data (red curve), the second component is the direction orthogonal to the first component that maximizes the variance of the projected data, and so on with the third component.","title":"Principal frame"},{"location":"cpo-structuretensors/#convert-to-spectral","text":"Converting between spectral and tensorial representations is a linear problem in the sense that \\[ {\\bf a}^{(k)} = {\\bf f}(\\hat{n}_2^{m}, \\hat{n}_4^{m}, \\cdots, \\hat{n}_k^{m}) , \\qquad\\text{(for all $m$)} \\] where \\({\\bf f}\\) is linear in its arguments and \\(\\hat{n}_l^m = n_l^m/n_0^0\\) . In the case of \\({\\bf a}^{(2)}\\) , the relation is simple: \\[ {\\bf a}^{(2)} = \\frac{{\\bf I}}{3} + \\sqrt{\\frac{2}{15}} \\left[\\begin{matrix} \\operatorname{Re}[\\hat{n}_2^2] - \\dfrac{1}{2}\\sqrt{\\dfrac{2}{3}} \\hat{n}_2^0 & -\\operatorname{Im}[\\hat{n}_2^2] & -\\operatorname{Re}[\\hat{n}_2^1] \\\\ & -\\operatorname{Re}[\\hat{n}_2^2] - \\dfrac{1}{2}\\sqrt{\\dfrac{2}{3}} \\hat{n}_2^0 & \\operatorname{Im}[\\hat{n}_2^1] \\\\ \\mathrm{sym.} & & \\sqrt{\\dfrac{2}{3}} \\hat{n}_2^0 \\end{matrix}\\right] , \\] but for higher-order structure tensors the expressions are long (not shown). The above applies to \\(b(\\theta,\\phi)\\) as well. The following code example shows how to convert between the two CPO representations: import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(8) nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients ### a2 to nlm a2 = np.diag([0.0,0.25,0.75]) # arbitrary second-order structure tensor nlm[:sf.L2len] = sf.a2_to_nlm(a2) # l<=2 expansion coefficients a2 = sf.a2(nlm) # nlm back to a2 print('a2 is: ', a2) ### a4 to nlm p = np.array([0,0,1]) # unidirectional CPO a4 = np.einsum('i,j,k,l', p,p,p,p) # a4 for ODF = deltafunc(r-p) nlm[:sf.L4len] = sf.a4_to_nlm(a4) # l<=4 expansion coefficients a4 = sf.a4(nlm) # nlm back to a4 print('a4 is: ', a4) ### a6 to nlm p = np.array([0,0,1]) # unidirectional CPO a6 = np.einsum('i,j,k,l,m,n', p,p,p,p,p,p) # a6 for ODF = deltafunc(r-p) nlm[:sf.L6len] = sf.a6_to_nlm(a6) # l<=6 expansion coefficients a6 = sf.a6(nlm) # nlm back to a6 print('a6 is: ', a6)","title":"Convert to spectral"},{"location":"cpo-structuretensors/#construct-from-measurements","text":"The harmonic expansion coefficients of any CPO can be determined from discrete measurements of its crystallographic axes. This requires constructing the corresponding structure tensors (of each crystallographic axis), from which the expansion coefficients may be derived. In the case of glacier ice where \\({\\bf n} = {\\bf c}\\) , this can be done as follows: import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(8) ### Replace with your own array/list of measured c-axes # caxes = [[c1x,c1y,c1z], [c2x,c2y,c2z], ...] ### Determine sixth-order structure tensor, a6 a6 = np.zeros((3,3,3,3,3,3)) for c in caxes a6 += np.einsum('i,j,k,l,m,n', c,c,c,c,c,c) # sixth outer product of c-axis with itself a6 /= len(caxes) # normalize by number of c-axes (grains) if grain sizes are not known ### Determine spectral expansion coefficients nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients nlm[:sf.L6len] = sf.a6_to_nlm(a6) # l<=6 expansion coefficients Note that constructing \\({\\bf a}^{(6)}\\) is to be preferred over \\({\\bf a}^{(4)}\\) and \\({\\bf a}^{(2)}\\) , since it contains more information on the fine-scale structure of the distribution: \\({\\bf a}^{(6)}\\) encodes information about the expansion coefficients \\(l\\leq 6\\) , \\({\\bf a}^{(4)}\\) about \\(l\\leq 4\\) , and \\({\\bf a}^{(2)}\\) about \\(l\\leq 2\\) .","title":"Construct from measurements"},{"location":"deformation-kinematics/","text":"Deformation kinematics The deformation gradient tensor \\({\\bf F}\\) quantifies how infinitesimal material elements (line, area, or volume) are deformed relative to some original reference configuration. The strain tensor \\({\\boldsymbol \\epsilon}\\) is derived from \\({\\bf F}\\) and is a measure of how a material deforms, excluding rigid body motions like rotation and translation. In continuum mechanics, it is useful to isolate such pure deformation (stretching) from rigid body motion, since the viscous and elastic response of a material when subject external forces is concerned with how easy or hard it is to stretch a material. Small strain tensor The symmetric and antisymmetric parts of \\({\\bf F}\\) describe the degree of stretching and the rotation of material elements, respectively, useful for isolating pure deformation (stretching) from rigid body rotations. For small deformations, the strain tensor (formally small strain tensor) is therefore defined as the symmetric part of \\({\\bf F}\\) , minus the identity: $$ {\\boldsymbol \\epsilon} = \\frac{1}{2}\\left( {\\bf F}+{\\bf F}^\\top \\right) - {\\bf I}. $$ The strain tensor \\({\\boldsymbol \\epsilon}\\) characterizes how a material stretches, compresses, or shears: positive components indicate extension along certain directions, negative components indicate compression, and off-diagonal components correspond to shear deformation. The antisymmetric part of \\({\\bf F}\\) is related to the component of deformation that describes rigid body rotation (so-called rotation tensor), defined as $$ {\\bf w} = \\frac{1}{2}\\left( {\\bf F}-{\\bf F}^\\top \\right) + {\\bf I}. $$ Notice that \\({\\bf F}= {\\boldsymbol \\epsilon} + {\\bf w}\\) by definition. While the strain tensor is the kinematic field of interest for elastic deformation (elastic problems are concerned with displacement), the strain-rate and spin tensors are more relevant for viscous deformation (viscous problems are concerned with velocity, \\({\\bf u}\\) ). The strain-rate and spin tensors are simply the rate-of-change of \\({\\boldsymbol \\epsilon}\\) and \\({\\bf w}\\) , respectively: $$ {\\dot{\\boldsymbol\\epsilon}} = \\frac{1}{2}\\left(\\nabla {\\bf u} + \\nabla {\\bf u}^\\top\\right) , \\quad {\\boldsymbol\\omega} = \\frac{1}{2}\\left( \\nabla {\\bf u} - \\nabla {\\bf u}^\\top \\right) , $$ where the velocity gradient tensor is \\(\\nabla {\\bf u} = \\dot{{\\bf F}} \\cdot {\\bf F}^{-1}\\) . Kinematic modes Let us now turn to the two common kinematic modes of deformation, pure shear and simple shear, that we will encounter many times throughout this book. Introducing these kinematic modes in terms of their deformation gradient \\({\\bf F}\\) provides a powerful way to describe e.g. how ice deforms below ice divides and domes of ice sheets. Example of strain tensors Pure shear Pure shear (stretching) aligned with the Cartesian coordinate axes renders \\({\\bf F}\\) diagonal, a convenient frame to consider. Suppose shortening takes places along the vertical \\(z\\) -axis and lengthening in the horizontal \\(xy\\) plane so that volume is conserved ( \\(\\det({\\bf F})=1\\) ; incompressible material). The deformation gradient can then be written as \\[ {\\bf F} = \\begin{bmatrix} r^{-(1+q)/2} & 0 & 0\\\\ 0 & r^{-(1-q)/2} & 0\\\\ 0& 0& r \\end{bmatrix} , \\] where \\(r\\) is a scaling parameter that controls the relative vertical shortening of material lines, and \\(q\\in[-1;1]\\) determines the horizontal direction of lengthening: For \\(q=0\\) lengthening is equal in the \\(x\\) and \\(y\\) directions. For \\(q=+1\\) lengthening occurs only in the \\(x\\) direction. For \\(q=-1\\) lengthening occurs only in the \\(y\\) direction. The corresponding vertical strain with time follows immediately as \\begin{align} \\epsilon_{zz}(t) = r(t) - 1, \\end{align} where \\(\\epsilon_{zz} = 0\\) (or \\(F_{zz}=1\\) ) corresponds to the undeformed configuration and \\(\\epsilon_{zz} = -1\\) (or \\(F_{zz}=0\\) ) corresponds to the limit of a vanishing material (parcel) height. Conversely, if lengthening takes place along the vertical axis with shortening in the horizontal plane then \\({\\bf F}\\rightarrow {\\bf F}^{-1}\\) above, implying \\(r\\rightarrow r^{-1}\\) . Constant strain rate For pure shear of the above form, it can be shown that the velocity gradient tensor reduces to \\[ \\nabla {\\bf u} = \\frac{\\dot{r}}{r} \\begin{bmatrix} -(1+q)/2 & 0 & 0\\\\ 0 & -(1-q)/2 & 0\\\\ 0& 0& 1 \\end{bmatrix} . \\] Clearly, if \\(r\\) is written in terms of the \\(e\\) -folding time \\(\\tau\\) , \\[ r(t) = \\exp(-t/\\tau) , \\] the strain-rate tensor becomes constant. Specifically, the vertical component becomes \\[ \\epsilon_{zz} = -\\frac{1}{\\tau} . \\] Code example The above expressions are accessible in specfab as follows import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(4) axis = 2 # axis of shortening (tauc>0) or lengthening (tauc<0): 0=x, 1=y, 2=z tauc = 1 # time taken in seconds for parcel to reduce to half (50%) height if tauc>0, or abs(time) taken for parcel to double in height (200%) if tauc<0. q = 0 # asymmetry parameter for shortening (if tauc>0) or lengthening (if tauc<0) tau = tauc/np.log(2) # corresponding e-folding time ugrad = sf.pureshear_ugrad(axis, q, tau) # velocity gradient D, W = sf.ugrad_to_D_and_W(ugrad) # strain-rate and spin tensor t = 1 # some specific time of interest r = sf.pureshear_r(tau, t) # scaling parameter \"r\" at time t F = sf.pureshear_F(axis, q, tau, t) # deformation gradient tensor at time t eps = sf.F_to_strain(F) # strain tensor at time t Simple shear Simple shear may be characterized by the shear angle \\(\\gamma\\) of the resulting rhombus. In the case of vertical shear in the \\(xz\\) plane, the deformation gradient tensor is given by \\[ {\\bf F} = \\begin{bmatrix} 1 & 0 & \\tan(\\gamma) \\\\ 0 & 1 & 0\\\\ 0& 0& 1 \\end{bmatrix} , \\] and velocity-gradient tensor becomes \\[ \\nabla {\\bf u} = \\frac{\\dot{\\gamma}}{\\cos^2(\\gamma)} \\begin{bmatrix} 0 & 0 & 1\\\\ 0 & 0 & 0\\\\ 0& 0& 0 \\end{bmatrix} . \\] Constant strain rate For a constant rate of shear \\(1/\\tau\\) , where \\(\\tau\\) is a characteristic time, the prefactor is \\[\\begin{align} \\frac{\\dot{\\gamma}}{\\cos^2(\\gamma)} = \\frac{1}{\\tau} . \\end{align}\\] Solving for the time-dependent shear angle function can be shown to give \\[ \\gamma(t) = \\tan^{-1}(t/\\tau) . \\] Thus, \\(\\tau\\) is the time it takes to reach a shear angle of \\(\\gamma=45^\\circ\\) from the undeformed configuration, corresponding to \\(\\epsilon_{xz}=\\tan(45^\\circ)/2=0.5\\) . Code example The above expressions are accessible in specfab as follows import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(4) plane = 1 # plane of shear: 0=yz, 1=xz, 2=xy tau = 1 # time taken in seconds for parcel to a reach shear strain of 1 (45 deg shear angle) ugrad = sf.simpleshear_ugrad(plane, tau) # velocity gradient D, W = sf.ugrad_to_D_and_W(ugrad) # strain-rate and spin tensor t = 1 # some specific time of interest gamma = sf.simpleshear_gamma(tau, t) # shear angle at time t F = sf.simpleshear_F(plane, tau, t) # deformation gradient tensor at time t eps = sf.F_to_strain(F) # strain tensor at time t Plotting deformed parcels Given a deformation gradient \\({\\bf F}\\) , the resulting deformed parcel shape can be plotting as follows: import numpy as np import matplotlib.pyplot as plt from specfabpy import specfab as sf from specfabpy import plotting as sfplt lm, nlm_len = sf.init(4) ### Determine deformation gradient F # Pure shear axis = 2 # axis of compression/extension (0=x, 1=y, 2=z) q = 0 # deformation asymmetry tau_ps = 1/np.log(2) # e-folding time scale t_ps = 1 # time at which deformed parcel is sought F_ps = sf.pureshear_F(axis, q, tau_ps, t_ps) # deformation gradient tensor # Simple shear plane = 1 # shear plane (0=yz, 1=xz, 2=xy) tau_ss = 1 # characteristic time taken to reach shear strain 45 deg. t_ss = 1 # time at which deformed parcel is sought F_ss = sf.simpleshear_F(plane, tau_ss, t_ss) # deformation gradient tensor ### Plot fig = plt.figure(figsize=(6,6)) ax1 = plt.subplot(121, projection='3d') ax2 = plt.subplot(122, projection='3d') sfplt.plotparcel(ax1, F_ps, azim=35, axscale=1.7, axislabels=True, drawinit=True) sfplt.plotparcel(ax2, F_ss, azim=35, axscale=1.7, axislabels=True, drawinit=True) ax1.set_title(r'$\\epsilon_{zz}=%.2f$'%(sf.F_to_strain(F_ps)[2,2])) ax2.set_title(r'$\\gamma=%.0f$ deg.'%(np.rad2deg(sf.simpleshear_gamma(tau_ss, t_ss)))) plt.savefig('deformed-parcel.png', dpi=175, pad_inches=0.1, bbox_inches='tight')","title":"Deformation kinematics"},{"location":"deformation-kinematics/#deformation-kinematics","text":"The deformation gradient tensor \\({\\bf F}\\) quantifies how infinitesimal material elements (line, area, or volume) are deformed relative to some original reference configuration. The strain tensor \\({\\boldsymbol \\epsilon}\\) is derived from \\({\\bf F}\\) and is a measure of how a material deforms, excluding rigid body motions like rotation and translation. In continuum mechanics, it is useful to isolate such pure deformation (stretching) from rigid body motion, since the viscous and elastic response of a material when subject external forces is concerned with how easy or hard it is to stretch a material.","title":"Deformation kinematics"},{"location":"deformation-kinematics/#small-strain-tensor","text":"The symmetric and antisymmetric parts of \\({\\bf F}\\) describe the degree of stretching and the rotation of material elements, respectively, useful for isolating pure deformation (stretching) from rigid body rotations. For small deformations, the strain tensor (formally small strain tensor) is therefore defined as the symmetric part of \\({\\bf F}\\) , minus the identity: $$ {\\boldsymbol \\epsilon} = \\frac{1}{2}\\left( {\\bf F}+{\\bf F}^\\top \\right) - {\\bf I}. $$ The strain tensor \\({\\boldsymbol \\epsilon}\\) characterizes how a material stretches, compresses, or shears: positive components indicate extension along certain directions, negative components indicate compression, and off-diagonal components correspond to shear deformation. The antisymmetric part of \\({\\bf F}\\) is related to the component of deformation that describes rigid body rotation (so-called rotation tensor), defined as $$ {\\bf w} = \\frac{1}{2}\\left( {\\bf F}-{\\bf F}^\\top \\right) + {\\bf I}. $$ Notice that \\({\\bf F}= {\\boldsymbol \\epsilon} + {\\bf w}\\) by definition. While the strain tensor is the kinematic field of interest for elastic deformation (elastic problems are concerned with displacement), the strain-rate and spin tensors are more relevant for viscous deformation (viscous problems are concerned with velocity, \\({\\bf u}\\) ). The strain-rate and spin tensors are simply the rate-of-change of \\({\\boldsymbol \\epsilon}\\) and \\({\\bf w}\\) , respectively: $$ {\\dot{\\boldsymbol\\epsilon}} = \\frac{1}{2}\\left(\\nabla {\\bf u} + \\nabla {\\bf u}^\\top\\right) , \\quad {\\boldsymbol\\omega} = \\frac{1}{2}\\left( \\nabla {\\bf u} - \\nabla {\\bf u}^\\top \\right) , $$ where the velocity gradient tensor is \\(\\nabla {\\bf u} = \\dot{{\\bf F}} \\cdot {\\bf F}^{-1}\\) .","title":"Small strain tensor"},{"location":"deformation-kinematics/#kinematic-modes","text":"Let us now turn to the two common kinematic modes of deformation, pure shear and simple shear, that we will encounter many times throughout this book. Introducing these kinematic modes in terms of their deformation gradient \\({\\bf F}\\) provides a powerful way to describe e.g. how ice deforms below ice divides and domes of ice sheets. Example of strain tensors","title":"Kinematic modes"},{"location":"deformation-kinematics/#pure-shear","text":"Pure shear (stretching) aligned with the Cartesian coordinate axes renders \\({\\bf F}\\) diagonal, a convenient frame to consider. Suppose shortening takes places along the vertical \\(z\\) -axis and lengthening in the horizontal \\(xy\\) plane so that volume is conserved ( \\(\\det({\\bf F})=1\\) ; incompressible material). The deformation gradient can then be written as \\[ {\\bf F} = \\begin{bmatrix} r^{-(1+q)/2} & 0 & 0\\\\ 0 & r^{-(1-q)/2} & 0\\\\ 0& 0& r \\end{bmatrix} , \\] where \\(r\\) is a scaling parameter that controls the relative vertical shortening of material lines, and \\(q\\in[-1;1]\\) determines the horizontal direction of lengthening: For \\(q=0\\) lengthening is equal in the \\(x\\) and \\(y\\) directions. For \\(q=+1\\) lengthening occurs only in the \\(x\\) direction. For \\(q=-1\\) lengthening occurs only in the \\(y\\) direction. The corresponding vertical strain with time follows immediately as \\begin{align} \\epsilon_{zz}(t) = r(t) - 1, \\end{align} where \\(\\epsilon_{zz} = 0\\) (or \\(F_{zz}=1\\) ) corresponds to the undeformed configuration and \\(\\epsilon_{zz} = -1\\) (or \\(F_{zz}=0\\) ) corresponds to the limit of a vanishing material (parcel) height. Conversely, if lengthening takes place along the vertical axis with shortening in the horizontal plane then \\({\\bf F}\\rightarrow {\\bf F}^{-1}\\) above, implying \\(r\\rightarrow r^{-1}\\) . Constant strain rate For pure shear of the above form, it can be shown that the velocity gradient tensor reduces to \\[ \\nabla {\\bf u} = \\frac{\\dot{r}}{r} \\begin{bmatrix} -(1+q)/2 & 0 & 0\\\\ 0 & -(1-q)/2 & 0\\\\ 0& 0& 1 \\end{bmatrix} . \\] Clearly, if \\(r\\) is written in terms of the \\(e\\) -folding time \\(\\tau\\) , \\[ r(t) = \\exp(-t/\\tau) , \\] the strain-rate tensor becomes constant. Specifically, the vertical component becomes \\[ \\epsilon_{zz} = -\\frac{1}{\\tau} . \\] Code example The above expressions are accessible in specfab as follows import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(4) axis = 2 # axis of shortening (tauc>0) or lengthening (tauc<0): 0=x, 1=y, 2=z tauc = 1 # time taken in seconds for parcel to reduce to half (50%) height if tauc>0, or abs(time) taken for parcel to double in height (200%) if tauc<0. q = 0 # asymmetry parameter for shortening (if tauc>0) or lengthening (if tauc<0) tau = tauc/np.log(2) # corresponding e-folding time ugrad = sf.pureshear_ugrad(axis, q, tau) # velocity gradient D, W = sf.ugrad_to_D_and_W(ugrad) # strain-rate and spin tensor t = 1 # some specific time of interest r = sf.pureshear_r(tau, t) # scaling parameter \"r\" at time t F = sf.pureshear_F(axis, q, tau, t) # deformation gradient tensor at time t eps = sf.F_to_strain(F) # strain tensor at time t","title":"Pure shear"},{"location":"deformation-kinematics/#simple-shear","text":"Simple shear may be characterized by the shear angle \\(\\gamma\\) of the resulting rhombus. In the case of vertical shear in the \\(xz\\) plane, the deformation gradient tensor is given by \\[ {\\bf F} = \\begin{bmatrix} 1 & 0 & \\tan(\\gamma) \\\\ 0 & 1 & 0\\\\ 0& 0& 1 \\end{bmatrix} , \\] and velocity-gradient tensor becomes \\[ \\nabla {\\bf u} = \\frac{\\dot{\\gamma}}{\\cos^2(\\gamma)} \\begin{bmatrix} 0 & 0 & 1\\\\ 0 & 0 & 0\\\\ 0& 0& 0 \\end{bmatrix} . \\] Constant strain rate For a constant rate of shear \\(1/\\tau\\) , where \\(\\tau\\) is a characteristic time, the prefactor is \\[\\begin{align} \\frac{\\dot{\\gamma}}{\\cos^2(\\gamma)} = \\frac{1}{\\tau} . \\end{align}\\] Solving for the time-dependent shear angle function can be shown to give \\[ \\gamma(t) = \\tan^{-1}(t/\\tau) . \\] Thus, \\(\\tau\\) is the time it takes to reach a shear angle of \\(\\gamma=45^\\circ\\) from the undeformed configuration, corresponding to \\(\\epsilon_{xz}=\\tan(45^\\circ)/2=0.5\\) . Code example The above expressions are accessible in specfab as follows import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(4) plane = 1 # plane of shear: 0=yz, 1=xz, 2=xy tau = 1 # time taken in seconds for parcel to a reach shear strain of 1 (45 deg shear angle) ugrad = sf.simpleshear_ugrad(plane, tau) # velocity gradient D, W = sf.ugrad_to_D_and_W(ugrad) # strain-rate and spin tensor t = 1 # some specific time of interest gamma = sf.simpleshear_gamma(tau, t) # shear angle at time t F = sf.simpleshear_F(plane, tau, t) # deformation gradient tensor at time t eps = sf.F_to_strain(F) # strain tensor at time t","title":"Simple shear"},{"location":"deformation-kinematics/#plotting-deformed-parcels","text":"Given a deformation gradient \\({\\bf F}\\) , the resulting deformed parcel shape can be plotting as follows: import numpy as np import matplotlib.pyplot as plt from specfabpy import specfab as sf from specfabpy import plotting as sfplt lm, nlm_len = sf.init(4) ### Determine deformation gradient F # Pure shear axis = 2 # axis of compression/extension (0=x, 1=y, 2=z) q = 0 # deformation asymmetry tau_ps = 1/np.log(2) # e-folding time scale t_ps = 1 # time at which deformed parcel is sought F_ps = sf.pureshear_F(axis, q, tau_ps, t_ps) # deformation gradient tensor # Simple shear plane = 1 # shear plane (0=yz, 1=xz, 2=xy) tau_ss = 1 # characteristic time taken to reach shear strain 45 deg. t_ss = 1 # time at which deformed parcel is sought F_ss = sf.simpleshear_F(plane, tau_ss, t_ss) # deformation gradient tensor ### Plot fig = plt.figure(figsize=(6,6)) ax1 = plt.subplot(121, projection='3d') ax2 = plt.subplot(122, projection='3d') sfplt.plotparcel(ax1, F_ps, azim=35, axscale=1.7, axislabels=True, drawinit=True) sfplt.plotparcel(ax2, F_ss, azim=35, axscale=1.7, axislabels=True, drawinit=True) ax1.set_title(r'$\\epsilon_{zz}=%.2f$'%(sf.F_to_strain(F_ps)[2,2])) ax2.set_title(r'$\\gamma=%.0f$ deg.'%(np.rad2deg(sf.simpleshear_gamma(tau_ss, t_ss)))) plt.savefig('deformed-parcel.png', dpi=175, pad_inches=0.1, bbox_inches='tight')","title":"Plotting deformed parcels"},{"location":"enhancements-strainrate-ice/","text":"Ice viscous anisotropy If ice grains are treated as transversely isotropic, the rheology of a single grain can be modeled as a transversely isotropic power law . This requires specifying the grain eigenenhancements \\(E_{cc}'\\) and \\(E_{ca}'\\) and the power law exponent \\(n'\\) . The grain parameters proposed by Rathmann and Lilien (2021) assume linear-viscous behavior of single crystals ( \\(n'=1\\) ) and promote the activation of basal glide by making that slip system soft compared to other systems: \\(E_{ca}' > 1\\) , whereas \\(E_{cc}'=1\\) . This reduces the problem to picking \\(E_{ca}'\\) and \\(\\alpha\\) (Taylor\u2014Sachs homogenization weight), which Rathmann and Lilien (2021) determined by requiring that deformation tests on strong single-maximum CPOs (aligned grains) are approximately reproduced; that is, \\(E_{mt}=10\\) and \\(E_{mm}=0.01\\) . The effect of choosing different \\(E_{ca}'\\) and \\(\\alpha\\) (left panel) on the eigenenhancements of different CPO states (right panel) is shown below for combinations of \\(E_{ca}'\\) and \\(\\alpha\\) that fulfill \\(E_{mt}=10\\) given a unidirectional CPO. Clearly, there is a trade-off between how shear enhanced ( \\(E_{mt}\\) ) and how hard for axial compression ( \\(E_{mm}\\) ) the model allows a unidirectional CPO to be. Code example The below code shows how to calculate \\(E_{ij}\\) given \\({\\bf a}^{(4)}\\) (or the state vector \\(\\bf s\\) ) and a set of grain parameters. import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(8) ### Synthetic unidirectional CPO (all c-axes aligned in z-direction) m = np.array([0,0,1]) a4 = np.einsum('i,j,k,l', m,m,m,m) # 4-times repeated outer product of m nlm = np.zeros((nlm_len), dtype=np.complex64) nlm[:sf.L4len] = sf.a4_to_nlm(a4) # derive corresponding expansion coefficients ### Basis for enhancement factor calculations (e1,e2,e3, eigvals) = sf.frame(nlm, 'e') # enhancement factors are w.r.t. a^(2) basis (i.e. eigenenhancements) #(e1,e2,e3) = np.eye(3) # enhancement factors are w.r.t. Cartesian basis (x,y,z) ### Transversely isotropic monocrystal parameters for ice (Rathmann & Lilien, 2021) n_grain = 1 # power-law exponent: n=1 => linear grain rheology, nonlinear (n>1) is unsupported. Eij_grain = (1, 1e3) # grain eigenenhancements (Ecc,Eca) for compression along c-axis (Ecc) and for shear parallel to basal plane (Eca) alpha = 0.0125 # Taylor--Sachs weight ### Calculate enhancement factors w.r.t. (e1,e2,e3) Eij = sf.Eij_tranisotropic(nlm, e1,e2,e3, Eij_grain,alpha,n_grain) # Eij=(E11,E22,E33,E23,E13,E12)","title":"Glacier ice"},{"location":"enhancements-strainrate-ice/#ice-viscous-anisotropy","text":"If ice grains are treated as transversely isotropic, the rheology of a single grain can be modeled as a transversely isotropic power law . This requires specifying the grain eigenenhancements \\(E_{cc}'\\) and \\(E_{ca}'\\) and the power law exponent \\(n'\\) . The grain parameters proposed by Rathmann and Lilien (2021) assume linear-viscous behavior of single crystals ( \\(n'=1\\) ) and promote the activation of basal glide by making that slip system soft compared to other systems: \\(E_{ca}' > 1\\) , whereas \\(E_{cc}'=1\\) . This reduces the problem to picking \\(E_{ca}'\\) and \\(\\alpha\\) (Taylor\u2014Sachs homogenization weight), which Rathmann and Lilien (2021) determined by requiring that deformation tests on strong single-maximum CPOs (aligned grains) are approximately reproduced; that is, \\(E_{mt}=10\\) and \\(E_{mm}=0.01\\) . The effect of choosing different \\(E_{ca}'\\) and \\(\\alpha\\) (left panel) on the eigenenhancements of different CPO states (right panel) is shown below for combinations of \\(E_{ca}'\\) and \\(\\alpha\\) that fulfill \\(E_{mt}=10\\) given a unidirectional CPO. Clearly, there is a trade-off between how shear enhanced ( \\(E_{mt}\\) ) and how hard for axial compression ( \\(E_{mm}\\) ) the model allows a unidirectional CPO to be.","title":"Ice viscous anisotropy"},{"location":"enhancements-strainrate-ice/#code-example","text":"The below code shows how to calculate \\(E_{ij}\\) given \\({\\bf a}^{(4)}\\) (or the state vector \\(\\bf s\\) ) and a set of grain parameters. import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(8) ### Synthetic unidirectional CPO (all c-axes aligned in z-direction) m = np.array([0,0,1]) a4 = np.einsum('i,j,k,l', m,m,m,m) # 4-times repeated outer product of m nlm = np.zeros((nlm_len), dtype=np.complex64) nlm[:sf.L4len] = sf.a4_to_nlm(a4) # derive corresponding expansion coefficients ### Basis for enhancement factor calculations (e1,e2,e3, eigvals) = sf.frame(nlm, 'e') # enhancement factors are w.r.t. a^(2) basis (i.e. eigenenhancements) #(e1,e2,e3) = np.eye(3) # enhancement factors are w.r.t. Cartesian basis (x,y,z) ### Transversely isotropic monocrystal parameters for ice (Rathmann & Lilien, 2021) n_grain = 1 # power-law exponent: n=1 => linear grain rheology, nonlinear (n>1) is unsupported. Eij_grain = (1, 1e3) # grain eigenenhancements (Ecc,Eca) for compression along c-axis (Ecc) and for shear parallel to basal plane (Eca) alpha = 0.0125 # Taylor--Sachs weight ### Calculate enhancement factors w.r.t. (e1,e2,e3) Eij = sf.Eij_tranisotropic(nlm, e1,e2,e3, Eij_grain,alpha,n_grain) # Eij=(E11,E22,E33,E23,E13,E12)","title":"Code example"},{"location":"enhancements-strainrate-olivine/","text":"Olivine viscous anisotropy If grains are approximately orthotropic, the grain rheology can be modelled using the orthotropic power-law rheology . This requires specifying the grain eigenenhancements \\(E_{ij}'\\) , the power-law exponent \\(n'\\) , and the Taylor\u2014Sachs weight \\(\\alpha\\) . \ud83d\udea7 Not yet documented \u2014 see Rathmann et al. (2024) for details.","title":"Olivine"},{"location":"enhancements-strainrate-olivine/#olivine-viscous-anisotropy","text":"If grains are approximately orthotropic, the grain rheology can be modelled using the orthotropic power-law rheology . This requires specifying the grain eigenenhancements \\(E_{ij}'\\) , the power-law exponent \\(n'\\) , and the Taylor\u2014Sachs weight \\(\\alpha\\) . \ud83d\udea7 Not yet documented \u2014 see Rathmann et al. (2024) for details.","title":"Olivine viscous anisotropy"},{"location":"enhancements-strainrate/","text":"Strain rate enhancement Given a bulk anisotropic rheology \\({\\dot{\\boldsymbol\\epsilon}}(\\boldsymbol\\tau)\\) , where \\({\\dot{\\boldsymbol\\epsilon}}\\) and \\({\\boldsymbol\\tau}\\) are the bulk strain-rate and deviatoric stress tensors, respectively, the directional strain-rate enhancement factors \\(E_{ij}\\) are defined as the \\(({\\bf e}_i, {\\bf e}_j)\\) -components of \\({\\dot{\\boldsymbol\\epsilon}}\\) relative to that of the rheology in the limit of an isotropic CPO: \\[ E_{ij} = \\frac{ {\\bf e}_i \\cdot {\\dot{\\boldsymbol\\epsilon}}({\\boldsymbol\\tau}) \\cdot {\\bf e}_j }{ {\\bf e}_i \\cdot {\\dot{\\boldsymbol\\epsilon}}_{\\mathrm{iso}}({\\boldsymbol\\tau}) \\cdot {\\bf e}_j } , \\qquad(1) \\] for a stress state aligned with \\(({\\bf e}_i, {\\bf e}_j)\\) : \\[ {\\boldsymbol\\tau}({\\bf e}_i, {\\bf e}_j) = \\tau_0 \\begin{cases} {\\bf I}/3 - {\\bf e}_i \\otimes {\\bf e}_i \\;\\;\\quad\\quad\\text{if}\\quad i=j \\\\ {\\bf e}_i \\otimes {\\bf e}_j + {\\bf e}_j \\otimes {\\bf e}_i \\quad\\text{if}\\quad i\\neq j \\\\ \\end{cases} . \\] In this way: \\({E_{11}}\\) is the longitudinal strain-rate enhancement along \\({\\bf e}_{1}\\) when subject to compression along \\({\\bf e}_{1}\\) \\({E_{12}}\\) is the \\({\\bf e}_{1}\\) \u2014 \\({\\bf e}_{2}\\) shear strain-rate enhancement when subject to shear in the \\({\\bf e}_{1}\\) \u2014 \\({\\bf e}_{2}\\) plane and so on. Hard or soft \\(E_{ij}>1\\) implies the material response is softened due to fabric (compared to an isotropic CPO), whereas \\(E_{ij}<1\\) implies hardening . Eigenenhancements Eigenenhancements are defined as the enhancement factors w.r.t. the CPO symmetry axes ( \\({\\bf m}_i\\) ): \\[{\\bf e}_i = {\\bf m}_i .\\] These are the enhancements factors needed to specify the viscous anisotropy in bulk rheologies : Transversely isotropic Orthotropic Grain homogenization Taylor\u2014Sachs Calculating \\(E_{ij}\\) using (1) for a given CPO requires an effective rheology that takes the microstructure into account. In the simplest case, polycrystals may be regarded as an ensemble of interactionless grains (monocrystals), subject to either a homogeneous stress field over the polycrystal scale: \\[ {\\boldsymbol\\tau}' = {\\boldsymbol\\tau} , \\qquad\\qquad \\text{(Sachs's hypothesis)} \\] or a homogeneous stain-rate field: \\[ {\\dot{\\boldsymbol\\epsilon}}' = {\\dot{\\boldsymbol\\epsilon}} , \\qquad\\qquad \\text{(Taylor's hypothesis)} \\] where \\({\\boldsymbol\\tau}'\\) and \\({\\dot{\\boldsymbol\\epsilon}}'\\) are the microscopic (grain-scale) stress and strain-rate tensors, respectively. The effective rheology can then be approximated as the ensemble-averaged monocrystal rheology for either case: \\[ {\\dot{\\boldsymbol\\epsilon}}^{\\mathrm{Sachs}} = \\langle {\\dot{\\boldsymbol\\epsilon}}'({\\boldsymbol\\tau}') \\rangle = \\langle {\\dot{\\boldsymbol\\epsilon}}'({\\boldsymbol\\tau}) \\rangle , \\qquad\\qquad \\text{(Sachs homogenization)} \\] \\[ \\qquad {\\dot{\\boldsymbol\\epsilon}}^{\\mathrm{Taylor}} = \\langle {\\boldsymbol\\tau}'({\\dot{\\boldsymbol\\epsilon}}') \\rangle^{-1} = \\langle {\\boldsymbol\\tau}'({\\dot{\\boldsymbol\\epsilon}}) \\rangle^{-1} , \\qquad \\text{(Taylor homogenization)} \\] where \\(\\langle \\cdot \\rangle^{-1}\\) inverts the tensorial relationship. If a linear combination of the two homogenizations is considered, equation (1) can be approximated as \\[ E_{ij} = (1-\\alpha) \\frac{{\\bf e}_i \\cdot {\\dot{\\boldsymbol\\epsilon}}^{\\mathrm{Sachs}}({\\boldsymbol\\tau}) \\cdot {\\bf e}_j} {{\\bf e}_i \\cdot {\\dot{\\boldsymbol\\epsilon}}^{\\mathrm{Sachs}}_{\\mathrm{iso}}({\\boldsymbol\\tau}) \\cdot {\\bf e}_j } + {\\alpha} \\frac{ {\\bf e}_i \\cdot {\\dot{\\boldsymbol\\epsilon}}^{\\mathrm{Taylor}}({\\boldsymbol\\tau}) \\cdot {\\bf e}_j } { {\\bf e}_i \\cdot {\\dot{\\boldsymbol\\epsilon}}^{\\mathrm{Taylor}}_{\\mathrm{iso}}({\\boldsymbol\\tau}) \\cdot {\\bf e}_j } , \\] or simply \\[ E_{ij} = (1-\\alpha)E_{ij}^{\\mathrm{Sachs}} + {\\alpha}E_{ij}^{\\mathrm{Taylor}} , \\] where \\(\\alpha\\in[0;1]\\) is a free parameter. Grain parameters The grain viscous parameters used for homogenization should be understood as the effective values needed to reproduce deformation experiments on polycrystals; they are not the values derived from experiments on single crystals. Azuma\u2014Placidi \ud83d\udea7 Not yet documented.","title":"Strain-rate enhancement"},{"location":"enhancements-strainrate/#strain-rate-enhancement","text":"Given a bulk anisotropic rheology \\({\\dot{\\boldsymbol\\epsilon}}(\\boldsymbol\\tau)\\) , where \\({\\dot{\\boldsymbol\\epsilon}}\\) and \\({\\boldsymbol\\tau}\\) are the bulk strain-rate and deviatoric stress tensors, respectively, the directional strain-rate enhancement factors \\(E_{ij}\\) are defined as the \\(({\\bf e}_i, {\\bf e}_j)\\) -components of \\({\\dot{\\boldsymbol\\epsilon}}\\) relative to that of the rheology in the limit of an isotropic CPO: \\[ E_{ij} = \\frac{ {\\bf e}_i \\cdot {\\dot{\\boldsymbol\\epsilon}}({\\boldsymbol\\tau}) \\cdot {\\bf e}_j }{ {\\bf e}_i \\cdot {\\dot{\\boldsymbol\\epsilon}}_{\\mathrm{iso}}({\\boldsymbol\\tau}) \\cdot {\\bf e}_j } , \\qquad(1) \\] for a stress state aligned with \\(({\\bf e}_i, {\\bf e}_j)\\) : \\[ {\\boldsymbol\\tau}({\\bf e}_i, {\\bf e}_j) = \\tau_0 \\begin{cases} {\\bf I}/3 - {\\bf e}_i \\otimes {\\bf e}_i \\;\\;\\quad\\quad\\text{if}\\quad i=j \\\\ {\\bf e}_i \\otimes {\\bf e}_j + {\\bf e}_j \\otimes {\\bf e}_i \\quad\\text{if}\\quad i\\neq j \\\\ \\end{cases} . \\] In this way: \\({E_{11}}\\) is the longitudinal strain-rate enhancement along \\({\\bf e}_{1}\\) when subject to compression along \\({\\bf e}_{1}\\) \\({E_{12}}\\) is the \\({\\bf e}_{1}\\) \u2014 \\({\\bf e}_{2}\\) shear strain-rate enhancement when subject to shear in the \\({\\bf e}_{1}\\) \u2014 \\({\\bf e}_{2}\\) plane and so on. Hard or soft \\(E_{ij}>1\\) implies the material response is softened due to fabric (compared to an isotropic CPO), whereas \\(E_{ij}<1\\) implies hardening .","title":"Strain rate enhancement"},{"location":"enhancements-strainrate/#eigenenhancements","text":"Eigenenhancements are defined as the enhancement factors w.r.t. the CPO symmetry axes ( \\({\\bf m}_i\\) ): \\[{\\bf e}_i = {\\bf m}_i .\\] These are the enhancements factors needed to specify the viscous anisotropy in bulk rheologies : Transversely isotropic Orthotropic","title":"Eigenenhancements"},{"location":"enhancements-strainrate/#grain-homogenization","text":"","title":"Grain homogenization"},{"location":"enhancements-strainrate/#taylorsachs","text":"Calculating \\(E_{ij}\\) using (1) for a given CPO requires an effective rheology that takes the microstructure into account. In the simplest case, polycrystals may be regarded as an ensemble of interactionless grains (monocrystals), subject to either a homogeneous stress field over the polycrystal scale: \\[ {\\boldsymbol\\tau}' = {\\boldsymbol\\tau} , \\qquad\\qquad \\text{(Sachs's hypothesis)} \\] or a homogeneous stain-rate field: \\[ {\\dot{\\boldsymbol\\epsilon}}' = {\\dot{\\boldsymbol\\epsilon}} , \\qquad\\qquad \\text{(Taylor's hypothesis)} \\] where \\({\\boldsymbol\\tau}'\\) and \\({\\dot{\\boldsymbol\\epsilon}}'\\) are the microscopic (grain-scale) stress and strain-rate tensors, respectively. The effective rheology can then be approximated as the ensemble-averaged monocrystal rheology for either case: \\[ {\\dot{\\boldsymbol\\epsilon}}^{\\mathrm{Sachs}} = \\langle {\\dot{\\boldsymbol\\epsilon}}'({\\boldsymbol\\tau}') \\rangle = \\langle {\\dot{\\boldsymbol\\epsilon}}'({\\boldsymbol\\tau}) \\rangle , \\qquad\\qquad \\text{(Sachs homogenization)} \\] \\[ \\qquad {\\dot{\\boldsymbol\\epsilon}}^{\\mathrm{Taylor}} = \\langle {\\boldsymbol\\tau}'({\\dot{\\boldsymbol\\epsilon}}') \\rangle^{-1} = \\langle {\\boldsymbol\\tau}'({\\dot{\\boldsymbol\\epsilon}}) \\rangle^{-1} , \\qquad \\text{(Taylor homogenization)} \\] where \\(\\langle \\cdot \\rangle^{-1}\\) inverts the tensorial relationship. If a linear combination of the two homogenizations is considered, equation (1) can be approximated as \\[ E_{ij} = (1-\\alpha) \\frac{{\\bf e}_i \\cdot {\\dot{\\boldsymbol\\epsilon}}^{\\mathrm{Sachs}}({\\boldsymbol\\tau}) \\cdot {\\bf e}_j} {{\\bf e}_i \\cdot {\\dot{\\boldsymbol\\epsilon}}^{\\mathrm{Sachs}}_{\\mathrm{iso}}({\\boldsymbol\\tau}) \\cdot {\\bf e}_j } + {\\alpha} \\frac{ {\\bf e}_i \\cdot {\\dot{\\boldsymbol\\epsilon}}^{\\mathrm{Taylor}}({\\boldsymbol\\tau}) \\cdot {\\bf e}_j } { {\\bf e}_i \\cdot {\\dot{\\boldsymbol\\epsilon}}^{\\mathrm{Taylor}}_{\\mathrm{iso}}({\\boldsymbol\\tau}) \\cdot {\\bf e}_j } , \\] or simply \\[ E_{ij} = (1-\\alpha)E_{ij}^{\\mathrm{Sachs}} + {\\alpha}E_{ij}^{\\mathrm{Taylor}} , \\] where \\(\\alpha\\in[0;1]\\) is a free parameter. Grain parameters The grain viscous parameters used for homogenization should be understood as the effective values needed to reproduce deformation experiments on polycrystals; they are not the values derived from experiments on single crystals.","title":"Taylor&mdash;Sachs"},{"location":"enhancements-strainrate/#azumaplacidi","text":"\ud83d\udea7 Not yet documented.","title":"Azuma&mdash;Placidi"},{"location":"gallery-CPO-flow-coupling/","text":"Coupling flow and CPO The coupled evolution of flow and CPO can be solved by joining different components of specfab together with a momentum balance solver (e.g., Stokes solver): That is, specfab can model: CPO evolution given bulk stress, strain-rate and temperature fields (green piece) Viscous anisotropy induced by the CPO (orange piece) Bulk anisotropic rheologies given the local viscous anisotropy (blue piece) Elmer/Ice See Lilien et al. (2023) for ice flow modelling. FEniCS See Rathmann et al. (2024) for olivine modelling.","title":"Coupling flow and CPO"},{"location":"gallery-CPO-flow-coupling/#coupling-flow-and-cpo","text":"The coupled evolution of flow and CPO can be solved by joining different components of specfab together with a momentum balance solver (e.g., Stokes solver): That is, specfab can model: CPO evolution given bulk stress, strain-rate and temperature fields (green piece) Viscous anisotropy induced by the CPO (orange piece) Bulk anisotropic rheologies given the local viscous anisotropy (blue piece)","title":"Coupling flow and CPO"},{"location":"gallery-CPO-flow-coupling/#elmerice","text":"See Lilien et al. (2023) for ice flow modelling.","title":"Elmer/Ice"},{"location":"gallery-CPO-flow-coupling/#fenics","text":"See Rathmann et al. (2024) for olivine modelling.","title":"FEniCS"},{"location":"gallery-CPO-from-radar/","text":"Inferring CPO from radar The dielectric permittivity tensor of a single ice crystal is often taken to be transversely isotropic w.r.t. the crystal \\(c\\) -axis: \\[ \\boldsymbol{\\epsilon}' = (2\\epsilon_{\\perp}' + \\epsilon_{\\parallel}') \\frac{{\\bf I}}{3} + (\\epsilon_{\\parallel}'-\\epsilon_{\\perp}') \\left({\\bf c}^2 - \\frac{{\\bf I}}{3} \\right), \\] where \\(\\epsilon_{\\parallel}'\\) and \\(\\epsilon_{\\perp}'\\) are the components parallel and perpendicular to the \\(c\\) -axis, respectively, which depend on ice temperature and EM wave frequency ( Fujita et al., 2000 ). For wave lengths much longer than the average grain size, the bulk permittivity tensor \\(\\boldsymbol{\\epsilon}\\) of polycrystalline ice may be approximated as the grain-average permittivity tensor, constructed by averaging \\(\\boldsymbol{\\epsilon}'\\) over all grain orientations (over the CPO) \\[ \\boldsymbol{\\epsilon} \\simeq \\langle \\boldsymbol{\\epsilon}' \\rangle = (2\\epsilon_{\\perp}' + \\epsilon_{\\parallel}') \\frac{{\\bf I}}{3} + (\\epsilon_{\\parallel}'-\\epsilon_{\\perp}') \\left(\\langle {\\bf c}^2 \\rangle - \\frac{{\\bf I}}{3} \\right) , \\] where \\(\\langle {\\bf c}^2\\rangle\\) is the second-order structure tensor , identical to \\({\\bf a}^{(2)}\\) . Thus, because the bulk permittivity tensor \\(\\boldsymbol{\\epsilon}\\) can be inferred from EM wave speeds or radar return-power anomalies, so can \\(\\langle {\\bf c}^2 \\rangle\\) . Radar measurements \\(\\rightarrow\\) CPO A useful approximation over large parts of ice sheets is that \\(\\langle {\\bf c}^2 \\rangle\\) has a vertical eigenvector, in which case the Cartesian components are \\[ \\langle {\\bf c}^2 \\rangle = \\left[\\begin{matrix} a_{xx} & a_{xy} & 0\\\\ a_{xy} & a_{yy} & 0\\\\ 0 & 0 & a_{zz} \\end{matrix}\\right] . \\] Consider then the case where the difference in horizontal eigenvalues of \\(\\langle {\\bf c}^2 \\rangle\\) , \\[ \\Delta \\lambda = \\lambda_2 - \\lambda_1, \\] can be inferred from ice-penetrating radar, where \\({\\bf m}_1\\) and \\({\\bf m}_2\\) are the corresponding horizontal eigenvectors and eigenvalues are sorted such that \\(\\lambda_1 \\leq \\lambda_2\\) . It follows that the structure tensor, posed in its eigenframe ( \\({\\bf m}_1, {\\bf m}_2, {\\bf z}\\) ), is \\[ \\langle {\\bf c}^2 \\rangle = \\left[\\begin{matrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_1 + \\Delta\\lambda & 0 \\\\ 0 & 0 & 1 - \\Delta \\lambda - 2\\lambda_1 \\end{matrix}\\right] , \\] where the identity \\(\\operatorname{tr}(\\langle {\\bf c}^2 \\rangle) = 1\\) was used. Gerber's approximation Since \\(\\lambda_1\\) is unknown, the problem can be closed by making different assumptions about \\(\\lambda_1\\) given the local/upstream flow regime, such as proposed by Gerber et al. (2023) . Suppose \\(\\Delta\\lambda\\) is measured in region where \\(c\\) -axes are, to a good approximation, suspected to be distributed on the \\({\\bf m}_2\\) \u2014 \\({\\bf z}\\) plane because the smallest eigenvalue is vanishing, \\(\\lambda_1 \\rightarrow 0\\) . In this case, \\(\\Delta \\lambda = 0\\) represents a perfect single-maximum along \\({\\bf z}\\) , \\(\\Delta \\lambda = 0.5\\) a perfect girdle in the \\({\\bf m}_2\\) \u2014 \\({\\bf z}\\) plane, and \\(\\Delta \\lambda = 1\\) a perfect single-maximum along \\({\\bf m}_2\\) , respectively: CPO \\(\\rightarrow\\) Enhancement factors If \\(\\langle {\\bf c}^2 \\rangle\\) can be inferred from radar measurements following the above method, so can the bulk strain-rate enhancement factors \\(E_{ij}\\) in the same frame. The enhancements depend, however, also on the fourth-order structure tensor, \\(\\langle {\\bf c}^4 \\rangle\\) , while the bulk permittivity \\(\\boldsymbol\\epsilon\\) depends exclusively on \\(\\langle {\\bf c}^2 \\rangle\\) . To overcome this, two approaches can be taken. Method 1: Use the IBOF closure of the Elmer/Ice flow model: import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(4) # L=4 is sufficient ### Determine <c^2> from radar-derived Delta lambda l1 = 0 # lambda_1 = 0 (Gerber's approximation) dl = 0.5 # Delta lambda = lambda_2 - lambda_1 a2 = np.diag([l1, l1+dl, 1-dl-2*l1]) # structure tensor <c^2> in eigenframe a4 = sf.a4_IBOF(a2) # Elmer/Ice IBOF closure for <c^4> given <c^2> Method 2 Use an empirical correlation for determining \\(\\langle {\\bf c}^4 \\rangle\\) given \\(\\langle {\\bf c}^2 \\rangle\\) if the CPO is approximately rotationally symmetric. If the CPO symmetry axis is rotated into the vertical direction, \\(\\langle {\\bf c}^2 \\rangle\\) depends only on the normalized spectral component \\(\\hat{n}_2^0 = n_2^0/n_0^0:\\) \\[ \\langle {\\bf c}^2 \\rangle = \\frac{\\bf I}{3} + \\frac{2\\sqrt{5}}{15} \\hat{n}_2^0 \\left[\\begin{matrix} -1/2 & 0 & 0 \\\\ 0 & -1/2 & 0 \\\\ 0 & 0 & 1 \\end{matrix}\\right] , \\] and \\(\\langle {\\bf c}^4 \\rangle\\) only on \\(\\hat{n}_2^0\\) and \\(\\hat{n}_4^0 = n_4^0/n_0^0\\) (not shown). The figure below shows the empirical correlation between these two components based on ice-core samples. Thus, if \\(\\hat{n}_2^0\\) is extracted from \\(\\langle {\\bf c}^2 \\rangle\\) in this frame, \\(\\hat{n}_4^0\\) can be derived and hence \\(\\langle {\\bf c}^4 \\rangle\\) reconstructed. To pose the CPO in the original, unrotated eigenframe ( \\({\\bf m}_1, {\\bf m}_2, {\\bf z}\\) ), the resulting expansion series is finally rotated back, allowing eigenenhancements to easily be calculated using specfab . The following code demonstrates how to take each step with specfab : import numpy as np from scipy.spatial.transform import Rotation from specfabpy import specfab as sf lm, nlm_len = sf.init(4) # L=4 is sufficient here ### Determine <c^2> from radar-derived Delta lambda l1 = 0 # lambda_1 = 0 (Gerber's approximation) dl = 0.5 # Delta lambda = lambda_2 - lambda_1 a2 = np.diag([l1, l1+dl, 1-dl-2*l1]) # second-order structure tensor, <c^2>, in eigenframe m1, m2, z = np.array([1,0,0]), np.array([0,1,0]), np.array([0,0,1]) # eigenvectors ### Rotate <c^2> into a rotationally-symmetric frame about z Rm1 = Rotation.from_rotvec(np.pi/2 * m1).as_matrix() # Rotate 90 deg about m1 eigenvector Rm2 = Rotation.from_rotvec(np.pi/2 * m2).as_matrix() # Rotate 90 deg about m2 eigenvector if dl < 0.4: a2_vs = a2 # Already in rotationally-symmetric frame about z if 0.4 <= dl <= 0.6: a2_vs = np.matmul(Rm2,np.matmul(a2,Rm2.T)) # Rotate vertical (m2--z) girdle into horizontal (m1--m2) girdle if dl > 0.6: a2_vs = np.matmul(Rm1,np.matmul(a2,Rm1.T)) # Rotate horizontal (m2) single-maximum into vertical (z) single-maximum ### Determine \\hat{n}_4^0 (= n_4^0/n_0^0) from \\hat{n}_2^0 (= n_2^0/n_0^0) in rotationally-symmetric frame about z nhat20 = (a2_vs[2,2]- 1/3)/(2/15*np.sqrt(5)) # azz -> nhat20 nhat40 = sf.nhat40_empcorr_ice(nhat20)[0] ### Construct nlm (state vector) in rotationally-symmetric frame about z nlm_vs = np.zeros(nlm_len, dtype=np.complex128) n00 = 1/np.sqrt(4*np.pi) # only grain-number normalized distribution is known, so must integrate to 1 over S^2. nlm_vs[0] = n00 nlm_vs[3] = nhat20*n00 nlm_vs[10] = nhat40*n00 ### Rotate spectral CPO state back to origional (m1,m2,z) eigenframe if dl < 0.4: nlm = nlm_vs # Already in vertical symmetric frame if 0.4 <= dl <= 0.6: nlm = sf.rotate_nlm(nlm_vs, -np.pi/2, 0) # Rotate horizontal (m1--m2) girdle back into vertical (m2--z) girdle if dl > 0.6: nlm = sf.rotate_nlm(sf.rotate_nlm(nlm_vs, -np.pi/2, 0), 0 ,-np.pi/2) # Rotate vertical (z) single-maximum back into horizontal (m2) single-maximum ### Calculate eigenenhancements # Transversely isotropic monocrystal parameters for ice (Rathmann & Lilien, 2021) n_grain = 1 # Power-law exponent: n=1 => linear grain rheology, nonlinear (n>1) is unsupported Eij_grain = (1, 1e3) # Grain eigenenhancements (Ecc,Eca) for compression along c-axis (Ecc) and for shear parallel to basal plane (Eca) alpha = 0.0125 # Taylor--Sachs weight # Tuple of eigenenhancements (bulk enhancement factors w.r.t. m1, m2, z) e1, e2, e3 = m1, m2, z Eij = sf.Eij_tranisotropic(nlm, e1,e2,e3, Eij_grain,alpha,n_grain) # (E_{m1,m1},E_{m2,m2},E_{zz},E_{m2,z),E_{m1,z},E_{m1,m2}) # To calculate bulk enhancement factors w.r.t. other axes of deformation/stress, change (e1,e2,e3) accordingly. For reference, the following plots show the different CPOs at each step for \\(\\Delta\\lambda=0.5\\) and \\(\\Delta\\lambda=1\\) , respectively:","title":"Inferring CPO from radar"},{"location":"gallery-CPO-from-radar/#inferring-cpo-from-radar","text":"The dielectric permittivity tensor of a single ice crystal is often taken to be transversely isotropic w.r.t. the crystal \\(c\\) -axis: \\[ \\boldsymbol{\\epsilon}' = (2\\epsilon_{\\perp}' + \\epsilon_{\\parallel}') \\frac{{\\bf I}}{3} + (\\epsilon_{\\parallel}'-\\epsilon_{\\perp}') \\left({\\bf c}^2 - \\frac{{\\bf I}}{3} \\right), \\] where \\(\\epsilon_{\\parallel}'\\) and \\(\\epsilon_{\\perp}'\\) are the components parallel and perpendicular to the \\(c\\) -axis, respectively, which depend on ice temperature and EM wave frequency ( Fujita et al., 2000 ). For wave lengths much longer than the average grain size, the bulk permittivity tensor \\(\\boldsymbol{\\epsilon}\\) of polycrystalline ice may be approximated as the grain-average permittivity tensor, constructed by averaging \\(\\boldsymbol{\\epsilon}'\\) over all grain orientations (over the CPO) \\[ \\boldsymbol{\\epsilon} \\simeq \\langle \\boldsymbol{\\epsilon}' \\rangle = (2\\epsilon_{\\perp}' + \\epsilon_{\\parallel}') \\frac{{\\bf I}}{3} + (\\epsilon_{\\parallel}'-\\epsilon_{\\perp}') \\left(\\langle {\\bf c}^2 \\rangle - \\frac{{\\bf I}}{3} \\right) , \\] where \\(\\langle {\\bf c}^2\\rangle\\) is the second-order structure tensor , identical to \\({\\bf a}^{(2)}\\) . Thus, because the bulk permittivity tensor \\(\\boldsymbol{\\epsilon}\\) can be inferred from EM wave speeds or radar return-power anomalies, so can \\(\\langle {\\bf c}^2 \\rangle\\) .","title":"Inferring CPO from radar"},{"location":"gallery-CPO-from-radar/#radar-measurements-rightarrow-cpo","text":"A useful approximation over large parts of ice sheets is that \\(\\langle {\\bf c}^2 \\rangle\\) has a vertical eigenvector, in which case the Cartesian components are \\[ \\langle {\\bf c}^2 \\rangle = \\left[\\begin{matrix} a_{xx} & a_{xy} & 0\\\\ a_{xy} & a_{yy} & 0\\\\ 0 & 0 & a_{zz} \\end{matrix}\\right] . \\] Consider then the case where the difference in horizontal eigenvalues of \\(\\langle {\\bf c}^2 \\rangle\\) , \\[ \\Delta \\lambda = \\lambda_2 - \\lambda_1, \\] can be inferred from ice-penetrating radar, where \\({\\bf m}_1\\) and \\({\\bf m}_2\\) are the corresponding horizontal eigenvectors and eigenvalues are sorted such that \\(\\lambda_1 \\leq \\lambda_2\\) . It follows that the structure tensor, posed in its eigenframe ( \\({\\bf m}_1, {\\bf m}_2, {\\bf z}\\) ), is \\[ \\langle {\\bf c}^2 \\rangle = \\left[\\begin{matrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_1 + \\Delta\\lambda & 0 \\\\ 0 & 0 & 1 - \\Delta \\lambda - 2\\lambda_1 \\end{matrix}\\right] , \\] where the identity \\(\\operatorname{tr}(\\langle {\\bf c}^2 \\rangle) = 1\\) was used.","title":"Radar measurements \\(\\rightarrow\\) CPO"},{"location":"gallery-CPO-from-radar/#gerbers-approximation","text":"Since \\(\\lambda_1\\) is unknown, the problem can be closed by making different assumptions about \\(\\lambda_1\\) given the local/upstream flow regime, such as proposed by Gerber et al. (2023) . Suppose \\(\\Delta\\lambda\\) is measured in region where \\(c\\) -axes are, to a good approximation, suspected to be distributed on the \\({\\bf m}_2\\) \u2014 \\({\\bf z}\\) plane because the smallest eigenvalue is vanishing, \\(\\lambda_1 \\rightarrow 0\\) . In this case, \\(\\Delta \\lambda = 0\\) represents a perfect single-maximum along \\({\\bf z}\\) , \\(\\Delta \\lambda = 0.5\\) a perfect girdle in the \\({\\bf m}_2\\) \u2014 \\({\\bf z}\\) plane, and \\(\\Delta \\lambda = 1\\) a perfect single-maximum along \\({\\bf m}_2\\) , respectively:","title":"Gerber's approximation"},{"location":"gallery-CPO-from-radar/#cpo-rightarrow-enhancement-factors","text":"If \\(\\langle {\\bf c}^2 \\rangle\\) can be inferred from radar measurements following the above method, so can the bulk strain-rate enhancement factors \\(E_{ij}\\) in the same frame. The enhancements depend, however, also on the fourth-order structure tensor, \\(\\langle {\\bf c}^4 \\rangle\\) , while the bulk permittivity \\(\\boldsymbol\\epsilon\\) depends exclusively on \\(\\langle {\\bf c}^2 \\rangle\\) . To overcome this, two approaches can be taken.","title":"CPO \\(\\rightarrow\\) Enhancement factors"},{"location":"gallery-CPO-from-radar/#method-1","text":"Use the IBOF closure of the Elmer/Ice flow model: import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(4) # L=4 is sufficient ### Determine <c^2> from radar-derived Delta lambda l1 = 0 # lambda_1 = 0 (Gerber's approximation) dl = 0.5 # Delta lambda = lambda_2 - lambda_1 a2 = np.diag([l1, l1+dl, 1-dl-2*l1]) # structure tensor <c^2> in eigenframe a4 = sf.a4_IBOF(a2) # Elmer/Ice IBOF closure for <c^4> given <c^2>","title":"Method 1:"},{"location":"gallery-CPO-from-radar/#method-2","text":"Use an empirical correlation for determining \\(\\langle {\\bf c}^4 \\rangle\\) given \\(\\langle {\\bf c}^2 \\rangle\\) if the CPO is approximately rotationally symmetric. If the CPO symmetry axis is rotated into the vertical direction, \\(\\langle {\\bf c}^2 \\rangle\\) depends only on the normalized spectral component \\(\\hat{n}_2^0 = n_2^0/n_0^0:\\) \\[ \\langle {\\bf c}^2 \\rangle = \\frac{\\bf I}{3} + \\frac{2\\sqrt{5}}{15} \\hat{n}_2^0 \\left[\\begin{matrix} -1/2 & 0 & 0 \\\\ 0 & -1/2 & 0 \\\\ 0 & 0 & 1 \\end{matrix}\\right] , \\] and \\(\\langle {\\bf c}^4 \\rangle\\) only on \\(\\hat{n}_2^0\\) and \\(\\hat{n}_4^0 = n_4^0/n_0^0\\) (not shown). The figure below shows the empirical correlation between these two components based on ice-core samples. Thus, if \\(\\hat{n}_2^0\\) is extracted from \\(\\langle {\\bf c}^2 \\rangle\\) in this frame, \\(\\hat{n}_4^0\\) can be derived and hence \\(\\langle {\\bf c}^4 \\rangle\\) reconstructed. To pose the CPO in the original, unrotated eigenframe ( \\({\\bf m}_1, {\\bf m}_2, {\\bf z}\\) ), the resulting expansion series is finally rotated back, allowing eigenenhancements to easily be calculated using specfab . The following code demonstrates how to take each step with specfab : import numpy as np from scipy.spatial.transform import Rotation from specfabpy import specfab as sf lm, nlm_len = sf.init(4) # L=4 is sufficient here ### Determine <c^2> from radar-derived Delta lambda l1 = 0 # lambda_1 = 0 (Gerber's approximation) dl = 0.5 # Delta lambda = lambda_2 - lambda_1 a2 = np.diag([l1, l1+dl, 1-dl-2*l1]) # second-order structure tensor, <c^2>, in eigenframe m1, m2, z = np.array([1,0,0]), np.array([0,1,0]), np.array([0,0,1]) # eigenvectors ### Rotate <c^2> into a rotationally-symmetric frame about z Rm1 = Rotation.from_rotvec(np.pi/2 * m1).as_matrix() # Rotate 90 deg about m1 eigenvector Rm2 = Rotation.from_rotvec(np.pi/2 * m2).as_matrix() # Rotate 90 deg about m2 eigenvector if dl < 0.4: a2_vs = a2 # Already in rotationally-symmetric frame about z if 0.4 <= dl <= 0.6: a2_vs = np.matmul(Rm2,np.matmul(a2,Rm2.T)) # Rotate vertical (m2--z) girdle into horizontal (m1--m2) girdle if dl > 0.6: a2_vs = np.matmul(Rm1,np.matmul(a2,Rm1.T)) # Rotate horizontal (m2) single-maximum into vertical (z) single-maximum ### Determine \\hat{n}_4^0 (= n_4^0/n_0^0) from \\hat{n}_2^0 (= n_2^0/n_0^0) in rotationally-symmetric frame about z nhat20 = (a2_vs[2,2]- 1/3)/(2/15*np.sqrt(5)) # azz -> nhat20 nhat40 = sf.nhat40_empcorr_ice(nhat20)[0] ### Construct nlm (state vector) in rotationally-symmetric frame about z nlm_vs = np.zeros(nlm_len, dtype=np.complex128) n00 = 1/np.sqrt(4*np.pi) # only grain-number normalized distribution is known, so must integrate to 1 over S^2. nlm_vs[0] = n00 nlm_vs[3] = nhat20*n00 nlm_vs[10] = nhat40*n00 ### Rotate spectral CPO state back to origional (m1,m2,z) eigenframe if dl < 0.4: nlm = nlm_vs # Already in vertical symmetric frame if 0.4 <= dl <= 0.6: nlm = sf.rotate_nlm(nlm_vs, -np.pi/2, 0) # Rotate horizontal (m1--m2) girdle back into vertical (m2--z) girdle if dl > 0.6: nlm = sf.rotate_nlm(sf.rotate_nlm(nlm_vs, -np.pi/2, 0), 0 ,-np.pi/2) # Rotate vertical (z) single-maximum back into horizontal (m2) single-maximum ### Calculate eigenenhancements # Transversely isotropic monocrystal parameters for ice (Rathmann & Lilien, 2021) n_grain = 1 # Power-law exponent: n=1 => linear grain rheology, nonlinear (n>1) is unsupported Eij_grain = (1, 1e3) # Grain eigenenhancements (Ecc,Eca) for compression along c-axis (Ecc) and for shear parallel to basal plane (Eca) alpha = 0.0125 # Taylor--Sachs weight # Tuple of eigenenhancements (bulk enhancement factors w.r.t. m1, m2, z) e1, e2, e3 = m1, m2, z Eij = sf.Eij_tranisotropic(nlm, e1,e2,e3, Eij_grain,alpha,n_grain) # (E_{m1,m1},E_{m2,m2},E_{zz},E_{m2,z),E_{m1,z},E_{m1,m2}) # To calculate bulk enhancement factors w.r.t. other axes of deformation/stress, change (e1,e2,e3) accordingly. For reference, the following plots show the different CPOs at each step for \\(\\Delta\\lambda=0.5\\) and \\(\\Delta\\lambda=1\\) , respectively:","title":"Method 2"},{"location":"gallery-Lagrangian-parcel/","text":"Lagrangian parcel model Specfab includes a high-level integrator for calculating the CPO evolution of a Lagrangian parcel subject to a constant strain rate tensor. The following code illustrates how to use it, which relies on specifying the kinematic mode of deformation in terms of the DK object. import numpy as np from specfabpy import specfab as sf from specfabpy import integrator as sfint L = 12 # expansion series truncation lm, nlm_len = sf.init(L) Nt = 200 # number of integration time steps for below mode of deformation (MOD) nlm = np.zeros((Nt+1,nlm_len), dtype=np.complex64) # expansion coefficients ### Pure shear axis = 2 # axis of compression (0,1,2 = x,y,z) tau = 1 # characteristic e-folding deformation time q = +0.25 # asymmetry in directions of extension: q=0 => unconfined, q=+1 or q=-1 => 100% confinement in either of the extending directions strain_target = -0.95 # deform parcel until this strain target is reached along \"axis\" DK = dict(type='ps', q=q, axis=axis, tau=tau) # deformation kinematics ### Simple shear #plane = 1 # (0,1,2 = yz,xz,xy shear) #strain_target = np.deg2rad(75) # deform parcel until this target strain (strain angle) #tau = 1 # characteristic deformation time-scale (1/shearrate) #DK = dict(type='ss', plane=plane, tau=tau) ### Integrate kw_dyn = dict( iota = 1, # plastic spin strength (default: iota=1 for deck-of-cards behaviour) nu = 1, # multiplicative factor for default regularization strength (default: nu=1) Gamma0 = None, # DDRX magnitude (None = disabled) Lambda = None, # CDRX magnitude (None = disabled) ) nlm[:,:], F, time, ugrad = sfint.lagrangianparcel(sf, DK, strain_target, Nt=Nt, **kw_dyn) \"\"\" Outputs are: ------------ nlm (Nt,nlm_len): Harmonic coefficients at each time step F (Nt,3,3): Deformation gradient tensor at each time step time (Nt): Total time at each time step ugrad (3,3): Velocity gradient \"\"\" ### Auxiliary strain_ij = np.array([sf.F_to_strain(F[nn,:,:]) for nn in np.arange(Nt)]) # full strain tensor","title":"Lagrangian parcel model"},{"location":"gallery-Lagrangian-parcel/#lagrangian-parcel-model","text":"Specfab includes a high-level integrator for calculating the CPO evolution of a Lagrangian parcel subject to a constant strain rate tensor. The following code illustrates how to use it, which relies on specifying the kinematic mode of deformation in terms of the DK object. import numpy as np from specfabpy import specfab as sf from specfabpy import integrator as sfint L = 12 # expansion series truncation lm, nlm_len = sf.init(L) Nt = 200 # number of integration time steps for below mode of deformation (MOD) nlm = np.zeros((Nt+1,nlm_len), dtype=np.complex64) # expansion coefficients ### Pure shear axis = 2 # axis of compression (0,1,2 = x,y,z) tau = 1 # characteristic e-folding deformation time q = +0.25 # asymmetry in directions of extension: q=0 => unconfined, q=+1 or q=-1 => 100% confinement in either of the extending directions strain_target = -0.95 # deform parcel until this strain target is reached along \"axis\" DK = dict(type='ps', q=q, axis=axis, tau=tau) # deformation kinematics ### Simple shear #plane = 1 # (0,1,2 = yz,xz,xy shear) #strain_target = np.deg2rad(75) # deform parcel until this target strain (strain angle) #tau = 1 # characteristic deformation time-scale (1/shearrate) #DK = dict(type='ss', plane=plane, tau=tau) ### Integrate kw_dyn = dict( iota = 1, # plastic spin strength (default: iota=1 for deck-of-cards behaviour) nu = 1, # multiplicative factor for default regularization strength (default: nu=1) Gamma0 = None, # DDRX magnitude (None = disabled) Lambda = None, # CDRX magnitude (None = disabled) ) nlm[:,:], F, time, ugrad = sfint.lagrangianparcel(sf, DK, strain_target, Nt=Nt, **kw_dyn) \"\"\" Outputs are: ------------ nlm (Nt,nlm_len): Harmonic coefficients at each time step F (Nt,3,3): Deformation gradient tensor at each time step time (Nt): Total time at each time step ugrad (3,3): Velocity gradient \"\"\" ### Auxiliary strain_ij = np.array([sf.F_to_strain(F[nn,:,:]) for nn in np.arange(Nt)]) # full strain tensor","title":"Lagrangian parcel model"},{"location":"gallery-SSA-fabric-solver/","text":"Steady SSA CPO field If the velocity field \\({\\bf u}({\\bf{x}},t)\\) and CPO field \\({\\bf s}({\\bf{x}},t)\\) can be assumed steady, CPO evolution reduces to a high-dimensional boundary value problem in \\({\\bf s}({\\bf{x}},t)\\) that can easily be solved using e.g. the finite element method. When considering the flow glacier ice, it is common to simplify the problem by invoking the Shallow Shelf Approximation (SSA), a depth-integrated version of the full Stokes equations. This approximation conveniently reduces the problem to a two-dimensional horizontal, membrane-like flow with negligible vertical shear. Performing a similar calculation, the depth-average equation for steady CPO evolution can be shown to take the form (Rathmann et al., 2025) \\[ ({\\bf u} \\cdot \\nabla) {\\bf \\bar s} = ({\\bf M}_{\\mathrm{LROT}}+{\\bf M}_{\\mathrm{DDRX}}+{\\bf M}_{\\mathrm{CDRX}}) \\cdot {\\bf \\bar s} + \\frac{a_{\\mathrm{sfc}}}{H}( {\\bf s}_{\\mathrm{sfc}} - {\\bf \\bar s} ) + \\frac{a_{\\mathrm{sub}}}{H}( {\\bf s}_{\\mathrm{sub}} - {\\bf \\bar s} ) , \\] where \\({\\bf \\bar s}(x,y)\\) is the depth-average CPO state vector field, \\({\\bf{u}}(x,y)=[u_x(x,y),u_y(x,y)]\\) is the horizontal surface velocity field, and \\(H\\) is the ice thickness, The first term represents CPO advection along stream lines, and the second term represents the depth-average effect of crystal processes. The third and fourth terms are state-space attractors, causing \\({\\bf \\bar s}\\) to tend towards the characteristic CPO states of ice that accumulates on the surface \\({\\bf s}_{\\mathrm{sfc}}\\) or subglacially \\({\\bf s}_{\\mathrm{sub}}\\) (likely isotropic), depending on the positively-defined accumulation rates \\(a_{\\mathrm{sfc}}\\) and \\(a_{\\mathrm{sub}}\\) . Closure If only lattice rotation is relevant (typical for cold ice), the problem is closed by specifying the horizontal surface velocity field (e.g., satellite-derived velocities), together with accumulation rates and the characteristic CPO state of accumulated ice (typically isotropic). If DDRX is non-negligible (typical for warm ice), the temperature and stress field must additionally be prescribed. One solution is to presume some temperature field and assert that the stress and strain-rate tensors are coaxial so that \\({\\boldsymbol\\tau} \\propto \\dot{\\boldsymbol\\epsilon}\\) (Rathmann et al., 2025) . Regularization Noise in the surface velocity products used, in addition to uncertainties due to model assumptions, can render the steady SSA CPO problem ill-posed. Adding Laplacian regularization of the form \\(\\gamma \\nabla^2 {\\bf \\bar s}\\) to the right-hand side of the problem solves this, at the expense of limiting how large spatial gradients are permitted in the CPO field. The strength of regularization \\(\\gamma\\) is therefore a free model parameter which must be carefully selected, especially in very dynamic regions where the CPO field might change rapidly with distance. Example for Ross ice shelf Documentation in prep. Will be updated once new paper is released.","title":"Steady SSA CPO field"},{"location":"gallery-SSA-fabric-solver/#steady-ssa-cpo-field","text":"If the velocity field \\({\\bf u}({\\bf{x}},t)\\) and CPO field \\({\\bf s}({\\bf{x}},t)\\) can be assumed steady, CPO evolution reduces to a high-dimensional boundary value problem in \\({\\bf s}({\\bf{x}},t)\\) that can easily be solved using e.g. the finite element method. When considering the flow glacier ice, it is common to simplify the problem by invoking the Shallow Shelf Approximation (SSA), a depth-integrated version of the full Stokes equations. This approximation conveniently reduces the problem to a two-dimensional horizontal, membrane-like flow with negligible vertical shear. Performing a similar calculation, the depth-average equation for steady CPO evolution can be shown to take the form (Rathmann et al., 2025) \\[ ({\\bf u} \\cdot \\nabla) {\\bf \\bar s} = ({\\bf M}_{\\mathrm{LROT}}+{\\bf M}_{\\mathrm{DDRX}}+{\\bf M}_{\\mathrm{CDRX}}) \\cdot {\\bf \\bar s} + \\frac{a_{\\mathrm{sfc}}}{H}( {\\bf s}_{\\mathrm{sfc}} - {\\bf \\bar s} ) + \\frac{a_{\\mathrm{sub}}}{H}( {\\bf s}_{\\mathrm{sub}} - {\\bf \\bar s} ) , \\] where \\({\\bf \\bar s}(x,y)\\) is the depth-average CPO state vector field, \\({\\bf{u}}(x,y)=[u_x(x,y),u_y(x,y)]\\) is the horizontal surface velocity field, and \\(H\\) is the ice thickness, The first term represents CPO advection along stream lines, and the second term represents the depth-average effect of crystal processes. The third and fourth terms are state-space attractors, causing \\({\\bf \\bar s}\\) to tend towards the characteristic CPO states of ice that accumulates on the surface \\({\\bf s}_{\\mathrm{sfc}}\\) or subglacially \\({\\bf s}_{\\mathrm{sub}}\\) (likely isotropic), depending on the positively-defined accumulation rates \\(a_{\\mathrm{sfc}}\\) and \\(a_{\\mathrm{sub}}\\) .","title":"Steady SSA CPO field"},{"location":"gallery-SSA-fabric-solver/#closure","text":"If only lattice rotation is relevant (typical for cold ice), the problem is closed by specifying the horizontal surface velocity field (e.g., satellite-derived velocities), together with accumulation rates and the characteristic CPO state of accumulated ice (typically isotropic). If DDRX is non-negligible (typical for warm ice), the temperature and stress field must additionally be prescribed. One solution is to presume some temperature field and assert that the stress and strain-rate tensors are coaxial so that \\({\\boldsymbol\\tau} \\propto \\dot{\\boldsymbol\\epsilon}\\) (Rathmann et al., 2025) .","title":"Closure"},{"location":"gallery-SSA-fabric-solver/#regularization","text":"Noise in the surface velocity products used, in addition to uncertainties due to model assumptions, can render the steady SSA CPO problem ill-posed. Adding Laplacian regularization of the form \\(\\gamma \\nabla^2 {\\bf \\bar s}\\) to the right-hand side of the problem solves this, at the expense of limiting how large spatial gradients are permitted in the CPO field. The strength of regularization \\(\\gamma\\) is therefore a free model parameter which must be carefully selected, especially in very dynamic regions where the CPO field might change rapidly with distance.","title":"Regularization"},{"location":"gallery-SSA-fabric-solver/#example-for-ross-ice-shelf","text":"Documentation in prep. Will be updated once new paper is released.","title":"Example for Ross ice shelf"},{"location":"install/","text":"Install Requires a version of Python between 3.6 and 3.11 \u2014 newer versions are not yet supported because specfab relies on setuptools<=61 . Source code is available here . \ud83d\udc27 Linux The easiest way to install is using the pipy package: pip3 install numpy --upgrade && pip3 install specfabpy Alternatively, you can compile specfab yourself: cd src pip3 install setuptools==61 make install \ud83c\udf4e Mac You must compile specfab yourself: cd src pip3 install setuptools==61 make all pip3 install . # or run: make install \ud83e\ude9f Windows No reported experience installing specfab on Windows. You will have to try this yourself, but please report back if successful, and how \ud83d\ude80. \ud83d\udc0d Conda Conda users have reported this to work: brew install gcc # if gcc is needed on Mac, else skip conda create --name sfenv conda install -c anaconda ipykernel # for jupyter support python -m ipykernel install --user --name=sfenv conda activate sfenv conda install python==3.11 pip install numpy==1.23 pip install setuptools==61 pip install cartopy, scipy, cmasher cd specfabpy/src make install \u2699\ufe0f Fortran interfaces Interface Make Plain Fortran interface Run cd src && make specfab.o Elmer interface Compile shared library by running cd src && make libspecfab.so Libraries required: BLAS, LAPACK Initialize Initialize specfab by running import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(10) # L=10 truncation is sufficient for many cases nlm = np.zeros(nlm_len, dtype=np.complex64) # vector of harmonic expansion coefficients nlm[0] = 1/np.sqrt(4*np.pi) # normalized isotropic distribution where Variable Interpretation nlm_len Number of expansion coefficients for expansion series truncated at \\(l=L\\) nlm Vector of complex-valued expansion coefficients (state vector) lm Vector of degree and order integers ( l , m ) associated with each entry in nlm","title":"\ud83d\udce6 Install"},{"location":"install/#install","text":"Requires a version of Python between 3.6 and 3.11 \u2014 newer versions are not yet supported because specfab relies on setuptools<=61 . Source code is available here .","title":"Install"},{"location":"install/#linux","text":"The easiest way to install is using the pipy package: pip3 install numpy --upgrade && pip3 install specfabpy Alternatively, you can compile specfab yourself: cd src pip3 install setuptools==61 make install","title":"\ud83d\udc27 Linux"},{"location":"install/#mac","text":"You must compile specfab yourself: cd src pip3 install setuptools==61 make all pip3 install . # or run: make install","title":"\ud83c\udf4e Mac"},{"location":"install/#windows","text":"No reported experience installing specfab on Windows. You will have to try this yourself, but please report back if successful, and how \ud83d\ude80.","title":"\ud83e\ude9f Windows"},{"location":"install/#conda","text":"Conda users have reported this to work: brew install gcc # if gcc is needed on Mac, else skip conda create --name sfenv conda install -c anaconda ipykernel # for jupyter support python -m ipykernel install --user --name=sfenv conda activate sfenv conda install python==3.11 pip install numpy==1.23 pip install setuptools==61 pip install cartopy, scipy, cmasher cd specfabpy/src make install","title":"\ud83d\udc0d Conda"},{"location":"install/#fortran-interfaces","text":"Interface Make Plain Fortran interface Run cd src && make specfab.o Elmer interface Compile shared library by running cd src && make libspecfab.so Libraries required: BLAS, LAPACK","title":"\u2699\ufe0f Fortran interfaces"},{"location":"install/#initialize","text":"Initialize specfab by running import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(10) # L=10 truncation is sufficient for many cases nlm = np.zeros(nlm_len, dtype=np.complex64) # vector of harmonic expansion coefficients nlm[0] = 1/np.sqrt(4*np.pi) # normalized isotropic distribution where Variable Interpretation nlm_len Number of expansion coefficients for expansion series truncated at \\(l=L\\) nlm Vector of complex-valued expansion coefficients (state vector) lm Vector of degree and order integers ( l , m ) associated with each entry in nlm","title":"Initialize"},{"location":"lattice-rotation/","text":"Lattice rotation When subject to simple shear, the orientation of easy slip systems in polycrystalline materials like ice or olivine tend towards aligning with the bulk shear-plane system. That is, the \\(n\\) -axis ( \\(c\\) -axis in ice) tends towards to bulk shear plane normal, and the \\(b\\) -axis ( \\(a\\) -axis in ice) towards to bulk shear direction. Thus, if grains are perfectly aligned with the bulk shear system, their orientation should be unaffected by any further shearing, but be in steady state. Clearly, slip systems do therefore not simply co-rotate with the bulk continuum spin ( \\({\\boldsymbol \\omega}\\) ) like passive material line elements embedded in a flow field, i.e. \\({\\bf \\dot{n}} \\neq {\\boldsymbol \\omega} \\cdot {\\bf n}\\) . Rather, slip systems must be subject to an additional contribution \u2014 a plastic spin \\({\\boldsymbol\\omega}'\\) \u2014 such that the bulk spin is exactly counteracted to achieve steady state if favorably aligned: \\[ {\\bf \\dot{n}} = ({\\boldsymbol\\omega} + {\\boldsymbol\\omega}'_{n}) \\cdot {\\bf n} = {\\bf 0} , \\] \\[ {\\bf \\dot{b}} = ({\\boldsymbol\\omega} + {\\boldsymbol\\omega}'_{b}) \\cdot {\\bf b} = {\\bf 0} . \\] More precisely, the crystallographic axes reorient themselves in response to both the bulk continuum spin and a plastic spin that is supposed to represent the crystallographic spin needed to accommodate strain compatibility between grains that otherwise preferentially deform by easy slip (i.e., basal slip for ice). Directors method Aravas and Aifantis (1991) and Aravas (1994) (among others) proposed a particularly simple model for the functional form of \\({\\boldsymbol \\omega}'\\) , the so-called directors method. For a constant rate of shear deformation ( \\(1/\\tau\\) ) aligned with the \\({\\bf b}\\) \u2014 \\({\\bf n}\\) system, the deformation gradient is \\({\\bf F} = {\\bf I} + (t/\\tau) {\\bf b}{\\bf n}\\) and therefore \\[ \\nabla {\\bf u} = \\frac{1}{\\tau} {\\bf b}{\\bf n} \\quad \\Longrightarrow\\quad {\\dot{\\boldsymbol\\epsilon}} = \\frac{1}{2\\tau} ({\\bf b}{\\bf n} + {\\bf n}{\\bf b}), \\quad {\\boldsymbol \\omega} = \\frac{1}{2\\tau} ({\\bf b}{\\bf n} - {\\bf n}{\\bf b}) . \\] Since \\({\\boldsymbol \\omega}' = -{\\boldsymbol \\omega}\\) is required in steady state, it follows from eliminating \\(1/(2\\tau)\\) by calculating \\({\\dot{\\boldsymbol\\epsilon}} \\cdot {\\bf n}^2\\) , \\({\\bf n}^2 \\cdot {\\dot{\\boldsymbol\\epsilon}}\\) , \\({\\dot{\\boldsymbol\\epsilon}} \\cdot {\\bf b}^2\\) , and \\({\\bf b}^2 \\cdot {\\dot{\\boldsymbol\\epsilon}}\\) , that \\[ {\\boldsymbol \\omega}'_{n} = +{\\bf n}^2 \\cdot {\\dot{\\boldsymbol\\epsilon}} - {\\dot{\\boldsymbol\\epsilon}} \\cdot {\\bf n}^2 , \\\\ {\\boldsymbol \\omega}'_{b} = -{\\bf b}^2 \\cdot {\\dot{\\boldsymbol\\epsilon}} + {\\dot{\\boldsymbol\\epsilon}} \\cdot {\\bf b}^2 . \\] Indeed, this result agrees with representation theorems for isotropic functions (Wang, 1969), stating that an antisymmetric tensor-valued function of a symmetric tensor ( \\({\\dot{\\boldsymbol\\epsilon}}\\) ) and a vector ( \\({\\hat {\\bf r}}\\) ) is to lowest order given by \\[ {\\boldsymbol \\omega}' = \\iota({\\hat {\\bf r}}^2\\cdot{\\dot{\\boldsymbol\\epsilon}} - {\\dot{\\boldsymbol\\epsilon}}\\cdot{\\hat {\\bf r}}^2) . \\] To be consistent with the above, \\(\\iota = +1\\) for \\({\\hat {\\bf r}}={\\bf n}\\) and \\(\\iota = -1\\) for \\({\\hat {\\bf r}}={\\bf b}\\) . \\({\\boldsymbol \\omega}'_{n}\\) and \\({\\boldsymbol \\omega}'_{b}\\) are then generally taken to suffice for other deformation kinematics, too. Glacier ice The predicted normalized \\(c\\) -axis velocity field for glacier ice where \\({\\bf n} = {\\bf c}\\) is show below for three different deformation kinematics: Matrix model The corresponding effect on the continuous distribution functions is modelled as a conservative advection process in orientation space \\(S^2\\) : \\[ \\frac{\\mathrm{D} n}{\\mathrm{D} t} = -\\nabla_{S^2}\\cdot(n{\\bf \\dot{n}}) \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}_n}{\\mathrm{D} t} = {\\bf M_{\\mathrm{LROT}}}(\\iota=+1) \\cdot {\\bf s}_n, \\] \\[ \\frac{\\mathrm{D} b}{\\mathrm{D} t} = -\\nabla_{S^2}\\cdot(b{\\bf \\dot{b}}) \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}_b}{\\mathrm{D} t} = {\\bf M_{\\mathrm{LROT}}}(\\iota=-1) \\cdot {\\bf s}_b, \\] where \\({\\bf M_{\\mathrm{LROT}}}(\\iota)\\) is given analytically in Rathmann et al. (2021) . Code example import numpy as np from specfabpy import specfab as sf # L=8 truncation is sufficient in this case, but larger L allows a very strong fabric to # develop and minimizes the effect that regularization has on low wavenumber modes (l=2,4) lm, nlm_len = sf.init(8) ### Velocity gradient tensor experienced by parcel ugrad = np.diag([0.5, 0.5, -1.0]) # uniaxial compression along z-axis D = (ugrad+np.transpose(ugrad))/2 # symmetric part (strain rate tensor) W = (ugrad-np.transpose(ugrad))/2 # anti-symmetric part (spin tensor) ### Numerics Nt = 25 # number of time steps dt = 0.05 # time-step size ### Initial fabric state nlm = np.zeros((Nt,nlm_len), dtype=np.complex64) # n state vector nlm[0,0] = 1/np.sqrt(4*np.pi) # normalized isotropic state at t=0 ### Euler integration for tt in np.arange(1,Nt): nlm_prev = nlm[tt-1,:] # previous solution iota, zeta = 1, 0 # \"deck of cards\" behavior M_LROT = sf.M_LROT(nlm_prev, D, W, iota, zeta) # lattice rotation operator M_REG = sf.M_REG(nlm_prev, D) # regularization operator M = M_LROT + M_REG nlm[tt,:] = nlm_prev + dt*np.matmul(M, nlm_prev) # euler step nlm[tt,:] = sf.apply_bounds(nlm[tt,:]) # apply spectral bounds if needed","title":"Lattice rotation"},{"location":"lattice-rotation/#lattice-rotation","text":"When subject to simple shear, the orientation of easy slip systems in polycrystalline materials like ice or olivine tend towards aligning with the bulk shear-plane system. That is, the \\(n\\) -axis ( \\(c\\) -axis in ice) tends towards to bulk shear plane normal, and the \\(b\\) -axis ( \\(a\\) -axis in ice) towards to bulk shear direction. Thus, if grains are perfectly aligned with the bulk shear system, their orientation should be unaffected by any further shearing, but be in steady state. Clearly, slip systems do therefore not simply co-rotate with the bulk continuum spin ( \\({\\boldsymbol \\omega}\\) ) like passive material line elements embedded in a flow field, i.e. \\({\\bf \\dot{n}} \\neq {\\boldsymbol \\omega} \\cdot {\\bf n}\\) . Rather, slip systems must be subject to an additional contribution \u2014 a plastic spin \\({\\boldsymbol\\omega}'\\) \u2014 such that the bulk spin is exactly counteracted to achieve steady state if favorably aligned: \\[ {\\bf \\dot{n}} = ({\\boldsymbol\\omega} + {\\boldsymbol\\omega}'_{n}) \\cdot {\\bf n} = {\\bf 0} , \\] \\[ {\\bf \\dot{b}} = ({\\boldsymbol\\omega} + {\\boldsymbol\\omega}'_{b}) \\cdot {\\bf b} = {\\bf 0} . \\] More precisely, the crystallographic axes reorient themselves in response to both the bulk continuum spin and a plastic spin that is supposed to represent the crystallographic spin needed to accommodate strain compatibility between grains that otherwise preferentially deform by easy slip (i.e., basal slip for ice).","title":"Lattice rotation"},{"location":"lattice-rotation/#directors-method","text":"Aravas and Aifantis (1991) and Aravas (1994) (among others) proposed a particularly simple model for the functional form of \\({\\boldsymbol \\omega}'\\) , the so-called directors method. For a constant rate of shear deformation ( \\(1/\\tau\\) ) aligned with the \\({\\bf b}\\) \u2014 \\({\\bf n}\\) system, the deformation gradient is \\({\\bf F} = {\\bf I} + (t/\\tau) {\\bf b}{\\bf n}\\) and therefore \\[ \\nabla {\\bf u} = \\frac{1}{\\tau} {\\bf b}{\\bf n} \\quad \\Longrightarrow\\quad {\\dot{\\boldsymbol\\epsilon}} = \\frac{1}{2\\tau} ({\\bf b}{\\bf n} + {\\bf n}{\\bf b}), \\quad {\\boldsymbol \\omega} = \\frac{1}{2\\tau} ({\\bf b}{\\bf n} - {\\bf n}{\\bf b}) . \\] Since \\({\\boldsymbol \\omega}' = -{\\boldsymbol \\omega}\\) is required in steady state, it follows from eliminating \\(1/(2\\tau)\\) by calculating \\({\\dot{\\boldsymbol\\epsilon}} \\cdot {\\bf n}^2\\) , \\({\\bf n}^2 \\cdot {\\dot{\\boldsymbol\\epsilon}}\\) , \\({\\dot{\\boldsymbol\\epsilon}} \\cdot {\\bf b}^2\\) , and \\({\\bf b}^2 \\cdot {\\dot{\\boldsymbol\\epsilon}}\\) , that \\[ {\\boldsymbol \\omega}'_{n} = +{\\bf n}^2 \\cdot {\\dot{\\boldsymbol\\epsilon}} - {\\dot{\\boldsymbol\\epsilon}} \\cdot {\\bf n}^2 , \\\\ {\\boldsymbol \\omega}'_{b} = -{\\bf b}^2 \\cdot {\\dot{\\boldsymbol\\epsilon}} + {\\dot{\\boldsymbol\\epsilon}} \\cdot {\\bf b}^2 . \\] Indeed, this result agrees with representation theorems for isotropic functions (Wang, 1969), stating that an antisymmetric tensor-valued function of a symmetric tensor ( \\({\\dot{\\boldsymbol\\epsilon}}\\) ) and a vector ( \\({\\hat {\\bf r}}\\) ) is to lowest order given by \\[ {\\boldsymbol \\omega}' = \\iota({\\hat {\\bf r}}^2\\cdot{\\dot{\\boldsymbol\\epsilon}} - {\\dot{\\boldsymbol\\epsilon}}\\cdot{\\hat {\\bf r}}^2) . \\] To be consistent with the above, \\(\\iota = +1\\) for \\({\\hat {\\bf r}}={\\bf n}\\) and \\(\\iota = -1\\) for \\({\\hat {\\bf r}}={\\bf b}\\) . \\({\\boldsymbol \\omega}'_{n}\\) and \\({\\boldsymbol \\omega}'_{b}\\) are then generally taken to suffice for other deformation kinematics, too. Glacier ice The predicted normalized \\(c\\) -axis velocity field for glacier ice where \\({\\bf n} = {\\bf c}\\) is show below for three different deformation kinematics:","title":"Directors method"},{"location":"lattice-rotation/#matrix-model","text":"The corresponding effect on the continuous distribution functions is modelled as a conservative advection process in orientation space \\(S^2\\) : \\[ \\frac{\\mathrm{D} n}{\\mathrm{D} t} = -\\nabla_{S^2}\\cdot(n{\\bf \\dot{n}}) \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}_n}{\\mathrm{D} t} = {\\bf M_{\\mathrm{LROT}}}(\\iota=+1) \\cdot {\\bf s}_n, \\] \\[ \\frac{\\mathrm{D} b}{\\mathrm{D} t} = -\\nabla_{S^2}\\cdot(b{\\bf \\dot{b}}) \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}_b}{\\mathrm{D} t} = {\\bf M_{\\mathrm{LROT}}}(\\iota=-1) \\cdot {\\bf s}_b, \\] where \\({\\bf M_{\\mathrm{LROT}}}(\\iota)\\) is given analytically in Rathmann et al. (2021) .","title":"Matrix model"},{"location":"lattice-rotation/#code-example","text":"import numpy as np from specfabpy import specfab as sf # L=8 truncation is sufficient in this case, but larger L allows a very strong fabric to # develop and minimizes the effect that regularization has on low wavenumber modes (l=2,4) lm, nlm_len = sf.init(8) ### Velocity gradient tensor experienced by parcel ugrad = np.diag([0.5, 0.5, -1.0]) # uniaxial compression along z-axis D = (ugrad+np.transpose(ugrad))/2 # symmetric part (strain rate tensor) W = (ugrad-np.transpose(ugrad))/2 # anti-symmetric part (spin tensor) ### Numerics Nt = 25 # number of time steps dt = 0.05 # time-step size ### Initial fabric state nlm = np.zeros((Nt,nlm_len), dtype=np.complex64) # n state vector nlm[0,0] = 1/np.sqrt(4*np.pi) # normalized isotropic state at t=0 ### Euler integration for tt in np.arange(1,Nt): nlm_prev = nlm[tt-1,:] # previous solution iota, zeta = 1, 0 # \"deck of cards\" behavior M_LROT = sf.M_LROT(nlm_prev, D, W, iota, zeta) # lattice rotation operator M_REG = sf.M_REG(nlm_prev, D) # regularization operator M = M_LROT + M_REG nlm[tt,:] = nlm_prev + dt*np.matmul(M, nlm_prev) # euler step nlm[tt,:] = sf.apply_bounds(nlm[tt,:]) # apply spectral bounds if needed","title":"Code example"},{"location":"recrystallization-CDRX/","text":"Continous dynamic recrystallization (CDRX) Polygonization (rotation recrystallization, CDRX) accounts for the division of grains along internal sub-grain boundaries resulting from local strain incompatibilities. In effect, CDRX reduces the average grain size upon grain division but does not necessarily change the CPO much ( Alley, 1992 ). Following G\u00f6dert (2003) , CDRX can be modeled by approximating this effect as a Laplacian diffusive process on \\(S^2\\) : \\[ \\frac{\\mathrm{D} n}{\\mathrm{D} t} = \\Lambda\\nabla^2 n , \\] where \\(\\Lambda\\) is the CDRX rate-factor magnitude that depends on temperature, stress, strain-rate, etc. ( Richards et al., 2021 ). Limited use Notice that this model is currently only relevant to slip-system normals. The model is therefore not yet useful for e.g. olivine. Matrix model The corresponding effect on the continuous distribution function is \\[ \\frac{\\mathrm{D} n}{\\mathrm{D} t} = \\Lambda\\nabla^2 n \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}}{\\mathrm{D} t} = {\\bf M_{\\mathrm{CDRX}}} \\cdot {\\bf s} . \\] Code example import numpy as np from specfabpy import specfab as sf # L=8 truncation is sufficient in this case, but larger L allows a very strong fabric to # develop and minimizes the effect that regularization has on low wavenumber modes (l=2,4) L = 8 lm, nlm_len = sf.init(L) ### Numerics Nt = 25 # number of time steps dt = 0.05 # time-step size ### Initial fabric state nlm = np.zeros((Nt,nlm_len), dtype=np.complex64) # n state vector nlm[0,:] = sf.nlm_ideal([0,0,1], 0, L) # sigle maximum at t=0 ### Euler integration for tt in np.arange(1,Nt): nlm_prev = nlm[tt-1,:] # previous solution Lambda = 1 # CDRX rate-factor M = Lambda*sf.M_CDRX(nlm) # CDRX operator nlm[tt,:] = nlm_prev + dt*np.matmul(M, nlm_prev) # euler step nlm[tt,:] = sf.apply_bounds(nlm[tt,:]) # apply spectral bounds if needed","title":"Continous DRX"},{"location":"recrystallization-CDRX/#continous-dynamic-recrystallization-cdrx","text":"Polygonization (rotation recrystallization, CDRX) accounts for the division of grains along internal sub-grain boundaries resulting from local strain incompatibilities. In effect, CDRX reduces the average grain size upon grain division but does not necessarily change the CPO much ( Alley, 1992 ). Following G\u00f6dert (2003) , CDRX can be modeled by approximating this effect as a Laplacian diffusive process on \\(S^2\\) : \\[ \\frac{\\mathrm{D} n}{\\mathrm{D} t} = \\Lambda\\nabla^2 n , \\] where \\(\\Lambda\\) is the CDRX rate-factor magnitude that depends on temperature, stress, strain-rate, etc. ( Richards et al., 2021 ). Limited use Notice that this model is currently only relevant to slip-system normals. The model is therefore not yet useful for e.g. olivine.","title":"Continous dynamic recrystallization (CDRX)"},{"location":"recrystallization-CDRX/#matrix-model","text":"The corresponding effect on the continuous distribution function is \\[ \\frac{\\mathrm{D} n}{\\mathrm{D} t} = \\Lambda\\nabla^2 n \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}}{\\mathrm{D} t} = {\\bf M_{\\mathrm{CDRX}}} \\cdot {\\bf s} . \\]","title":"Matrix model"},{"location":"recrystallization-CDRX/#code-example","text":"import numpy as np from specfabpy import specfab as sf # L=8 truncation is sufficient in this case, but larger L allows a very strong fabric to # develop and minimizes the effect that regularization has on low wavenumber modes (l=2,4) L = 8 lm, nlm_len = sf.init(L) ### Numerics Nt = 25 # number of time steps dt = 0.05 # time-step size ### Initial fabric state nlm = np.zeros((Nt,nlm_len), dtype=np.complex64) # n state vector nlm[0,:] = sf.nlm_ideal([0,0,1], 0, L) # sigle maximum at t=0 ### Euler integration for tt in np.arange(1,Nt): nlm_prev = nlm[tt-1,:] # previous solution Lambda = 1 # CDRX rate-factor M = Lambda*sf.M_CDRX(nlm) # CDRX operator nlm[tt,:] = nlm_prev + dt*np.matmul(M, nlm_prev) # euler step nlm[tt,:] = sf.apply_bounds(nlm[tt,:]) # apply spectral bounds if needed","title":"Code example"},{"location":"recrystallization-DDRX/","text":"Discontinous dynamic recrystallization (DDRX) Following Placidi and others (2010) , DDRX is modeled as a spontaneous mass decay\u2014production process in orientation space \\(S^2\\) , intended to represent the combined effect of nucleation and grain boundary migration. That is, mass is spontaneously exchanged between grains with different orientations depending on the local stress state, strain rate, and temperature, in a statistical sense. The decay\u2014production rate is defined as \\[ \\Gamma = \\Gamma_0\\left(D- {\\langle} D {\\rangle}\\right) \\] where the prefactor \\(\\Gamma_0\\) accounts for the preferential (Arrhenius) activation at warm temperatures and the effect of strain-rate magnitude, defined as \\begin{align} \\Gamma_0 = \\sqrt{\\frac{{\\dot{\\boldsymbol\\epsilon}}:{\\dot{\\boldsymbol\\epsilon}}}{2}} A_{\\Gamma}\\exp(-Q_{\\Gamma}/RT) . \\end{align} Here, \\({\\dot{\\boldsymbol\\epsilon}}\\) is the strain-rate tensor, \\(R\\) is the gas constant, \\(T\\) is the temperature, and \\(A_{\\Gamma}\\) and \\(Q_{\\Gamma}\\) have been calibration by Richards et al. (2021) and Lilien et al. (2023) . The deformability \\(D\\) is the square of the basal-plane resolved shear stress \\[ \\tau^2_\\mathrm{RSS} = ({\\boldsymbol\\tau}\\cdot{\\boldsymbol\\tau}):{\\bf n}^2 - {\\boldsymbol\\tau}:{\\bf n}^4:{\\boldsymbol\\tau}, \\] relative to the average value of an isotropic fabric: \\[ D = \\frac{\\tau^2_\\mathrm{RSS}}{\\langle \\tau^2_\\mathrm{RSS} \\rangle_\\mathrm{iso}} = \\frac{({\\boldsymbol\\tau}\\cdot{\\boldsymbol\\tau}):{\\bf n}^2 - {\\boldsymbol\\tau}:{\\bf n}^4:{\\boldsymbol\\tau}}{{\\boldsymbol\\tau}:{\\boldsymbol\\tau}/5}, \\] where \\({\\bf n}\\) is an arbitrary slip-plane normal ( \\(c\\) -axis for ice). Because \\(D\\) is largest for grains with an orientation favorable to easy glide, mass is spontaneously created/added to grains with such preferred orientations (in a statistical sense). Conversely, mass spontaneously decays if \\(D<{\\langle} D {\\rangle}\\) , corresponding to grains with an unfavorable orientation being consumed by grains with a more favorable orientation to basal glide. Here, \\({\\langle} D {\\rangle}\\) is the grain-average deformability of the polycrystal, and the total mass of the polycrystal is conserved since \\(\\Gamma\\) is zero on average, \\(\\langle\\Gamma\\rangle=\\Gamma_0\\langle D-\\langle D\\rangle\\rangle=0\\) (equal amounts of grain mass are created and destroyed per time). The primary driver for grain boundary migration is generally regarded to be the contrast in dislocation density (stored strain energy) between grains. In this sense, \\(1/D\\) can be understood as a parameterization of the dislocation density: the larger \\(1/D\\) is, the more dislocations a grain has, and the more likely it is to be consumed (decay). Nonlinear process Since average deformability \\(\\langle D\\rangle\\) depends on the instantaneous CPO state \u2014 specifically, the structure tensors \\(\\langle{\\bf c}^2\\rangle\\) and \\(\\langle{\\bf c}^4\\rangle\\) \u2014 this crystal process is nonlinear (renders a nonlinear matrix problem below). Limited use Notice that this model is currently only relevant to slip-system normals. The model is therefore not yet useful for e.g. olivine. Glacier ice The normalized decay\u2014production rate is shown below for three different stress states: Matrix model The corresponding effect on the continuous distribution function is \\[ \\frac{\\mathrm{D} n}{\\mathrm{D} t} = \\Gamma n \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}_n}{\\mathrm{D} t} = {\\bf M_{\\mathrm{DDRX}}} \\cdot {\\bf s}_n , \\] where \\({\\bf M_{\\mathrm{DDRX}}}\\) is given analytically in Rathmann and Lilien (2021) . Code example import numpy as np from specfabpy import specfab as sf # L=8 truncation is sufficient in this case, but larger L allows a very strong fabric to # develop and minimizes the effect that regularization has on low wavenumber modes (l=2,4) lm, nlm_len = sf.init(8) ### Stress tensor experienced by parcel S = np.diag([0.5, 0.5, -1.0]) # uniaxial compression along z-axis ### Numerics Nt = 25 # number of time steps dt = 0.05 # time-step size ### Initial fabric state nlm = np.zeros((Nt,nlm_len), dtype=np.complex64) # n state vector nlm[0,0] = 1/np.sqrt(4*np.pi) # normalized isotropic state at t=0 ### Euler integration for tt in np.arange(1,Nt): nlm_prev = nlm[tt-1,:] # previous solution Gamma0 = 10 # DDRX decay-rate magnitude M = Gamma0 * sf.M_DDRX(nlm_prev, S) # DDRX operator nlm[tt,:] = nlm_prev + dt*np.matmul(M, nlm_prev) # euler step nlm[tt,:] = sf.apply_bounds(nlm[tt,:]) # apply spectral bounds if needed","title":"Discontinous DRX"},{"location":"recrystallization-DDRX/#discontinous-dynamic-recrystallization-ddrx","text":"Following Placidi and others (2010) , DDRX is modeled as a spontaneous mass decay\u2014production process in orientation space \\(S^2\\) , intended to represent the combined effect of nucleation and grain boundary migration. That is, mass is spontaneously exchanged between grains with different orientations depending on the local stress state, strain rate, and temperature, in a statistical sense. The decay\u2014production rate is defined as \\[ \\Gamma = \\Gamma_0\\left(D- {\\langle} D {\\rangle}\\right) \\] where the prefactor \\(\\Gamma_0\\) accounts for the preferential (Arrhenius) activation at warm temperatures and the effect of strain-rate magnitude, defined as \\begin{align} \\Gamma_0 = \\sqrt{\\frac{{\\dot{\\boldsymbol\\epsilon}}:{\\dot{\\boldsymbol\\epsilon}}}{2}} A_{\\Gamma}\\exp(-Q_{\\Gamma}/RT) . \\end{align} Here, \\({\\dot{\\boldsymbol\\epsilon}}\\) is the strain-rate tensor, \\(R\\) is the gas constant, \\(T\\) is the temperature, and \\(A_{\\Gamma}\\) and \\(Q_{\\Gamma}\\) have been calibration by Richards et al. (2021) and Lilien et al. (2023) . The deformability \\(D\\) is the square of the basal-plane resolved shear stress \\[ \\tau^2_\\mathrm{RSS} = ({\\boldsymbol\\tau}\\cdot{\\boldsymbol\\tau}):{\\bf n}^2 - {\\boldsymbol\\tau}:{\\bf n}^4:{\\boldsymbol\\tau}, \\] relative to the average value of an isotropic fabric: \\[ D = \\frac{\\tau^2_\\mathrm{RSS}}{\\langle \\tau^2_\\mathrm{RSS} \\rangle_\\mathrm{iso}} = \\frac{({\\boldsymbol\\tau}\\cdot{\\boldsymbol\\tau}):{\\bf n}^2 - {\\boldsymbol\\tau}:{\\bf n}^4:{\\boldsymbol\\tau}}{{\\boldsymbol\\tau}:{\\boldsymbol\\tau}/5}, \\] where \\({\\bf n}\\) is an arbitrary slip-plane normal ( \\(c\\) -axis for ice). Because \\(D\\) is largest for grains with an orientation favorable to easy glide, mass is spontaneously created/added to grains with such preferred orientations (in a statistical sense). Conversely, mass spontaneously decays if \\(D<{\\langle} D {\\rangle}\\) , corresponding to grains with an unfavorable orientation being consumed by grains with a more favorable orientation to basal glide. Here, \\({\\langle} D {\\rangle}\\) is the grain-average deformability of the polycrystal, and the total mass of the polycrystal is conserved since \\(\\Gamma\\) is zero on average, \\(\\langle\\Gamma\\rangle=\\Gamma_0\\langle D-\\langle D\\rangle\\rangle=0\\) (equal amounts of grain mass are created and destroyed per time). The primary driver for grain boundary migration is generally regarded to be the contrast in dislocation density (stored strain energy) between grains. In this sense, \\(1/D\\) can be understood as a parameterization of the dislocation density: the larger \\(1/D\\) is, the more dislocations a grain has, and the more likely it is to be consumed (decay). Nonlinear process Since average deformability \\(\\langle D\\rangle\\) depends on the instantaneous CPO state \u2014 specifically, the structure tensors \\(\\langle{\\bf c}^2\\rangle\\) and \\(\\langle{\\bf c}^4\\rangle\\) \u2014 this crystal process is nonlinear (renders a nonlinear matrix problem below). Limited use Notice that this model is currently only relevant to slip-system normals. The model is therefore not yet useful for e.g. olivine. Glacier ice The normalized decay\u2014production rate is shown below for three different stress states:","title":"Discontinous dynamic recrystallization (DDRX)"},{"location":"recrystallization-DDRX/#matrix-model","text":"The corresponding effect on the continuous distribution function is \\[ \\frac{\\mathrm{D} n}{\\mathrm{D} t} = \\Gamma n \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}_n}{\\mathrm{D} t} = {\\bf M_{\\mathrm{DDRX}}} \\cdot {\\bf s}_n , \\] where \\({\\bf M_{\\mathrm{DDRX}}}\\) is given analytically in Rathmann and Lilien (2021) .","title":"Matrix model"},{"location":"recrystallization-DDRX/#code-example","text":"import numpy as np from specfabpy import specfab as sf # L=8 truncation is sufficient in this case, but larger L allows a very strong fabric to # develop and minimizes the effect that regularization has on low wavenumber modes (l=2,4) lm, nlm_len = sf.init(8) ### Stress tensor experienced by parcel S = np.diag([0.5, 0.5, -1.0]) # uniaxial compression along z-axis ### Numerics Nt = 25 # number of time steps dt = 0.05 # time-step size ### Initial fabric state nlm = np.zeros((Nt,nlm_len), dtype=np.complex64) # n state vector nlm[0,0] = 1/np.sqrt(4*np.pi) # normalized isotropic state at t=0 ### Euler integration for tt in np.arange(1,Nt): nlm_prev = nlm[tt-1,:] # previous solution Gamma0 = 10 # DDRX decay-rate magnitude M = Gamma0 * sf.M_DDRX(nlm_prev, S) # DDRX operator nlm[tt,:] = nlm_prev + dt*np.matmul(M, nlm_prev) # euler step nlm[tt,:] = sf.apply_bounds(nlm[tt,:]) # apply spectral bounds if needed","title":"Code example"},{"location":"wavepropagation-elastic/","text":"Elastic wave propagation Plane waves are a well-known solution to the Cauchy-Navier equation of motion \\[ \\nabla\\cdot {\\boldsymbol \\sigma} = \\rho \\frac{\\partial^2 {\\bf d}}{\\partial t^2}, \\] where \\({\\boldsymbol \\sigma}\\) is the bulk stress tensor, \\({\\bf d}\\) is the displacement field, and \\(\\rho\\) the mass density. Substituting \\({\\bf d}\\) for a plane wave solution, \\({\\bf d} = {\\bf d}_0 \\exp[i({\\bf k}\\cdot {\\bf x} - \\omega t)]\\) , the problem reduces to \\[ (k^2\\hat{{\\bf Q}} - \\omega^2 \\rho {\\bf I}) {\\bf d} = {\\bf 0}, \\] where \\(\\hat{{\\bf Q}}(\\hat{{\\bf k}})\\) is the normalized acoustic tensor that varies depending on the bulk constitutive equation substituted for \\({\\boldsymbol \\sigma}({\\bf d})\\) . The above equation requires \\[ \\det( k^2\\hat{{\\bf Q}} - \\omega^2 \\rho {\\bf I} ) = 0 . \\] Evidently, the eigenvalues and eigenvectors of \\(\\hat{{\\bf Q}}/\\rho\\) are the permitted wave velocities squared and wave polarization, respectively, where \\[ V^2 = \\frac{\\omega^2}{k^2} \\] is the wave velocity squared. Homogenization The problem may be closed by approximating \\(\\hat{{\\bf Q}}\\) as the grain-averaged acoustic tensor, subject to a linear combination of the Voigt and Reuss homogenization schemes: \\[ \\hat{{\\bf Q}} = (1-\\alpha) \\langle\\hat{{\\bf Q}}'_{\\mathrm{Reuss}}\\rangle + \\alpha \\langle \\hat{{\\bf Q}}'_{\\mathrm{Voigt}}\\rangle . \\] The Voigt scheme ( \\(\\alpha=1\\) ) assumes the strain field is homogeneous over the polycrystal scale, whereas the Reuss scheme ( \\(\\alpha=0\\) ) assumes the stress is homogeneous. In these homogenizations, grains are therefore assumed interactionless and the bulk elastic behaviour is therefore simply the grain-orientation-averaged elastic behaviour subject to either homogeneous stress or strain assumptions over the polycrystal scale. Grain parameters The grain elastic parameters used for homogenization should be understood as the effective polycrystal values needed to reproduce experimental results; they are not the values derived from experiments on single crystals. Glacier ice If ice grains are approximated as transversely isotropic, their elastic behaviour can be modelled using the transversely isotropic elastic constitutive equation . This requires specifying the grain elastic parameters \\(\\lambda'\\) , \\(\\mu'\\) , \\(\\hat{\\lambda}'\\) , \\(\\hat{\\mu}'\\) , \\(\\hat{\\gamma}'\\) , and the Voigt\u2014Reuss weight \\(\\alpha\\) . Code example import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(4) # L=4 is sufficient here nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients ### CPO from fourth-order structure tensor p = np.array([0,0,1]) # preferred c-axis direction a4 = np.einsum('i,j,k,l', p,p,p,p) # a4 if n(r) = deltafunc(r-p) nlm[:sf.L4len] = sf.a4_to_nlm(a4) # l<=4 expansion coefficients ### Physical parameters (SI units) rho = 917 # density of ice Cij = (14.060e9, 15.240e9, 3.060e9, 7.150e9, 5.880e9) # Bennett (1968) parameters (C11,C33,C55,C12,C13) Lame_grain = sf.Cij_to_Lame_tranisotropic(Cij) # Lame parameters (lam,mu,Elam,Emu,Egam) alpha = 0.5 # Voigt--Reuss weight, where 0.5 = Hill average ### Propagation directions of interest theta, phi = np.deg2rad([90,70,]), np.deg2rad([0,10,]) # theta=colatitude, phi=longitude ### Calculate phase velocities Vi = sf.Vi_elastic_tranisotropic(nlm, alpha, Lame_grain, rho, theta,phi) # phase velocities are V_S1=vi[0,:], V_S2=vi[1,:], V_P=vi[2,:] The below animation shows directional P- and S-wave velocities for a CPO evolving under uniaxial compression along \\({\\hat {\\bf z}}\\) , relative to an isotropic CPO, when subject to lattice rotation . Olivine If olivine grains are approximated as orthotropic, their elastic behaviour can be modelled using the orthotropic elastic constitutive equation . This requires specifying the grain elastic parameters \\(\\lambda_{ij}'\\) , \\(\\mu_{i}'\\) , and the Voigt\u2014Reuss weight \\(\\alpha\\) . Code example import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(4) # L=4 is sufficient here nlm = np.zeros((nlm_len), dtype=np.complex64) blm = np.zeros((nlm_len), dtype=np.complex64) ### CPO (nlm,blm) from fourth-order structure tensors vn = np.array([0,0,1]) # preferred slip-normal direction vb = np.array([1,0,0]) # preferred slip direction a4_n = np.einsum('i,j,k,l', vn,vn,vn,vn) # a4 if n(r) = deltafunc(r-vn) a4_b = np.einsum('i,j,k,l', vb,vb,vb,vb) # a4 if b(r) = deltafunc(r-vb) nlm[:sf.L4len] = sf.a4_to_nlm(a4_n) # l<=4 expansion coefficients blm[:sf.L4len] = sf.a4_to_nlm(a4_b) # l<=4 expansion coefficients ### Physical parameters (SI units) rho = 3355 # density of olivine alpha = 1 # Voigt--Reuss weight; only alpha=1 supported for now Cij = (320.5e9, 196.5e9, 233.5e9, 64.0e9, 77.0e9, 78.7e9, 76.8e9, 71.6e9, 68.15e9) # Abramson (1997) parameters (C11,C22,C33,C44,C55,C66,C23,C13,C12) Lame_grain = sf.Cij_to_Lame_orthotropic(Cij) # Lame parameters (lam11,lam22,lam33, lam23,lam13,lam12, mu1,mu2,mu3) # Note that the above ordering of Lame/Cij parameters assume an A-type fabric; that is, (blm,nlm,vlm) refer to the distibutions of (m1',m2',m3') axes, respectively. # If concerned with another fabric type, the components can easily be re-ordered: #Lame_grain = sf.Lame_olivine_A2X(Lame_grain, 'B') # B-type Lame paremeters #Lame_grain = sf.Lame_olivine_A2X(Lame_grain, 'C') # C-type Lame paremeters ### Propagation directions of interest theta, phi = np.deg2rad([90,70,]), np.deg2rad([0,10,]) # theta=colatitude, phi=longitude ### Calculate phase velocities vlm = 0*nlm # estimate vlm from (blm,nlm) by passing zero array Vi = sf.Vi_elastic_orthotropic(blm,nlm,vlm, alpha, Lame_grain, rho, theta,phi) # phase velocities are V_S1=vi[0,:], V_S2=vi[1,:], V_P=vi[2,:]","title":"Elastic"},{"location":"wavepropagation-elastic/#elastic-wave-propagation","text":"Plane waves are a well-known solution to the Cauchy-Navier equation of motion \\[ \\nabla\\cdot {\\boldsymbol \\sigma} = \\rho \\frac{\\partial^2 {\\bf d}}{\\partial t^2}, \\] where \\({\\boldsymbol \\sigma}\\) is the bulk stress tensor, \\({\\bf d}\\) is the displacement field, and \\(\\rho\\) the mass density. Substituting \\({\\bf d}\\) for a plane wave solution, \\({\\bf d} = {\\bf d}_0 \\exp[i({\\bf k}\\cdot {\\bf x} - \\omega t)]\\) , the problem reduces to \\[ (k^2\\hat{{\\bf Q}} - \\omega^2 \\rho {\\bf I}) {\\bf d} = {\\bf 0}, \\] where \\(\\hat{{\\bf Q}}(\\hat{{\\bf k}})\\) is the normalized acoustic tensor that varies depending on the bulk constitutive equation substituted for \\({\\boldsymbol \\sigma}({\\bf d})\\) . The above equation requires \\[ \\det( k^2\\hat{{\\bf Q}} - \\omega^2 \\rho {\\bf I} ) = 0 . \\] Evidently, the eigenvalues and eigenvectors of \\(\\hat{{\\bf Q}}/\\rho\\) are the permitted wave velocities squared and wave polarization, respectively, where \\[ V^2 = \\frac{\\omega^2}{k^2} \\] is the wave velocity squared.","title":"Elastic wave propagation"},{"location":"wavepropagation-elastic/#homogenization","text":"The problem may be closed by approximating \\(\\hat{{\\bf Q}}\\) as the grain-averaged acoustic tensor, subject to a linear combination of the Voigt and Reuss homogenization schemes: \\[ \\hat{{\\bf Q}} = (1-\\alpha) \\langle\\hat{{\\bf Q}}'_{\\mathrm{Reuss}}\\rangle + \\alpha \\langle \\hat{{\\bf Q}}'_{\\mathrm{Voigt}}\\rangle . \\] The Voigt scheme ( \\(\\alpha=1\\) ) assumes the strain field is homogeneous over the polycrystal scale, whereas the Reuss scheme ( \\(\\alpha=0\\) ) assumes the stress is homogeneous. In these homogenizations, grains are therefore assumed interactionless and the bulk elastic behaviour is therefore simply the grain-orientation-averaged elastic behaviour subject to either homogeneous stress or strain assumptions over the polycrystal scale. Grain parameters The grain elastic parameters used for homogenization should be understood as the effective polycrystal values needed to reproduce experimental results; they are not the values derived from experiments on single crystals.","title":"Homogenization"},{"location":"wavepropagation-elastic/#glacier-ice","text":"If ice grains are approximated as transversely isotropic, their elastic behaviour can be modelled using the transversely isotropic elastic constitutive equation . This requires specifying the grain elastic parameters \\(\\lambda'\\) , \\(\\mu'\\) , \\(\\hat{\\lambda}'\\) , \\(\\hat{\\mu}'\\) , \\(\\hat{\\gamma}'\\) , and the Voigt\u2014Reuss weight \\(\\alpha\\) .","title":"Glacier ice"},{"location":"wavepropagation-elastic/#code-example","text":"import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(4) # L=4 is sufficient here nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients ### CPO from fourth-order structure tensor p = np.array([0,0,1]) # preferred c-axis direction a4 = np.einsum('i,j,k,l', p,p,p,p) # a4 if n(r) = deltafunc(r-p) nlm[:sf.L4len] = sf.a4_to_nlm(a4) # l<=4 expansion coefficients ### Physical parameters (SI units) rho = 917 # density of ice Cij = (14.060e9, 15.240e9, 3.060e9, 7.150e9, 5.880e9) # Bennett (1968) parameters (C11,C33,C55,C12,C13) Lame_grain = sf.Cij_to_Lame_tranisotropic(Cij) # Lame parameters (lam,mu,Elam,Emu,Egam) alpha = 0.5 # Voigt--Reuss weight, where 0.5 = Hill average ### Propagation directions of interest theta, phi = np.deg2rad([90,70,]), np.deg2rad([0,10,]) # theta=colatitude, phi=longitude ### Calculate phase velocities Vi = sf.Vi_elastic_tranisotropic(nlm, alpha, Lame_grain, rho, theta,phi) # phase velocities are V_S1=vi[0,:], V_S2=vi[1,:], V_P=vi[2,:] The below animation shows directional P- and S-wave velocities for a CPO evolving under uniaxial compression along \\({\\hat {\\bf z}}\\) , relative to an isotropic CPO, when subject to lattice rotation .","title":"Code example"},{"location":"wavepropagation-elastic/#olivine","text":"If olivine grains are approximated as orthotropic, their elastic behaviour can be modelled using the orthotropic elastic constitutive equation . This requires specifying the grain elastic parameters \\(\\lambda_{ij}'\\) , \\(\\mu_{i}'\\) , and the Voigt\u2014Reuss weight \\(\\alpha\\) .","title":"Olivine"},{"location":"wavepropagation-elastic/#code-example_1","text":"import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(4) # L=4 is sufficient here nlm = np.zeros((nlm_len), dtype=np.complex64) blm = np.zeros((nlm_len), dtype=np.complex64) ### CPO (nlm,blm) from fourth-order structure tensors vn = np.array([0,0,1]) # preferred slip-normal direction vb = np.array([1,0,0]) # preferred slip direction a4_n = np.einsum('i,j,k,l', vn,vn,vn,vn) # a4 if n(r) = deltafunc(r-vn) a4_b = np.einsum('i,j,k,l', vb,vb,vb,vb) # a4 if b(r) = deltafunc(r-vb) nlm[:sf.L4len] = sf.a4_to_nlm(a4_n) # l<=4 expansion coefficients blm[:sf.L4len] = sf.a4_to_nlm(a4_b) # l<=4 expansion coefficients ### Physical parameters (SI units) rho = 3355 # density of olivine alpha = 1 # Voigt--Reuss weight; only alpha=1 supported for now Cij = (320.5e9, 196.5e9, 233.5e9, 64.0e9, 77.0e9, 78.7e9, 76.8e9, 71.6e9, 68.15e9) # Abramson (1997) parameters (C11,C22,C33,C44,C55,C66,C23,C13,C12) Lame_grain = sf.Cij_to_Lame_orthotropic(Cij) # Lame parameters (lam11,lam22,lam33, lam23,lam13,lam12, mu1,mu2,mu3) # Note that the above ordering of Lame/Cij parameters assume an A-type fabric; that is, (blm,nlm,vlm) refer to the distibutions of (m1',m2',m3') axes, respectively. # If concerned with another fabric type, the components can easily be re-ordered: #Lame_grain = sf.Lame_olivine_A2X(Lame_grain, 'B') # B-type Lame paremeters #Lame_grain = sf.Lame_olivine_A2X(Lame_grain, 'C') # C-type Lame paremeters ### Propagation directions of interest theta, phi = np.deg2rad([90,70,]), np.deg2rad([0,10,]) # theta=colatitude, phi=longitude ### Calculate phase velocities vlm = 0*nlm # estimate vlm from (blm,nlm) by passing zero array Vi = sf.Vi_elastic_orthotropic(blm,nlm,vlm, alpha, Lame_grain, rho, theta,phi) # phase velocities are V_S1=vi[0,:], V_S2=vi[1,:], V_P=vi[2,:]","title":"Code example"},{"location":"wavepropagation-electromagnetic/","text":"Electromagnetic wave propagation Plane waves are a well-known solution to Maxwell's equations in a non-conducting, source-free, anisotropic linear dielectric medium \\[ \\nabla \\times \\nabla \\times {\\bf E} = -\\mu {\\boldsymbol \\epsilon} \\frac{\\partial^2 {\\bf E}}{\\partial t^2}, \\] where \\({\\bf E}\\) is the electric field, \\({\\boldsymbol \\epsilon}\\) is the bulk dielectric permittivity tensor, and \\(\\mu\\) the bulk isotropic permeability of the medium. Note this can also be written as \\(\\nabla^2 {\\bf E} = \\mu {\\boldsymbol \\epsilon} {\\partial^2 {\\bf E}}/{\\partial t^2}\\) . Substituting \\({\\bf E}\\) for a plane wave solution, \\({\\bf E} = {\\bf E}_0 \\exp[i({\\bf k}\\cdot {\\bf x} - \\omega t)]\\) , the problem reduces to \\[ ({\\bf K} + \\omega^2 \\mu {\\boldsymbol \\epsilon}) {\\bf E} = {\\bf 0}, \\] where \\({\\bf K} = {\\bf k}\\times{\\bf k} \\times\\) is the matrix representation of the twice-applied cross product. The above equation requires \\[ \\det( {\\bf K} + \\omega^2 \\mu {\\boldsymbol \\epsilon} ) = 0 . \\] Evidently, the eigenvalues and eigenvectors of \\({\\boldsymbol \\epsilon}^{-1} {\\bf K}/(\\mu k^2)\\) are the permitted wave velocities squared and wave polarization, respectively, where \\[ V^2 = \\frac{\\omega^2}{k^2} \\] is the wave velocity squared. Homogenization If wave lengths are much longer than the average grain size, the problem can be closed by approximating the bulk polycrystalline permittivity tensor by the grain-averaged permittivity tensor \\[{\\boldsymbol \\epsilon} = \\langle {\\boldsymbol \\epsilon}' \\rangle,\\] constructed by averaging over all grain orientations (over the CPO). Glacier ice If ice grains are approximated as transversely isotropic w.r.t. the \\(c\\) -axis, the dielectric permittivity tensor of a single crystal can be written as $$ {\\boldsymbol \\epsilon}' = (2\\epsilon_{a}' + \\epsilon_{c}') \\frac{\\bf I}{3} + (\\epsilon_{c}'-\\epsilon_{a}') \\left( {\\bf c}^2 - \\frac{\\bf I}{3} \\right), $$ where \\(\\epsilon_{c}'\\) and \\(\\epsilon_{a}'\\) are the permittivities parallel and perpendicular to the \\(c\\) axis. In this case, the grain-averaged permitivity is simply \\[ \\langle {\\boldsymbol \\epsilon}'\\rangle = (2\\epsilon_{a}' + \\epsilon_{c}') \\frac{\\bf I}{3} + (\\epsilon_{c}'-\\epsilon_{a}') \\left( \\langle {\\bf c}^2 \\rangle - \\frac{\\bf I}{3} \\right) , \\] where \\(\\langle {\\bf c}^2 \\rangle\\) is the second-order structure tensor . Code example Experimental, bug reports are welcome. import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(4) nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients ### Physical parameters (note eps=eps0*epsr, mu=mu0*mur) epsr_c = 3.17 # relative permittivity of a single grain parallel to symmetry axis (c) epsr_a = 3.17-0.034 # relative permittivity of a single grain perpendicular to symmetry axis (a) mur = 1 # relative permeability of a single grain ### CPO from second-order structure tensor p = np.array([0,0,1]) # preferred c-axis direction a2 = np.einsum('i,j', p,p) # a2 if MODF = deltafunc(r-p) nlm[:sf.L2len] = sf.a2_to_nlm(a2) # l<=2 expansion coefficients ### Propagation directions of interest theta, phi = np.deg2rad([0,90,]), np.deg2rad([0,0,]) # theta=colatitude, phi=longitude ### Calculate phase velocities Vi = sf.Vi_electromagnetic_tranisotropic(nlm, epsr_c, epsr_a, mur, theta,phi) # fast and slow phase velocities are V_S1=vi[0,:], V_S2=vi[1,:] The below animation shows directional S-wave velocities for a CPO evolving under \\(xz\\) confined compression , relative to an isotropic CPO, when subject to lattice rotation . Olivine \ud83d\udea7 Not yet supported.","title":"Electromagnetic"},{"location":"wavepropagation-electromagnetic/#electromagnetic-wave-propagation","text":"Plane waves are a well-known solution to Maxwell's equations in a non-conducting, source-free, anisotropic linear dielectric medium \\[ \\nabla \\times \\nabla \\times {\\bf E} = -\\mu {\\boldsymbol \\epsilon} \\frac{\\partial^2 {\\bf E}}{\\partial t^2}, \\] where \\({\\bf E}\\) is the electric field, \\({\\boldsymbol \\epsilon}\\) is the bulk dielectric permittivity tensor, and \\(\\mu\\) the bulk isotropic permeability of the medium. Note this can also be written as \\(\\nabla^2 {\\bf E} = \\mu {\\boldsymbol \\epsilon} {\\partial^2 {\\bf E}}/{\\partial t^2}\\) . Substituting \\({\\bf E}\\) for a plane wave solution, \\({\\bf E} = {\\bf E}_0 \\exp[i({\\bf k}\\cdot {\\bf x} - \\omega t)]\\) , the problem reduces to \\[ ({\\bf K} + \\omega^2 \\mu {\\boldsymbol \\epsilon}) {\\bf E} = {\\bf 0}, \\] where \\({\\bf K} = {\\bf k}\\times{\\bf k} \\times\\) is the matrix representation of the twice-applied cross product. The above equation requires \\[ \\det( {\\bf K} + \\omega^2 \\mu {\\boldsymbol \\epsilon} ) = 0 . \\] Evidently, the eigenvalues and eigenvectors of \\({\\boldsymbol \\epsilon}^{-1} {\\bf K}/(\\mu k^2)\\) are the permitted wave velocities squared and wave polarization, respectively, where \\[ V^2 = \\frac{\\omega^2}{k^2} \\] is the wave velocity squared.","title":"Electromagnetic wave propagation"},{"location":"wavepropagation-electromagnetic/#homogenization","text":"If wave lengths are much longer than the average grain size, the problem can be closed by approximating the bulk polycrystalline permittivity tensor by the grain-averaged permittivity tensor \\[{\\boldsymbol \\epsilon} = \\langle {\\boldsymbol \\epsilon}' \\rangle,\\] constructed by averaging over all grain orientations (over the CPO).","title":"Homogenization"},{"location":"wavepropagation-electromagnetic/#glacier-ice","text":"If ice grains are approximated as transversely isotropic w.r.t. the \\(c\\) -axis, the dielectric permittivity tensor of a single crystal can be written as $$ {\\boldsymbol \\epsilon}' = (2\\epsilon_{a}' + \\epsilon_{c}') \\frac{\\bf I}{3} + (\\epsilon_{c}'-\\epsilon_{a}') \\left( {\\bf c}^2 - \\frac{\\bf I}{3} \\right), $$ where \\(\\epsilon_{c}'\\) and \\(\\epsilon_{a}'\\) are the permittivities parallel and perpendicular to the \\(c\\) axis. In this case, the grain-averaged permitivity is simply \\[ \\langle {\\boldsymbol \\epsilon}'\\rangle = (2\\epsilon_{a}' + \\epsilon_{c}') \\frac{\\bf I}{3} + (\\epsilon_{c}'-\\epsilon_{a}') \\left( \\langle {\\bf c}^2 \\rangle - \\frac{\\bf I}{3} \\right) , \\] where \\(\\langle {\\bf c}^2 \\rangle\\) is the second-order structure tensor .","title":"Glacier ice"},{"location":"wavepropagation-electromagnetic/#code-example","text":"Experimental, bug reports are welcome. import numpy as np from specfabpy import specfab as sf lm, nlm_len = sf.init(4) nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients ### Physical parameters (note eps=eps0*epsr, mu=mu0*mur) epsr_c = 3.17 # relative permittivity of a single grain parallel to symmetry axis (c) epsr_a = 3.17-0.034 # relative permittivity of a single grain perpendicular to symmetry axis (a) mur = 1 # relative permeability of a single grain ### CPO from second-order structure tensor p = np.array([0,0,1]) # preferred c-axis direction a2 = np.einsum('i,j', p,p) # a2 if MODF = deltafunc(r-p) nlm[:sf.L2len] = sf.a2_to_nlm(a2) # l<=2 expansion coefficients ### Propagation directions of interest theta, phi = np.deg2rad([0,90,]), np.deg2rad([0,0,]) # theta=colatitude, phi=longitude ### Calculate phase velocities Vi = sf.Vi_electromagnetic_tranisotropic(nlm, epsr_c, epsr_a, mur, theta,phi) # fast and slow phase velocities are V_S1=vi[0,:], V_S2=vi[1,:] The below animation shows directional S-wave velocities for a CPO evolving under \\(xz\\) confined compression , relative to an isotropic CPO, when subject to lattice rotation .","title":"Code example"},{"location":"wavepropagation-electromagnetic/#olivine","text":"\ud83d\udea7 Not yet supported.","title":"Olivine"}]}
{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"specfab documentation Spectral CPO model of polycrystalline materials that: Can model lattice rotation, discontinuous DRX, and rotation/continuous DRX. Can calculate CPO-induced viscous anisotropies using Sachs/Taylor homogenizations. Can calculate elastic P- and S-wave velocities using Voigt/Reuss homogenizations. Contains expressions for forward+inverse orthotropic and transversely isotropic rheologies. Can convert between structure tensors and spectral expansions coefficients. Can be integrated with finite-element models such as Elmer and FEniCS. By Nicholas M. Rathmann and David A. Lilien Glacier ice demo Install Source code available here Enviroment How to Python A pre-compiled module exists for Linux: pip3 install numpy --upgrade && pip3 install specfabpy Compile Python module - For a local-only install, run make specfabpy in /src (requires LAPACK and BLAS) - To install for general use (in other folders), run make python in /src . Note that if you do not have write permissions for your python installation, you can instead run make specfabpy; python setup.py install --user Fortran The Fortran module is built by running make specfab.o Elmer/Ice Interface To interface with Elmer/Ice, you need a shared version of the libraries (built with the same Fortran compiler as Elmer). If needed, change the compiler in src/Makefile , then run make libspecfab.so Literature Component Reference Lattice rotation Rathmann et al. (2021) Discontinuous dynamic recrystallization Rathmann and Lilien (2021) Orthotropic bulk rheologies Rathmann and Lilien (2022) Elastic wave velocities Rathmann et al. (2022) Initialize Initialize specfabpy by running import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(10) # L=10 truncation is sufficient for many cases nlm = np.zeros(nlm_len, dtype=np.complex64) nlm[0] = 1/np.sqrt(4*np.pi) # Normalized, isotropic distribution where Variable Interpretation nlm_len Number of expansion coefficients for expansion series truncated at \\(l=L\\) nlm Vector of complex-valued expansion coefficients (state vector) lm Vector of degree and order integers ( l , m ) associated with each entry in nlm","title":"About"},{"location":"#specfab-documentation","text":"Spectral CPO model of polycrystalline materials that: Can model lattice rotation, discontinuous DRX, and rotation/continuous DRX. Can calculate CPO-induced viscous anisotropies using Sachs/Taylor homogenizations. Can calculate elastic P- and S-wave velocities using Voigt/Reuss homogenizations. Contains expressions for forward+inverse orthotropic and transversely isotropic rheologies. Can convert between structure tensors and spectral expansions coefficients. Can be integrated with finite-element models such as Elmer and FEniCS. By Nicholas M. Rathmann and David A. Lilien","title":"specfab documentation"},{"location":"#glacier-ice-demo","text":"","title":"Glacier ice demo"},{"location":"#install","text":"Source code available here Enviroment How to Python A pre-compiled module exists for Linux: pip3 install numpy --upgrade && pip3 install specfabpy Compile Python module - For a local-only install, run make specfabpy in /src (requires LAPACK and BLAS) - To install for general use (in other folders), run make python in /src . Note that if you do not have write permissions for your python installation, you can instead run make specfabpy; python setup.py install --user Fortran The Fortran module is built by running make specfab.o Elmer/Ice Interface To interface with Elmer/Ice, you need a shared version of the libraries (built with the same Fortran compiler as Elmer). If needed, change the compiler in src/Makefile , then run make libspecfab.so","title":"Install"},{"location":"#literature","text":"Component Reference Lattice rotation Rathmann et al. (2021) Discontinuous dynamic recrystallization Rathmann and Lilien (2021) Orthotropic bulk rheologies Rathmann and Lilien (2022) Elastic wave velocities Rathmann et al. (2022)","title":"Literature"},{"location":"#initialize","text":"Initialize specfabpy by running import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(10) # L=10 truncation is sufficient for many cases nlm = np.zeros(nlm_len, dtype=np.complex64) nlm[0] = 1/np.sqrt(4*np.pi) # Normalized, isotropic distribution where Variable Interpretation nlm_len Number of expansion coefficients for expansion series truncated at \\(l=L\\) nlm Vector of complex-valued expansion coefficients (state vector) lm Vector of degree and order integers ( l , m ) associated with each entry in nlm","title":"Initialize"},{"location":"FEM-integration-elmer/","text":"Elmer integration To be updated.","title":"Elmer FEM integration"},{"location":"FEM-integration-elmer/#elmer-integration","text":"To be updated.","title":"Elmer integration"},{"location":"FEM-integration-fenics/","text":"FEniCS integration To be updated.","title":"FEniCS FEM integration"},{"location":"FEM-integration-fenics/#fenics-integration","text":"To be updated.","title":"FEniCS integration"},{"location":"constitutive-elastic/","text":"Elastic constitutive equations Linear elastic constituve equations are supported in both forward and inverse (or reverse) form. Transversely isotropic Symmetries Stiffness matrix \\({\\bf C}\\) for \\(\\bf{m}=\\hat{\\bf{z}}\\) \\(\\begin{bmatrix}\\gamma & \\lambda & \\hat{\\lambda}\\lambda & 0 & 0 & 0 \\\\\\lambda & \\gamma & \\hat{\\lambda}\\lambda & 0 & 0 & 0 \\\\\\hat{\\lambda}\\lambda & \\hat{\\lambda}\\lambda & \\hat{\\gamma}\\gamma & 0 & 0 & 0 \\\\0&0&0& \\hat{\\mu}\\mu & 0 & 0\\\\0&0&0& 0 & \\hat{\\mu}\\mu & 0\\\\0&0&0& 0 & 0 & \\mu\\\\\\end{bmatrix}\\) E = sf.elas_fwd_tranisotropic(S, lam, mu, Elam, Emu, Egam, m) S = sf.elas_rev_tranisotropic(E, lam, mu, Elam, Emu, Egam, m) where Arguments Type S , E stress and strain tensor (3x3) lam , mu Isotropic Lam\u00e9 parameters \\(\\lambda\\) and \\(\\mu\\) Elam , Emu , Egam Anisotropic enhancement factors \\(\\hat{\\lambda}\\) , \\(\\hat{\\mu}\\) , and \\(\\hat{\\gamma}\\) Note P-wave modulus is not a free parameter but given by \\(\\gamma \\equiv \\lambda + 2\\mu\\) . Tip: convert from \\(C_{ij}\\) to Lam\u00e9 parameters lam,mu,Elam,Emu,Egam = sf.Cij_to_Lame_tranisotropic(C11,C33,C55,C12,C13) Orthotropic Symmetries Stiffness matrix \\({\\bf C}\\) for \\(({\\bf m}_1,{\\bf m}_2,{\\bf m}_3)=(\\hat{{\\bf x}},\\hat{{\\bf y}},\\hat{{\\bf z}})\\) \\(\\small\\begin{bmatrix} \\lambda_{11} + 2\\mu_1 & \\lambda_{12} & \\lambda_{13} & 0 & 0 & 0 \\\\ \\lambda_{12} & \\lambda_{22} + 2\\mu_2 & \\lambda_{23} & 0 & 0 & 0 \\\\ \\lambda_{13 }& \\lambda_{23} & \\lambda_{33} + 2\\mu_3 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & \\dfrac{\\mu_2+\\mu_3}{2} & 0 & 0 \\\\ 0 & 0 & 0 & 0 & \\dfrac{\\mu_3+\\mu_1}{2} & 0 \\\\ 0 & 0 & 0 & 0 & 0 & \\dfrac{\\mu_1+\\mu_2}{2} \\end{bmatrix}\\) Not yet available","title":"Constitutive equations"},{"location":"constitutive-elastic/#elastic-constitutive-equations","text":"Linear elastic constituve equations are supported in both forward and inverse (or reverse) form.","title":"Elastic constitutive equations"},{"location":"constitutive-elastic/#transversely-isotropic","text":"Symmetries Stiffness matrix \\({\\bf C}\\) for \\(\\bf{m}=\\hat{\\bf{z}}\\) \\(\\begin{bmatrix}\\gamma & \\lambda & \\hat{\\lambda}\\lambda & 0 & 0 & 0 \\\\\\lambda & \\gamma & \\hat{\\lambda}\\lambda & 0 & 0 & 0 \\\\\\hat{\\lambda}\\lambda & \\hat{\\lambda}\\lambda & \\hat{\\gamma}\\gamma & 0 & 0 & 0 \\\\0&0&0& \\hat{\\mu}\\mu & 0 & 0\\\\0&0&0& 0 & \\hat{\\mu}\\mu & 0\\\\0&0&0& 0 & 0 & \\mu\\\\\\end{bmatrix}\\)","title":"Transversely isotropic"},{"location":"constitutive-elastic/#e-sfelas_fwd_tranisotropics-lam-mu-elam-emu-egam-m","text":"","title":"E = sf.elas_fwd_tranisotropic(S, lam, mu, Elam, Emu, Egam, m)"},{"location":"constitutive-elastic/#s-sfelas_rev_tranisotropice-lam-mu-elam-emu-egam-m","text":"where Arguments Type S , E stress and strain tensor (3x3) lam , mu Isotropic Lam\u00e9 parameters \\(\\lambda\\) and \\(\\mu\\) Elam , Emu , Egam Anisotropic enhancement factors \\(\\hat{\\lambda}\\) , \\(\\hat{\\mu}\\) , and \\(\\hat{\\gamma}\\) Note P-wave modulus is not a free parameter but given by \\(\\gamma \\equiv \\lambda + 2\\mu\\) . Tip: convert from \\(C_{ij}\\) to Lam\u00e9 parameters lam,mu,Elam,Emu,Egam = sf.Cij_to_Lame_tranisotropic(C11,C33,C55,C12,C13)","title":"S = sf.elas_rev_tranisotropic(E, lam, mu, Elam, Emu, Egam, m)"},{"location":"constitutive-elastic/#orthotropic","text":"Symmetries Stiffness matrix \\({\\bf C}\\) for \\(({\\bf m}_1,{\\bf m}_2,{\\bf m}_3)=(\\hat{{\\bf x}},\\hat{{\\bf y}},\\hat{{\\bf z}})\\) \\(\\small\\begin{bmatrix} \\lambda_{11} + 2\\mu_1 & \\lambda_{12} & \\lambda_{13} & 0 & 0 & 0 \\\\ \\lambda_{12} & \\lambda_{22} + 2\\mu_2 & \\lambda_{23} & 0 & 0 & 0 \\\\ \\lambda_{13 }& \\lambda_{23} & \\lambda_{33} + 2\\mu_3 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & \\dfrac{\\mu_2+\\mu_3}{2} & 0 & 0 \\\\ 0 & 0 & 0 & 0 & \\dfrac{\\mu_3+\\mu_1}{2} & 0 \\\\ 0 & 0 & 0 & 0 & 0 & \\dfrac{\\mu_1+\\mu_2}{2} \\end{bmatrix}\\) Not yet available","title":"Orthotropic"},{"location":"constitutive-viscoplastic/","text":"Viscoplastic constitutive equations Anisotropic power-law rheologies are supported in both forward and inverse (or reverse) form. Eigenenhancements Anisotropic viscosities/fluidities are prescribed in terms of logitudinal and shear strain-rate enhancement factors w.r.t rheological symmetry axes, termed eigenenhancements ( \\(E_{ij}\\) ). Transversely isotropic Rheolgical symmetries Forward rheology $$ {\\bf D} = \\eta^{-1} \\Big( {\\bf S} - \\lambda_1 ({\\bf S}:{\\bf M}){\\bf I} + \\lambda_2 ({\\bf S}:{\\bf M}){\\bf M} + \\lambda_3 ({\\bf S}\\cdot{\\bf M} + {\\bf M}\\cdot{\\bf S}) \\Big) $$ $$ \\eta^{-1} = A\\Big( {\\bf S}:{\\bf S} + \\lambda_2 ({\\bf S}:{\\bf M})^2 + 2\\lambda_2 ({\\bf S}^2:{\\bf M}) \\Big)^{(n-1)/2} $$ $$ {\\bf M}={\\bf m}^2$$ where the material parameters \\(\\lambda_i\\) depend on the eigenenhancements: \\[ \\lambda_1 = \\frac{E_{mm}^{2/(n+1)}-1}{2} ,\\quad \\lambda_2 = \\frac{3(E_{mm}^{2/(n+1)}-1) - 4(E_{mt}^{2/(n+1)}-1)}{2} ,\\quad \\lambda_3 = E_{mt}^{2/(n+1)}-1 \\] API D = sf.rheo_fwd_tranisotropic(S, A, n, m, Eij) S = sf.rheo_rev_tranisotropic(D, A, n, m, Eij) Arguments Type S , D Deviatoric-stress and strain-rate tensor (3x3) A , n Flow-rate factor \\(A\\) and power-law exponent \\(n\\) m Rotational symmetry axis \\(\\bf{m}\\) Eij Tuple of eigenenhancements (Emm, Emt) Orthotropic Rheolgical symmetries Forward rheology \\({\\bf D} = \\eta^{-1} \\displaystyle\\sum_{i=1}^{3} \\Big[ \\lambda_i ({\\bf S}:{\\bf M}_i){\\bf M}_{i} + \\lambda_{i+3} ({\\bf S}:{\\bf M}_{i+3}) {\\bf M}_{i+3} \\Big]\\) \\(\\eta^{-1} = A\\left( \\displaystyle\\sum_{i=1}^3 \\Big[ \\lambda_i ({\\bf S}:{\\bf M}_{i})^2 + \\lambda_{i+3} ({\\bf S}:{\\bf M}_{i+3})^2 \\Big] \\right)^{(n-1)/2}\\) \\({\\bf M}_{i} = \\dfrac{{\\bf m}_{j_i} {\\bf m}_{j_i} - {\\bf m}_{k_i} {\\bf m}_{k_i}}{2} ,\\quad {\\bf M}_{i+3} = \\dfrac{{\\bf m}_{j_i} {\\bf m}_{k_i} + {\\bf m}_{k_i} {\\bf m}_{j_i}}{2},\\) \\((j_1, j_2, j_3) = (2,3,1),\\quad (k_1, k_2, k_3) = (3,1,2)\\) where the material parameters \\(\\lambda_i\\) depend on the eigenenhancements: \\[ \\lambda_i = \\frac{4}{3} \\left( E_{j_i j_i}^{2/(n+1)} + E_{k_i k_i}^{2/(n+1)} - E_{i i}^{2/(n+1)} \\right),\\quad \\lambda_{i+3} = 2 E_{j_i k_i}^{2/(n+1)} \\] API D = sf.rheo_fwd_orthotropic(S, A, n, m1,m2,m3, Eij) S = sf.rheo_rev_orthotropic(D, A, n, m1,m2,m3, Eij) Arguments Type S , D Deviatoric-stress and strain-rate tensor (3x3) A , n Flow-rate factor \\(A\\) and power-law exponent \\(n\\) m1 , m2 , m3 Reflection symmetry axes \\(\\bf{m}_1\\) , \\(\\bf{m}_2\\) , and \\(\\bf{m}_3\\) Eij Tuple of eigenenhancements (E11,E22,E33,E23,E13,E12)","title":"Constitutive equations"},{"location":"constitutive-viscoplastic/#viscoplastic-constitutive-equations","text":"Anisotropic power-law rheologies are supported in both forward and inverse (or reverse) form. Eigenenhancements Anisotropic viscosities/fluidities are prescribed in terms of logitudinal and shear strain-rate enhancement factors w.r.t rheological symmetry axes, termed eigenenhancements ( \\(E_{ij}\\) ).","title":"Viscoplastic constitutive equations"},{"location":"constitutive-viscoplastic/#transversely-isotropic","text":"Rheolgical symmetries Forward rheology $$ {\\bf D} = \\eta^{-1} \\Big( {\\bf S} - \\lambda_1 ({\\bf S}:{\\bf M}){\\bf I} + \\lambda_2 ({\\bf S}:{\\bf M}){\\bf M} + \\lambda_3 ({\\bf S}\\cdot{\\bf M} + {\\bf M}\\cdot{\\bf S}) \\Big) $$ $$ \\eta^{-1} = A\\Big( {\\bf S}:{\\bf S} + \\lambda_2 ({\\bf S}:{\\bf M})^2 + 2\\lambda_2 ({\\bf S}^2:{\\bf M}) \\Big)^{(n-1)/2} $$ $$ {\\bf M}={\\bf m}^2$$ where the material parameters \\(\\lambda_i\\) depend on the eigenenhancements: \\[ \\lambda_1 = \\frac{E_{mm}^{2/(n+1)}-1}{2} ,\\quad \\lambda_2 = \\frac{3(E_{mm}^{2/(n+1)}-1) - 4(E_{mt}^{2/(n+1)}-1)}{2} ,\\quad \\lambda_3 = E_{mt}^{2/(n+1)}-1 \\]","title":"Transversely isotropic"},{"location":"constitutive-viscoplastic/#api","text":"","title":"API"},{"location":"constitutive-viscoplastic/#d-sfrheo_fwd_tranisotropics-a-n-m-eij","text":"","title":"D = sf.rheo_fwd_tranisotropic(S, A, n, m, Eij)"},{"location":"constitutive-viscoplastic/#s-sfrheo_rev_tranisotropicd-a-n-m-eij","text":"Arguments Type S , D Deviatoric-stress and strain-rate tensor (3x3) A , n Flow-rate factor \\(A\\) and power-law exponent \\(n\\) m Rotational symmetry axis \\(\\bf{m}\\) Eij Tuple of eigenenhancements (Emm, Emt)","title":"S = sf.rheo_rev_tranisotropic(D, A, n, m, Eij)"},{"location":"constitutive-viscoplastic/#orthotropic","text":"Rheolgical symmetries Forward rheology \\({\\bf D} = \\eta^{-1} \\displaystyle\\sum_{i=1}^{3} \\Big[ \\lambda_i ({\\bf S}:{\\bf M}_i){\\bf M}_{i} + \\lambda_{i+3} ({\\bf S}:{\\bf M}_{i+3}) {\\bf M}_{i+3} \\Big]\\) \\(\\eta^{-1} = A\\left( \\displaystyle\\sum_{i=1}^3 \\Big[ \\lambda_i ({\\bf S}:{\\bf M}_{i})^2 + \\lambda_{i+3} ({\\bf S}:{\\bf M}_{i+3})^2 \\Big] \\right)^{(n-1)/2}\\) \\({\\bf M}_{i} = \\dfrac{{\\bf m}_{j_i} {\\bf m}_{j_i} - {\\bf m}_{k_i} {\\bf m}_{k_i}}{2} ,\\quad {\\bf M}_{i+3} = \\dfrac{{\\bf m}_{j_i} {\\bf m}_{k_i} + {\\bf m}_{k_i} {\\bf m}_{j_i}}{2},\\) \\((j_1, j_2, j_3) = (2,3,1),\\quad (k_1, k_2, k_3) = (3,1,2)\\) where the material parameters \\(\\lambda_i\\) depend on the eigenenhancements: \\[ \\lambda_i = \\frac{4}{3} \\left( E_{j_i j_i}^{2/(n+1)} + E_{k_i k_i}^{2/(n+1)} - E_{i i}^{2/(n+1)} \\right),\\quad \\lambda_{i+3} = 2 E_{j_i k_i}^{2/(n+1)} \\]","title":"Orthotropic"},{"location":"constitutive-viscoplastic/#api_1","text":"","title":"API"},{"location":"constitutive-viscoplastic/#d-sfrheo_fwd_orthotropics-a-n-m1m2m3-eij","text":"","title":"D = sf.rheo_fwd_orthotropic(S, A, n, m1,m2,m3, Eij)"},{"location":"constitutive-viscoplastic/#s-sfrheo_rev_orthotropicd-a-n-m1m2m3-eij","text":"Arguments Type S , D Deviatoric-stress and strain-rate tensor (3x3) A , n Flow-rate factor \\(A\\) and power-law exponent \\(n\\) m1 , m2 , m3 Reflection symmetry axes \\(\\bf{m}_1\\) , \\(\\bf{m}_2\\) , and \\(\\bf{m}_3\\) Eij Tuple of eigenenhancements (E11,E22,E33,E23,E13,E12)","title":"S = sf.rheo_rev_orthotropic(D, A, n, m1,m2,m3, Eij)"},{"location":"cpo-dynamics-orthotropic/","text":"CPO dynamics \u2014 Orthotropic grains Introduction This tutorial focuses on modelling the CPO evolution of polycrystalline olivine, understood as the distribution of (easy) slip-plane normals and slip directions of grains, \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) . Polycrystal Slip system The distributions \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) refer to certain crystallographic axes ( \\({\\bf r}_i\\) ) depending on the fabric type; i.e. thermodynamic conditions, water content, and stress magnitude that control which of the crystallographic slip systems is activated. Note The distributions may also be understood as the mass density fraction of grains with a given slip-plane-normal and slip-direction orientation. See CPO representation for details. Lagrangian material parcel The tutorial shows how to model the CPO evolution of a Lagrangian material parcel subject to three different modes of deformation/stress: Notation Given the expansions \\[ n({\\bf x},t,\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}n_{l}^{m}({\\bf x},t) Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip-plane normals)}, \\\\ b({\\bf x},t,\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}b_{l}^{m}({\\bf x},t) Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip directions)}, \\] CPO evolution can be written as a matrix problem involving the (block) state vector \\[ {\\bf s} = \\begin{bmatrix} {\\bf s}_n \\\\ {\\bf s}_b \\end{bmatrix} \\quad\\text{(state vector)}, \\] where \\[ {\\bf s}_n = [n_0^0,n_2^{-2},n_2^{-1},n_2^{0},n_2^{1},n_2^{2},n_4^{-4},\\cdots,n_4^{4},\\cdots,n_L^{-L},\\cdots,n_L^{L}]^{\\mathrm{T}} \\quad\\text{($n$ state vector)}, \\\\ {\\bf s}_b = [b_0^0,b_2^{-2},b_2^{-1},b_2^{0},b_2^{1},b_2^{2},b_4^{-4},\\cdots,b_4^{4},\\cdots,b_L^{-L},\\cdots,b_L^{L}]^{\\mathrm{T}} \\quad\\text{($b$ state vector)}, \\] such that \\[ \\frac{\\mathrm{D}{\\bf s}}{\\mathrm{D} t} = {\\bf M} \\cdot {\\bf s} \\quad\\text{(state evolution)}, \\] where the operator (matrix) \\({\\bf M}\\) represents the effect of a given CPO process, which may depend on stress, strain-rate, temperature, etc. Note Only lattice rotation is so far supported: \\({\\bf M} = {\\bf M}_{\\mathrm{LROT}}\\) . Lattice rotation To be published before documented here. Regularization Same as CPO dynamics for transversely isotropic grains","title":"Orthotropic grains"},{"location":"cpo-dynamics-orthotropic/#cpo-dynamics-orthotropic-grains","text":"","title":"CPO dynamics &mdash; Orthotropic grains"},{"location":"cpo-dynamics-orthotropic/#introduction","text":"This tutorial focuses on modelling the CPO evolution of polycrystalline olivine, understood as the distribution of (easy) slip-plane normals and slip directions of grains, \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) . Polycrystal Slip system The distributions \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) refer to certain crystallographic axes ( \\({\\bf r}_i\\) ) depending on the fabric type; i.e. thermodynamic conditions, water content, and stress magnitude that control which of the crystallographic slip systems is activated. Note The distributions may also be understood as the mass density fraction of grains with a given slip-plane-normal and slip-direction orientation. See CPO representation for details.","title":"Introduction"},{"location":"cpo-dynamics-orthotropic/#lagrangian-material-parcel","text":"The tutorial shows how to model the CPO evolution of a Lagrangian material parcel subject to three different modes of deformation/stress:","title":"Lagrangian material parcel"},{"location":"cpo-dynamics-orthotropic/#notation","text":"Given the expansions \\[ n({\\bf x},t,\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}n_{l}^{m}({\\bf x},t) Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip-plane normals)}, \\\\ b({\\bf x},t,\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}b_{l}^{m}({\\bf x},t) Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip directions)}, \\] CPO evolution can be written as a matrix problem involving the (block) state vector \\[ {\\bf s} = \\begin{bmatrix} {\\bf s}_n \\\\ {\\bf s}_b \\end{bmatrix} \\quad\\text{(state vector)}, \\] where \\[ {\\bf s}_n = [n_0^0,n_2^{-2},n_2^{-1},n_2^{0},n_2^{1},n_2^{2},n_4^{-4},\\cdots,n_4^{4},\\cdots,n_L^{-L},\\cdots,n_L^{L}]^{\\mathrm{T}} \\quad\\text{($n$ state vector)}, \\\\ {\\bf s}_b = [b_0^0,b_2^{-2},b_2^{-1},b_2^{0},b_2^{1},b_2^{2},b_4^{-4},\\cdots,b_4^{4},\\cdots,b_L^{-L},\\cdots,b_L^{L}]^{\\mathrm{T}} \\quad\\text{($b$ state vector)}, \\] such that \\[ \\frac{\\mathrm{D}{\\bf s}}{\\mathrm{D} t} = {\\bf M} \\cdot {\\bf s} \\quad\\text{(state evolution)}, \\] where the operator (matrix) \\({\\bf M}\\) represents the effect of a given CPO process, which may depend on stress, strain-rate, temperature, etc. Note Only lattice rotation is so far supported: \\({\\bf M} = {\\bf M}_{\\mathrm{LROT}}\\) .","title":"Notation"},{"location":"cpo-dynamics-orthotropic/#lattice-rotation","text":"To be published before documented here.","title":"Lattice rotation"},{"location":"cpo-dynamics-orthotropic/#regularization","text":"Same as CPO dynamics for transversely isotropic grains","title":"Regularization"},{"location":"cpo-dynamics-tranisotropic/","text":"CPO dynamics \u2014 Transversely isotropic grains Introduction This tutorial focuses on modelling the CPO evolution of polycrystalline glacier ice, understood as the \\({\\bf c}\\) -axis distribution or, equivelently, the distribution of (easy) slip-plane normals of grains, \\(n(\\theta,\\phi)\\) . Polycrystal Slip system Note \\(n(\\theta,\\phi)\\) may also be understood as the mass density fraction of grains with a given slip-plane normal orientation. See CPO representation for details. Lagrangian material parcel The tutorial shows how to model the CPO evolution of a Lagrangian material parcel subject to three different modes of deformation/stress: Notation Given the expansion \\[ n({\\bf x},t,\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}n_{l}^{m}({\\bf x},t) Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip-plane normals)}, \\] CPO evolution can be written as a matrix problem involving the state vector \\[ {\\bf s} = [n_0^0,n_2^{-2},n_2^{-1},n_2^{0},n_2^{1},n_2^{2},n_4^{-4},\\cdots,n_4^{4},\\cdots,n_L^{-L},\\cdots,n_L^{L}]^{\\mathrm{T}} \\quad\\text{(state vector)}, \\] such that \\[ \\frac{\\mathrm{D}{\\bf s}}{\\mathrm{D} t} = {\\bf M} \\cdot {\\bf s} \\quad\\text{(state evolution)}, \\] where the operator (matrix) \\({\\bf M}\\) represents the effect of a given CPO process, which may depend on stress, strain-rate, temperature, etc. The total effect of multiple processes acting simultaneously is simply \\[ {\\bf M} = {\\bf M_{\\mathrm{LROT}}} + {\\bf M_{\\mathrm{DDRX}}} + {\\bf M_{\\mathrm{CDRX}}} + \\cdots \\quad\\text{(operator)}. \\] Lattice rotation The strain-induced rotation of \\(c\\) -axes is modelled given the (local) velocity gradient tensor \\(\\nabla {\\bf u}\\) ( Svendsen and Hutter, 1996 ). The model is a kinematic model in the sense that \\(c\\) -axes rotate in response to the bulk rate of stretching, \\({\\bf D}\\) , and spin, \\({\\bf W}\\) , thereby allowing the detailed microscopic stress and strain rate fields to be neglected and hence interactions between neighboring grains to be disregarded. The modelled \\(c\\) -axes are taken to rotate with the bulk continuum spin ( \\({\\bf W}\\) ), plus some plastic spin correction ( \\({\\bf W}_{\\mathrm{p}}\\) ), so that the \\(c\\) -axis velocity field on the unit sphere is \\[ {\\bf \\dot{c}} = ({\\bf W} + {\\bf W}_{\\mathrm{p}}) \\cdot {\\bf c} \\quad\\text{($c$-axis velocity field)} , \\] where the plastic spin generally depends on \\({\\bf D}\\) to lowest and second lowest order as (Wang, 1969; Aravas, 1994 ) \\[ {\\bf W}_{\\mathrm{p}} = \\iota({\\bf c}\\otimes{\\bf c}\\cdot{\\bf D} - {\\bf D}\\cdot{\\bf c}\\otimes{\\bf c}) + \\zeta({\\bf c}\\otimes{\\bf c}\\cdot{\\bf D}^2 - {\\bf D}^2\\cdot{\\bf c}\\otimes{\\bf c}) . \\] By requiring that basal planes preserve their orientation when subject to simple shear (like a deck of cards), it can be shown that \\(\\iota=1\\) and \\(\\zeta=0\\) . The corresponding effect on the continuous \\(c\\) -axis distribution is modelled as a conservative advection process on the surface of the unit sphere: \\[ \\frac{\\mathrm{D} n}{\\mathrm{D} t} = -\\nabla_{S^2}\\cdot(n{\\bf \\dot{c}}) \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}}{\\mathrm{D} t} = {\\bf M_{\\mathrm{LROT}}} \\cdot {\\bf s}, \\] where \\({\\bf M_{\\mathrm{LROT}}}\\) is given analytically in Rathmann et al. (2021) . c-axis velocity field The normalized \\(c\\) -axis velocity fields for the three modes of deformation considered are: Example import numpy as np from specfabpy import specfabpy as sf # L=6 truncation is sufficient in this case, but larger L allows a very strong fabric to develop # and minimizes the effect that regularization has on low wavenumber modes (l=2,4) lm, nlm_len = sf.init(8) ### Velocity gradient tensor experienced by parcel ugrad = np.diag([0.5, 0.5, -1.0]) # Unconfined compression along z-direction (equal extension in x and y) D = (ugrad+np.transpose(ugrad))/2 # Symmetric part (strain-rate tensor) W = (ugrad-np.transpose(ugrad))/2 # Anti-symmetric part (spin tensor) ### Numerics Nt = 25 # Number of time steps dt = 0.05 # Time-step size ### Initialize fabric as isotropic nlm = np.zeros((Nt,nlm_len), dtype=np.complex64) # State vector (array of expansion coefficients) nlm[0,0] = 1/np.sqrt(4*np.pi) # Normalized ODF at t=0 ### Euler integration of lattice rotation + regularization for tt in np.arange(1,Nt): nlm_prev = nlm[tt-1,:] # Previous solution iota, zeta = 1, 0 # \"Deck of cards\" behavior M_LROT = sf.M_LROT(nlm_prev, D, W, iota, zeta) # Lattice rotation operator (nlm_len x nlm_len matrix) M_REG = sf.M_REG(nlm_prev, D) # Regularization operator (nlm_len x nlm_len matrix) M = M_LROT + M_REG nlm[tt,:] = nlm_prev + dt*np.matmul(M, nlm_prev) # Euler step nlm[tt,:] = sf.apply_bounds(nlm[tt,:]) # Apply spectral bounds if needed # To plot the resulting ODF or calculate structure tensors, see CPO representation pages. See also demo code in repository . Discontinous dynamic recrystallization (DDRX) DDRX is modelled as a grain orientation or mass decay/production process on the unit sphere ( Placidi and others, 2010 ): \\[ \\frac{\\mathrm{D} n}{\\mathrm{D} t} = \\Gamma n \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}}{\\mathrm{D} t} = {\\bf M_{\\mathrm{DDRX}}} \\cdot {\\bf s} , \\] where the decay/production rate \\[\\Gamma = \\Gamma_0\\left(D- {\\langle} D {\\rangle}\\right) \\quad\\text{(decay/production rate)}\\] depends on the rate magnitude \\(\\Gamma_0\\) , and the deformability \\(D\\) as a function of the stress tensor \\({\\bf S}\\) : \\[ D = \\frac{({\\bf S}\\cdot{\\bf S}):({\\bf c}\\otimes{\\bf c}) - {\\bf S}:({\\bf c}\\otimes{\\bf c}\\otimes{\\bf c}\\otimes{\\bf c}):{\\bf S}}{{\\bf S}:{\\bf S}}\\quad\\text{(deformability)} . \\] \\({\\bf M_{\\mathrm{DDRX}}}\\) is given analytically in Rathmann and Lilien (2021) . Note The average deformability, \\(\\langle D\\rangle\\) , depends on the instantaneous CPO state \u2014 specifically, the structure tensors a2 and a4 \u2014 making the corresponding matrix problem nonlinear by conserving the total number of grain orientations or mass density depending on how normalization is interpreted , the latter arguably resting on stronger physical grounds. Decay/production rate The normalized DDRX decay/production rate \\(\\Gamma/\\Gamma_0 = D - \\langle D \\rangle\\) is an orientation dependent field that favors nucleation (orientation/mass production) in the directions where the resolved basal-plane shear stress is maximal, and orientation/mass decay elsewhere. The the normalized decay rate for the three modes of deformation considered are: Example import numpy as np from specfabpy import specfabpy as sf # L=6 truncation is sufficient in this case, but larger L allows a very strong fabric to develop # and minimizes the effect that regularization has on low wavenumber modes (l=2,4) lm, nlm_len = sf.init(8) ### Stress tensor experienced by parcel S = np.diag([0.0, 1.0, -1.0]) # Confined compression along z-direction (extension confined to y-direction) #S = np.diag([0.5, 0.5, -1.0]) # Unconfined compression along z-direction Gamma0 = 10 # DDRX decay-rate magnitude (may depend on temperature, strain-rate, and other factors, see e.g. Richards et al., 2021) ### Numerics Nt = 25 # Number of time steps dt = 0.05 # Time-step size ### Initialize fabric as isotropic nlm = np.zeros((Nt,nlm_len), dtype=np.complex64) # State vector (array of expansion coefficients) nlm[0,0] = 1/np.sqrt(4*np.pi) # Normalized ODF at t=0 ### Euler integration of DDRX for tt in np.arange(1,Nt): nlm_prev = nlm[tt-1,:] # Previous solution M = Gamma0 * sf.M_DDRX(nlm_prev, S) # DDRX operator (nlm_len x nlm_len matrix) nlm[tt,:] = nlm_prev + dt*np.matmul(M, nlm_prev) # Complete Euler step nlm[tt,:] = sf.apply_bounds(nlm[tt,:]) # Apply spectral bounds if needed # To plot the resulting ODF or calculate structure tensors, see CPO representation pages. Continous dynamic recrystallization (CDRX) Polygonization (rotation recrystallization, CDRX) accounts for the division of grains along internal sub-grain boundaries when exposed to bending stresses. In effect, CDRX reduces the average grain size upon grain division but does not necessarily change the CPO much ( Alley, 1992 ). The model follows G\u00f6dert (2003) by approximating the effect of CDRX on the distribution of grain orientations/mass as a Laplacian diffusive process on \\(S^2\\) : \\[ \\frac{\\mathrm{D} n}{\\mathrm{D} t} = \\Lambda\\nabla^2 n \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}}{\\mathrm{D} t} = {\\bf M_{\\mathrm{CDRX}}} \\cdot {\\bf s} . \\] Example To model CDRX, add the following contribution to the total fabric operator \\({\\bf M}\\) : M += Lambda*sf.M_CDRX(nlm) where Lambda is the CDRX rate-factor magnitude, \\(\\Lambda\\) , that possibly depends on temperature, stress, strain-rate, etc. ( Richards et al., 2021 ). Regularization As \\(n(\\theta,\\phi)\\) becomes anisotropic due to CPO processes, the coefficients \\(n_l^m\\) associated with high wavenumber modes (large \\(l\\) and \\(m\\) , and thus small-scale structure) must increase in magnitude relative to the low wavenumber coefficients (small \\(l\\) and \\(m\\) ). One way to visualize this is by the angular power spectrum \\[ S(l) = \\frac{1}{2l + 1} \\sum_{m=-l}^l \\left\\vert n_l^m \\right\\vert^2 , \\] which grows with time. In the animation above, the left-hand panel shows how the power spectrum evolves under lattice rotation (unconfined vertical compression) compared to the end-member case of a delta-function (dashed line). If the expansion series is truncated at \\(l=L\\) , then \\(l{\\gt}L\\) modes cannot evolve, and the truncated solution will reach an unphysical quasi-steady state. To prevent this, regularization must be introduced. Specfab uses Laplacian hyper diffusion ( \\(k>1\\) ) as regularization in \\(S^2\\) \\[ \\frac{\\mathrm{D} n_l^m}{\\mathrm{D} t} ={\\nu}[l(l+1)]^{k} n_l^m \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}}{\\mathrm{D} t} = {\\bf M_{\\mathrm{REG}}} \\cdot {\\bf s} , \\] that can be added to the fabric evolution operator \\({\\bf M}\\) as follows: M += sf.M_REG(nlm, D) This allows the growth of high wavenumber modes to be disproportionately damped (green line compared to red line in animation above). However, sf.M_REG() is currently only calibrated for \\(L = 4,6,8,20\\) \u2014 that is, optimal values of \\(\\nu\\) and \\(k\\) are only available for these truncations. Note As a rule-of-thumb, regularization affects the highest and next-highest modes \\(l{\\geq}L-2\\) and can therefore not be expected to evolve freely. This, in turn, means that structure tensors a2 and a4 , and hence calculated enhancement factors , will be affected by regularization unless \\(L{\\geq}8\\) is chosen. Validation If the CPO is rotated into an approximatly rotationally-symmetric frame about the \\(z\\) -axis, then only \\(n_l^0\\) components are nonzero. This conviniently allows validating modelled CPO processes by comparing modelled to observed correlations between, e.g., the lowest-order normalized components \\(\\hat{n}_2^0 \\equiv n_2^0/n_0^0\\) and \\(\\hat{n}_4^0 \\equiv n_4^0/n_0^0\\) . The below plot shows the observed correlation structure (markers) compared to the above CPO model(s) for different modes of deformation, suggesting that modelled CPO processes capture observations reasonably well.","title":"Transversely isotropic grains"},{"location":"cpo-dynamics-tranisotropic/#cpo-dynamics-transversely-isotropic-grains","text":"","title":"CPO dynamics &mdash; Transversely isotropic grains"},{"location":"cpo-dynamics-tranisotropic/#introduction","text":"This tutorial focuses on modelling the CPO evolution of polycrystalline glacier ice, understood as the \\({\\bf c}\\) -axis distribution or, equivelently, the distribution of (easy) slip-plane normals of grains, \\(n(\\theta,\\phi)\\) . Polycrystal Slip system Note \\(n(\\theta,\\phi)\\) may also be understood as the mass density fraction of grains with a given slip-plane normal orientation. See CPO representation for details.","title":"Introduction"},{"location":"cpo-dynamics-tranisotropic/#lagrangian-material-parcel","text":"The tutorial shows how to model the CPO evolution of a Lagrangian material parcel subject to three different modes of deformation/stress:","title":"Lagrangian material parcel"},{"location":"cpo-dynamics-tranisotropic/#notation","text":"Given the expansion \\[ n({\\bf x},t,\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}n_{l}^{m}({\\bf x},t) Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip-plane normals)}, \\] CPO evolution can be written as a matrix problem involving the state vector \\[ {\\bf s} = [n_0^0,n_2^{-2},n_2^{-1},n_2^{0},n_2^{1},n_2^{2},n_4^{-4},\\cdots,n_4^{4},\\cdots,n_L^{-L},\\cdots,n_L^{L}]^{\\mathrm{T}} \\quad\\text{(state vector)}, \\] such that \\[ \\frac{\\mathrm{D}{\\bf s}}{\\mathrm{D} t} = {\\bf M} \\cdot {\\bf s} \\quad\\text{(state evolution)}, \\] where the operator (matrix) \\({\\bf M}\\) represents the effect of a given CPO process, which may depend on stress, strain-rate, temperature, etc. The total effect of multiple processes acting simultaneously is simply \\[ {\\bf M} = {\\bf M_{\\mathrm{LROT}}} + {\\bf M_{\\mathrm{DDRX}}} + {\\bf M_{\\mathrm{CDRX}}} + \\cdots \\quad\\text{(operator)}. \\]","title":"Notation"},{"location":"cpo-dynamics-tranisotropic/#lattice-rotation","text":"The strain-induced rotation of \\(c\\) -axes is modelled given the (local) velocity gradient tensor \\(\\nabla {\\bf u}\\) ( Svendsen and Hutter, 1996 ). The model is a kinematic model in the sense that \\(c\\) -axes rotate in response to the bulk rate of stretching, \\({\\bf D}\\) , and spin, \\({\\bf W}\\) , thereby allowing the detailed microscopic stress and strain rate fields to be neglected and hence interactions between neighboring grains to be disregarded. The modelled \\(c\\) -axes are taken to rotate with the bulk continuum spin ( \\({\\bf W}\\) ), plus some plastic spin correction ( \\({\\bf W}_{\\mathrm{p}}\\) ), so that the \\(c\\) -axis velocity field on the unit sphere is \\[ {\\bf \\dot{c}} = ({\\bf W} + {\\bf W}_{\\mathrm{p}}) \\cdot {\\bf c} \\quad\\text{($c$-axis velocity field)} , \\] where the plastic spin generally depends on \\({\\bf D}\\) to lowest and second lowest order as (Wang, 1969; Aravas, 1994 ) \\[ {\\bf W}_{\\mathrm{p}} = \\iota({\\bf c}\\otimes{\\bf c}\\cdot{\\bf D} - {\\bf D}\\cdot{\\bf c}\\otimes{\\bf c}) + \\zeta({\\bf c}\\otimes{\\bf c}\\cdot{\\bf D}^2 - {\\bf D}^2\\cdot{\\bf c}\\otimes{\\bf c}) . \\] By requiring that basal planes preserve their orientation when subject to simple shear (like a deck of cards), it can be shown that \\(\\iota=1\\) and \\(\\zeta=0\\) . The corresponding effect on the continuous \\(c\\) -axis distribution is modelled as a conservative advection process on the surface of the unit sphere: \\[ \\frac{\\mathrm{D} n}{\\mathrm{D} t} = -\\nabla_{S^2}\\cdot(n{\\bf \\dot{c}}) \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}}{\\mathrm{D} t} = {\\bf M_{\\mathrm{LROT}}} \\cdot {\\bf s}, \\] where \\({\\bf M_{\\mathrm{LROT}}}\\) is given analytically in Rathmann et al. (2021) . c-axis velocity field The normalized \\(c\\) -axis velocity fields for the three modes of deformation considered are:","title":"Lattice rotation"},{"location":"cpo-dynamics-tranisotropic/#example","text":"import numpy as np from specfabpy import specfabpy as sf # L=6 truncation is sufficient in this case, but larger L allows a very strong fabric to develop # and minimizes the effect that regularization has on low wavenumber modes (l=2,4) lm, nlm_len = sf.init(8) ### Velocity gradient tensor experienced by parcel ugrad = np.diag([0.5, 0.5, -1.0]) # Unconfined compression along z-direction (equal extension in x and y) D = (ugrad+np.transpose(ugrad))/2 # Symmetric part (strain-rate tensor) W = (ugrad-np.transpose(ugrad))/2 # Anti-symmetric part (spin tensor) ### Numerics Nt = 25 # Number of time steps dt = 0.05 # Time-step size ### Initialize fabric as isotropic nlm = np.zeros((Nt,nlm_len), dtype=np.complex64) # State vector (array of expansion coefficients) nlm[0,0] = 1/np.sqrt(4*np.pi) # Normalized ODF at t=0 ### Euler integration of lattice rotation + regularization for tt in np.arange(1,Nt): nlm_prev = nlm[tt-1,:] # Previous solution iota, zeta = 1, 0 # \"Deck of cards\" behavior M_LROT = sf.M_LROT(nlm_prev, D, W, iota, zeta) # Lattice rotation operator (nlm_len x nlm_len matrix) M_REG = sf.M_REG(nlm_prev, D) # Regularization operator (nlm_len x nlm_len matrix) M = M_LROT + M_REG nlm[tt,:] = nlm_prev + dt*np.matmul(M, nlm_prev) # Euler step nlm[tt,:] = sf.apply_bounds(nlm[tt,:]) # Apply spectral bounds if needed # To plot the resulting ODF or calculate structure tensors, see CPO representation pages. See also demo code in repository .","title":"Example"},{"location":"cpo-dynamics-tranisotropic/#discontinous-dynamic-recrystallization-ddrx","text":"DDRX is modelled as a grain orientation or mass decay/production process on the unit sphere ( Placidi and others, 2010 ): \\[ \\frac{\\mathrm{D} n}{\\mathrm{D} t} = \\Gamma n \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}}{\\mathrm{D} t} = {\\bf M_{\\mathrm{DDRX}}} \\cdot {\\bf s} , \\] where the decay/production rate \\[\\Gamma = \\Gamma_0\\left(D- {\\langle} D {\\rangle}\\right) \\quad\\text{(decay/production rate)}\\] depends on the rate magnitude \\(\\Gamma_0\\) , and the deformability \\(D\\) as a function of the stress tensor \\({\\bf S}\\) : \\[ D = \\frac{({\\bf S}\\cdot{\\bf S}):({\\bf c}\\otimes{\\bf c}) - {\\bf S}:({\\bf c}\\otimes{\\bf c}\\otimes{\\bf c}\\otimes{\\bf c}):{\\bf S}}{{\\bf S}:{\\bf S}}\\quad\\text{(deformability)} . \\] \\({\\bf M_{\\mathrm{DDRX}}}\\) is given analytically in Rathmann and Lilien (2021) . Note The average deformability, \\(\\langle D\\rangle\\) , depends on the instantaneous CPO state \u2014 specifically, the structure tensors a2 and a4 \u2014 making the corresponding matrix problem nonlinear by conserving the total number of grain orientations or mass density depending on how normalization is interpreted , the latter arguably resting on stronger physical grounds. Decay/production rate The normalized DDRX decay/production rate \\(\\Gamma/\\Gamma_0 = D - \\langle D \\rangle\\) is an orientation dependent field that favors nucleation (orientation/mass production) in the directions where the resolved basal-plane shear stress is maximal, and orientation/mass decay elsewhere. The the normalized decay rate for the three modes of deformation considered are:","title":"Discontinous dynamic recrystallization (DDRX)"},{"location":"cpo-dynamics-tranisotropic/#example_1","text":"import numpy as np from specfabpy import specfabpy as sf # L=6 truncation is sufficient in this case, but larger L allows a very strong fabric to develop # and minimizes the effect that regularization has on low wavenumber modes (l=2,4) lm, nlm_len = sf.init(8) ### Stress tensor experienced by parcel S = np.diag([0.0, 1.0, -1.0]) # Confined compression along z-direction (extension confined to y-direction) #S = np.diag([0.5, 0.5, -1.0]) # Unconfined compression along z-direction Gamma0 = 10 # DDRX decay-rate magnitude (may depend on temperature, strain-rate, and other factors, see e.g. Richards et al., 2021) ### Numerics Nt = 25 # Number of time steps dt = 0.05 # Time-step size ### Initialize fabric as isotropic nlm = np.zeros((Nt,nlm_len), dtype=np.complex64) # State vector (array of expansion coefficients) nlm[0,0] = 1/np.sqrt(4*np.pi) # Normalized ODF at t=0 ### Euler integration of DDRX for tt in np.arange(1,Nt): nlm_prev = nlm[tt-1,:] # Previous solution M = Gamma0 * sf.M_DDRX(nlm_prev, S) # DDRX operator (nlm_len x nlm_len matrix) nlm[tt,:] = nlm_prev + dt*np.matmul(M, nlm_prev) # Complete Euler step nlm[tt,:] = sf.apply_bounds(nlm[tt,:]) # Apply spectral bounds if needed # To plot the resulting ODF or calculate structure tensors, see CPO representation pages.","title":"Example"},{"location":"cpo-dynamics-tranisotropic/#continous-dynamic-recrystallization-cdrx","text":"Polygonization (rotation recrystallization, CDRX) accounts for the division of grains along internal sub-grain boundaries when exposed to bending stresses. In effect, CDRX reduces the average grain size upon grain division but does not necessarily change the CPO much ( Alley, 1992 ). The model follows G\u00f6dert (2003) by approximating the effect of CDRX on the distribution of grain orientations/mass as a Laplacian diffusive process on \\(S^2\\) : \\[ \\frac{\\mathrm{D} n}{\\mathrm{D} t} = \\Lambda\\nabla^2 n \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}}{\\mathrm{D} t} = {\\bf M_{\\mathrm{CDRX}}} \\cdot {\\bf s} . \\]","title":"Continous dynamic recrystallization (CDRX)"},{"location":"cpo-dynamics-tranisotropic/#example_2","text":"To model CDRX, add the following contribution to the total fabric operator \\({\\bf M}\\) : M += Lambda*sf.M_CDRX(nlm) where Lambda is the CDRX rate-factor magnitude, \\(\\Lambda\\) , that possibly depends on temperature, stress, strain-rate, etc. ( Richards et al., 2021 ).","title":"Example"},{"location":"cpo-dynamics-tranisotropic/#regularization","text":"As \\(n(\\theta,\\phi)\\) becomes anisotropic due to CPO processes, the coefficients \\(n_l^m\\) associated with high wavenumber modes (large \\(l\\) and \\(m\\) , and thus small-scale structure) must increase in magnitude relative to the low wavenumber coefficients (small \\(l\\) and \\(m\\) ). One way to visualize this is by the angular power spectrum \\[ S(l) = \\frac{1}{2l + 1} \\sum_{m=-l}^l \\left\\vert n_l^m \\right\\vert^2 , \\] which grows with time. In the animation above, the left-hand panel shows how the power spectrum evolves under lattice rotation (unconfined vertical compression) compared to the end-member case of a delta-function (dashed line). If the expansion series is truncated at \\(l=L\\) , then \\(l{\\gt}L\\) modes cannot evolve, and the truncated solution will reach an unphysical quasi-steady state. To prevent this, regularization must be introduced. Specfab uses Laplacian hyper diffusion ( \\(k>1\\) ) as regularization in \\(S^2\\) \\[ \\frac{\\mathrm{D} n_l^m}{\\mathrm{D} t} ={\\nu}[l(l+1)]^{k} n_l^m \\quad\\Longrightarrow\\quad \\frac{\\mathrm{D} {\\bf s}}{\\mathrm{D} t} = {\\bf M_{\\mathrm{REG}}} \\cdot {\\bf s} , \\] that can be added to the fabric evolution operator \\({\\bf M}\\) as follows: M += sf.M_REG(nlm, D) This allows the growth of high wavenumber modes to be disproportionately damped (green line compared to red line in animation above). However, sf.M_REG() is currently only calibrated for \\(L = 4,6,8,20\\) \u2014 that is, optimal values of \\(\\nu\\) and \\(k\\) are only available for these truncations. Note As a rule-of-thumb, regularization affects the highest and next-highest modes \\(l{\\geq}L-2\\) and can therefore not be expected to evolve freely. This, in turn, means that structure tensors a2 and a4 , and hence calculated enhancement factors , will be affected by regularization unless \\(L{\\geq}8\\) is chosen.","title":"Regularization"},{"location":"cpo-dynamics-tranisotropic/#validation","text":"If the CPO is rotated into an approximatly rotationally-symmetric frame about the \\(z\\) -axis, then only \\(n_l^0\\) components are nonzero. This conviniently allows validating modelled CPO processes by comparing modelled to observed correlations between, e.g., the lowest-order normalized components \\(\\hat{n}_2^0 \\equiv n_2^0/n_0^0\\) and \\(\\hat{n}_4^0 \\equiv n_4^0/n_0^0\\) . The below plot shows the observed correlation structure (markers) compared to the above CPO model(s) for different modes of deformation, suggesting that modelled CPO processes capture observations reasonably well.","title":"Validation"},{"location":"cpo-plot/","text":"Plotting The orientation distribution function (ODF; normalized expansion series) can be plotted as follows: import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(4) # L=4 truncation is sufficient in this case import scipy.special as sp import matplotlib.pyplot as plt import matplotlib.ticker as mticker import cmasher as cmr import cartopy.crs as ccrs def plot_ODF(nlm, lm, ax, geo, cmap='Greys', cblabel='$n/N$ (ODF)', lvls=np.linspace(0.0,0.4,9), tickintvl=4, latres=60, plotAxes=False): # Discretize over S^2 theta = np.linspace(0, np.pi, latres) # co-lat phi = np.linspace(0, 2*np.pi, 2*latres) # lon phi, theta = np.meshgrid(phi, theta) # gridded lon, colat = phi, theta lat = np.pi/2-colat _,nlm_len = lm.shape F = np.real(np.sum([ nlm[ii]*sp.sph_harm(lm[1][ii], lm[0][ii], phi,theta) for ii in np.arange(nlm_len) ], axis=0)) F[F<0] = 0 # hide numerical/truncation errors # Plot cmap = cmr.get_sub_cmap(cmap, 0.05, 1) # don't include pure white for visibility h = ax.contourf(np.rad2deg(lon), np.rad2deg(lat), F, transform=ccrs.PlateCarree(), levels=lvls, extend='max', cmap=cmap, nchunk=5) # \"nchunk\" argument must be larger than 0 for constant-ODF (isotropy) to be plotted correctly. # Add grid lines kwargs_gridlines = {'ylocs':np.arange(-90,90+30,30), 'xlocs':np.arange(0,360+45,45), 'linewidth':0.5, 'color':'black', 'alpha':0.25, 'linestyle':'-'} gl = ax.gridlines(crs=ccrs.PlateCarree(), **kwargs_gridlines) gl.xlocator = mticker.FixedLocator(np.array([-135, -90, -45, 0, 90, 45, 135, 180])) # Colorbar cb = plt.colorbar(h, ax=ax, fraction=0.075, aspect=9, orientation='horizontal', pad=0.1, ticks=lvls[::tickintvl]) cb.set_label(cblabel) cb.ax.xaxis.set_ticks(lvls, minor=True) if plotAxes: ax.plot([0],[90], marker=r'$z$', ms=9, c='tab:red', transform=geo) # z axis ax.plot([90],[0], marker=r'$y$', ms=9, c='tab:blue', transform=geo) # y axis ax.plot([0],[0], marker=r'$x$', ms=9, c='tab:green', transform=geo) # x axis return h, cb ### Plot ODF # Make synthetic ODF a2 = np.diag([0.0,0.5,0.5]) # an arbitrary a2 nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients nlm[:6] = sf.a2_to_nlm(a2) # a2 contains information about the lowest-order harmonics l=2 only # Setup figure fig = plt.figure(figsize=(3,4)) inclination, rot = 45, +45 # view angle prj, geo = ccrs.Orthographic(rot, 90-inclination), ccrs.Geodetic() ax = plt.subplot(projection=prj) ax.set_global() # show entire S^2 # Plot h, cb = plot_ODF(nlm, lm, ax, geo, plotAxes=True) fig.tight_layout() plt.show()","title":"Plotting"},{"location":"cpo-plot/#plotting","text":"The orientation distribution function (ODF; normalized expansion series) can be plotted as follows: import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(4) # L=4 truncation is sufficient in this case import scipy.special as sp import matplotlib.pyplot as plt import matplotlib.ticker as mticker import cmasher as cmr import cartopy.crs as ccrs def plot_ODF(nlm, lm, ax, geo, cmap='Greys', cblabel='$n/N$ (ODF)', lvls=np.linspace(0.0,0.4,9), tickintvl=4, latres=60, plotAxes=False): # Discretize over S^2 theta = np.linspace(0, np.pi, latres) # co-lat phi = np.linspace(0, 2*np.pi, 2*latres) # lon phi, theta = np.meshgrid(phi, theta) # gridded lon, colat = phi, theta lat = np.pi/2-colat _,nlm_len = lm.shape F = np.real(np.sum([ nlm[ii]*sp.sph_harm(lm[1][ii], lm[0][ii], phi,theta) for ii in np.arange(nlm_len) ], axis=0)) F[F<0] = 0 # hide numerical/truncation errors # Plot cmap = cmr.get_sub_cmap(cmap, 0.05, 1) # don't include pure white for visibility h = ax.contourf(np.rad2deg(lon), np.rad2deg(lat), F, transform=ccrs.PlateCarree(), levels=lvls, extend='max', cmap=cmap, nchunk=5) # \"nchunk\" argument must be larger than 0 for constant-ODF (isotropy) to be plotted correctly. # Add grid lines kwargs_gridlines = {'ylocs':np.arange(-90,90+30,30), 'xlocs':np.arange(0,360+45,45), 'linewidth':0.5, 'color':'black', 'alpha':0.25, 'linestyle':'-'} gl = ax.gridlines(crs=ccrs.PlateCarree(), **kwargs_gridlines) gl.xlocator = mticker.FixedLocator(np.array([-135, -90, -45, 0, 90, 45, 135, 180])) # Colorbar cb = plt.colorbar(h, ax=ax, fraction=0.075, aspect=9, orientation='horizontal', pad=0.1, ticks=lvls[::tickintvl]) cb.set_label(cblabel) cb.ax.xaxis.set_ticks(lvls, minor=True) if plotAxes: ax.plot([0],[90], marker=r'$z$', ms=9, c='tab:red', transform=geo) # z axis ax.plot([90],[0], marker=r'$y$', ms=9, c='tab:blue', transform=geo) # y axis ax.plot([0],[0], marker=r'$x$', ms=9, c='tab:green', transform=geo) # x axis return h, cb ### Plot ODF # Make synthetic ODF a2 = np.diag([0.0,0.5,0.5]) # an arbitrary a2 nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients nlm[:6] = sf.a2_to_nlm(a2) # a2 contains information about the lowest-order harmonics l=2 only # Setup figure fig = plt.figure(figsize=(3,4)) inclination, rot = 45, +45 # view angle prj, geo = ccrs.Orthographic(rot, 90-inclination), ccrs.Geodetic() ax = plt.subplot(projection=prj) ax.set_global() # show entire S^2 # Plot h, cb = plot_ODF(nlm, lm, ax, geo, plotAxes=True) fig.tight_layout() plt.show()","title":"Plotting"},{"location":"cpo-representation/","text":"CPO representation Definition CPOs are represented by the distribution(s) of crystallographic axes in orientation space, \\(S^2\\) . Supported grain symmetry groups for modelling CPO evolution are Grain symmetry CPO components Interpretation Transversely isotropic \\(n(\\theta,\\phi)\\) Distribution of slip-plane normals Orthotropic \\(n(\\theta,\\phi),b(\\theta,\\phi)\\) Distribution of slip-plane normals and slip directions Note Grain sizes or shapes are not modelled by specfab. Example Polycrystalline ice Polycrystalline olivine \\(n(\\theta,\\phi)\\) is the \\({\\bf c}\\) -axis distribution \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) are the distributions of particular crystallographic axes ( \\({\\bf m}'_i\\) ) depending on fabric type (A\u2014E type). Series expansion CPOs are represented by expanding their distributions of crystallographic axes in terms of spherical harmonic expansion series. E.g. for transversely isotropic grains where only \\(n(\\theta,\\phi)\\) is relevant: $$ n(\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}n_{l}^{m}Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip-plane normals)}. $$ The orientation distribution function (ODF) is defined as the normalized distribution \\[ \\mathrm{ODF} = \\frac{n(\\theta,\\phi)}{N} \\quad\\text{where}\\quad N=\\int_{S^2}{n} d\\Omega=\\sqrt{4\\pi}n_0^0 . \\] The array of complex-valued expansion coefficients, defining the CPO state, is \\[ {\\bf s} = [n_0^0,n_2^{-2},n_2^{-1},n_2^{0},n_2^{1},n_2^{2},n_4^{-4},\\cdots,n_4^{4},\\cdots,n_L^{-L},\\cdots,n_L^{L}] \\quad\\text{(state vector)}. \\] $$ $$ Normalization \\(n(\\theta,\\phi)\\) may be understood either as the number density of grains with a given slip-plane normal orientation, or as the mass density fraction ( Faria, 2006 ; Richards et al., 2021 ) of grains with a given slip-plane normal orientation. From specfab's point-of-view, the difference is a matter of normalization: since the models of CPO evolution (lattice rotation, DDRX, CDRX) conserve the normalization, the two views are effectively the same, not least because CPO-derived quantities depend on the normalized distributions (which are identical). The mass-density-fraction interpretation rests, however, on stronger physical grounds as mass is conserved but grain numbers are not. Reduced form Not all expansion coefficients are independent for real-valued expansion series, but must fulfill \\[ n_l^{-m}=(-1)^m(n_l^m)^* . \\] This can be taken advantage of for large problems where many (e.g. gridded) CPOs need to be stored in memory, thereby effectively reducing the size of the problem. The array of reduced expansion coefficients is defined as \\(\\qquad\\) rnlm \\(= [n_0^0,n_2^{0},n_2^{1},n_2^{2},n_4^{0},\\cdots,n_4^{4},\\cdots,n_L^{0},\\cdots,n_L^{L}] \\quad\\text{(reduced state vector)}\\) Example Converting between full and reduced forms: import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(2) # L=2 truncation is sufficient in this case # Construct an arbitrary fabric a2 = np.diag([0.1,0.2,0.7]) # any second-order structure tensor (not necessarily diagonal) nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients nlm[0:6] = sf.a2_to_nlm(a2) # l=2 expansion coefficients for corresponding ODF (a2 is normalized) print('original:', nlm) # Get reduced form of coefficient array, rnlm rnlm_len = sf.get_rnlm_len() rnlm = np.zeros((rnlm_len), dtype=np.complex64) # array of reduced expansion coefficients rnlm[:] = sf.nlm_to_rnlm(nlm, rnlm_len) # reduced form print('reduced:', rnlm) # Recover full form (nlm) from reduced form (rnlm) nlm[:] = sf.rnlm_to_nlm(rnlm, nlm_len) print('recovered:', nlm)","title":"Representation"},{"location":"cpo-representation/#cpo-representation","text":"","title":"CPO representation"},{"location":"cpo-representation/#definition","text":"CPOs are represented by the distribution(s) of crystallographic axes in orientation space, \\(S^2\\) . Supported grain symmetry groups for modelling CPO evolution are Grain symmetry CPO components Interpretation Transversely isotropic \\(n(\\theta,\\phi)\\) Distribution of slip-plane normals Orthotropic \\(n(\\theta,\\phi),b(\\theta,\\phi)\\) Distribution of slip-plane normals and slip directions Note Grain sizes or shapes are not modelled by specfab.","title":"Definition"},{"location":"cpo-representation/#example","text":"Polycrystalline ice Polycrystalline olivine \\(n(\\theta,\\phi)\\) is the \\({\\bf c}\\) -axis distribution \\(n(\\theta,\\phi)\\) and \\(b(\\theta,\\phi)\\) are the distributions of particular crystallographic axes ( \\({\\bf m}'_i\\) ) depending on fabric type (A\u2014E type).","title":"Example"},{"location":"cpo-representation/#series-expansion","text":"CPOs are represented by expanding their distributions of crystallographic axes in terms of spherical harmonic expansion series. E.g. for transversely isotropic grains where only \\(n(\\theta,\\phi)\\) is relevant: $$ n(\\theta,\\phi)=\\sum_{l=0}^{L}\\sum_{m=-l}^{l}n_{l}^{m}Y_{l}^{m}(\\theta,\\phi) \\quad\\text{(distribution of slip-plane normals)}. $$ The orientation distribution function (ODF) is defined as the normalized distribution \\[ \\mathrm{ODF} = \\frac{n(\\theta,\\phi)}{N} \\quad\\text{where}\\quad N=\\int_{S^2}{n} d\\Omega=\\sqrt{4\\pi}n_0^0 . \\] The array of complex-valued expansion coefficients, defining the CPO state, is \\[ {\\bf s} = [n_0^0,n_2^{-2},n_2^{-1},n_2^{0},n_2^{1},n_2^{2},n_4^{-4},\\cdots,n_4^{4},\\cdots,n_L^{-L},\\cdots,n_L^{L}] \\quad\\text{(state vector)}. \\] $$ $$ Normalization \\(n(\\theta,\\phi)\\) may be understood either as the number density of grains with a given slip-plane normal orientation, or as the mass density fraction ( Faria, 2006 ; Richards et al., 2021 ) of grains with a given slip-plane normal orientation. From specfab's point-of-view, the difference is a matter of normalization: since the models of CPO evolution (lattice rotation, DDRX, CDRX) conserve the normalization, the two views are effectively the same, not least because CPO-derived quantities depend on the normalized distributions (which are identical). The mass-density-fraction interpretation rests, however, on stronger physical grounds as mass is conserved but grain numbers are not.","title":"Series expansion"},{"location":"cpo-representation/#reduced-form","text":"Not all expansion coefficients are independent for real-valued expansion series, but must fulfill \\[ n_l^{-m}=(-1)^m(n_l^m)^* . \\] This can be taken advantage of for large problems where many (e.g. gridded) CPOs need to be stored in memory, thereby effectively reducing the size of the problem. The array of reduced expansion coefficients is defined as \\(\\qquad\\) rnlm \\(= [n_0^0,n_2^{0},n_2^{1},n_2^{2},n_4^{0},\\cdots,n_4^{4},\\cdots,n_L^{0},\\cdots,n_L^{L}] \\quad\\text{(reduced state vector)}\\)","title":"Reduced form"},{"location":"cpo-representation/#example_1","text":"Converting between full and reduced forms: import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(2) # L=2 truncation is sufficient in this case # Construct an arbitrary fabric a2 = np.diag([0.1,0.2,0.7]) # any second-order structure tensor (not necessarily diagonal) nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients nlm[0:6] = sf.a2_to_nlm(a2) # l=2 expansion coefficients for corresponding ODF (a2 is normalized) print('original:', nlm) # Get reduced form of coefficient array, rnlm rnlm_len = sf.get_rnlm_len() rnlm = np.zeros((rnlm_len), dtype=np.complex64) # array of reduced expansion coefficients rnlm[:] = sf.nlm_to_rnlm(nlm, rnlm_len) # reduced form print('reduced:', rnlm) # Recover full form (nlm) from reduced form (rnlm) nlm[:] = sf.rnlm_to_nlm(rnlm, nlm_len) print('recovered:', nlm)","title":"Example"},{"location":"cpo-rotation/","text":"Rotation Rotating an expansion series by theta about the \\(y\\) -axis (in the \\(x\\) \u2014 \\(z\\) plane) followed by phi about the \\(z\\) -axis (in the \\(x\\) \u2014 \\(y\\) plane) is done by: import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(4) # Construct an arbitrary fabric to rotate a2 = np.diag([0.0,0.0,1.0]) # any second-order structure tensor (not necessarily diagonal) nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients nlm[0:6] = sf.a2_to_nlm(a2) # l=2 expansion coefficients of corresponding ODF (normalized) # Rotate ODF # Assumes L=<12 - rotation for larger L is *not* implemented theta = np.deg2rad(-45) phi = np.deg2rad(45) nlm_rot1 = sf.rotate_nlm(nlm, theta, 0) # first rotate around y axis in x-z plane nlm_rot2 = sf.rotate_nlm(nlm_rot1, 0, phi) # next rotate around z axis in x-y plane Plotting the expansion series ( nlm and nlm_rot* ) gives:","title":"Rotation"},{"location":"cpo-rotation/#rotation","text":"Rotating an expansion series by theta about the \\(y\\) -axis (in the \\(x\\) \u2014 \\(z\\) plane) followed by phi about the \\(z\\) -axis (in the \\(x\\) \u2014 \\(y\\) plane) is done by: import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(4) # Construct an arbitrary fabric to rotate a2 = np.diag([0.0,0.0,1.0]) # any second-order structure tensor (not necessarily diagonal) nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients nlm[0:6] = sf.a2_to_nlm(a2) # l=2 expansion coefficients of corresponding ODF (normalized) # Rotate ODF # Assumes L=<12 - rotation for larger L is *not* implemented theta = np.deg2rad(-45) phi = np.deg2rad(45) nlm_rot1 = sf.rotate_nlm(nlm, theta, 0) # first rotate around y axis in x-z plane nlm_rot2 = sf.rotate_nlm(nlm_rot1, 0, phi) # next rotate around z axis in x-y plane Plotting the expansion series ( nlm and nlm_rot* ) gives:","title":"Rotation"},{"location":"cpo-structuretensors/","text":"Structure tensors The 2nd-, 4th- and 6th-order structure tensors ( a2 , a4 , a6 ) are the average outer products (vector moments) of a crystallographic axis, e.g. \\({\\bf c}\\) : \\[ {\\bf a}^{(2)}=\\frac{1}{N}\\sum_i^N {\\bf c}\\otimes{\\bf c} ,\\quad {\\bf a}^{(4)}=\\frac{1}{N}\\sum_i^N ({\\bf c}\\otimes)^4 ,\\quad {\\bf a}^{(6)}=\\frac{1}{N}\\sum_i^N ({\\bf c}\\otimes)^6 , \\] where \\(N\\) is the total number of grains (here assuming equal grain weight/size/mass for simplicity). In terms of the distribution of \\({\\bf c}\\) axes, \\(n(\\theta,\\phi)\\) , the structure tensors are \\[ {\\bf a}^{(k)}=\\frac{1}{N} \\int_{S^2} ({\\bf c}\\otimes)^k n(\\theta,\\phi) \\, \\mathrm{d}\\Omega , \\] where \\(N=\\int_{S^2} n(\\theta,\\phi) \\, \\mathrm{d}\\Omega\\) and \\(\\mathrm{d}\\Omega = \\mathrm{d}\\theta \\mathrm{d}\\phi\\) is the infinitesimal solid angle. Converting between spectral and tensorial representations is a linear problem in the sense that \\[ {\\bf a}^{(2)} = {\\bf f}(\\hat{n}_2^{m}) ,\\quad {\\bf a}^{(4)} = {\\bf g}(\\hat{n}_0^0, \\hat{n}_2^{m}, \\hat{n}_4^{m}) ,\\quad {\\bf a}^{(6)} = {\\bf h}(\\hat{n}_2^{m}, \\hat{n}_4^{m}, \\hat{n}_6^{m}) , \\qquad\\text{(for all $m$)} \\] where \\({\\bf f}\\) , \\({\\bf g}\\) , \\({\\bf h}\\) are linear in their arguments, and \\[ \\hat{n}_l^m \\equiv n_l^m/n_0^0 . \\] Example The following example shows how to convert between the representations: import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(6) # L=6 truncation is sufficient in this case nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients ### a2 to nlm a2 = np.diag([0.0,0.25,0.75]) # any second-order structure tensor (not necessarily diagonal) nlm[:6] = sf.a2_to_nlm(a2) # Determine l=2 expansion coefficients of ODF (a2 is normalized) a2 = sf.a2(nlm) # nlm back to a2 print('a2 is: ', a2) ### a4 to nlm p = np.array([0,0,1]) # unidirectional fabric where all c-axes are aligned with the z-direction a4 = np.einsum('i,j,k,l', p,p,p,p) # a4 for ODF = deltafunc(r-p) nlm[:15] = sf.a4_to_nlm(a4) # Determine l=2,4 expansion coefficients of ODF (a4 is normalized) a4 = sf.a4(nlm) # nlm back to a4 print('a4 is: ', a4) ### a6 to nlm p = np.array([0,0,1]) # unidirectional fabric where all c-axes are aligned with the z-direction a6 = np.einsum('i,j,k,l,m,n', p,p,p,p,p,p) # a6 for ODF = deltafunc(r-p) nlm[:] = sf.a6_to_nlm(a6) # Determine l=2,4,6 expansion coefficients of ODF (a6 is normalized) a6 = sf.a6(nlm) # nlm back to a6 print('a6 is: ', a6) Constructing CPOs from measurements The spectral expansion coefficients of any CPO may be determined from discrete measurements of crystallographic axes. This requires constructing the corresponding structure tensors (for each crystallographic axis), from which the expansion coefficients may be derived. Example import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(6) # Replace with your own array/list of measured c-axes # caxes = [[c1x,c1y,c1z], [c2x,c2y,c2z], ...] # Determine sixth-order structure tensor, a6 a6 = np.zeros((3,3,3,3,3,3)) for c in caxes a6 += np.einsum('i,j,k,l,m,n', c,c,c,c,c,c) # sixth outer product of c with itself a6 /= len(caxes) # normalize by number of c-axes (grains) # Determine spectral expansion coefficients nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients nlm[:] = sf.a6_to_nlm(a6) # Determine l=2,4,6 expansion coefficients of ODF (a6 is normalized) Note Constructing a6 is to be preferred over a4 and a2 since it contains more information on the fine-scale structure of the distribution; that is, \\(l\\leq 6\\) expansion coefficients as opposed to \\(l\\leq 4\\) and \\(l\\leq 2\\) coefficients, respectively.","title":"Structure tensors"},{"location":"cpo-structuretensors/#structure-tensors","text":"The 2nd-, 4th- and 6th-order structure tensors ( a2 , a4 , a6 ) are the average outer products (vector moments) of a crystallographic axis, e.g. \\({\\bf c}\\) : \\[ {\\bf a}^{(2)}=\\frac{1}{N}\\sum_i^N {\\bf c}\\otimes{\\bf c} ,\\quad {\\bf a}^{(4)}=\\frac{1}{N}\\sum_i^N ({\\bf c}\\otimes)^4 ,\\quad {\\bf a}^{(6)}=\\frac{1}{N}\\sum_i^N ({\\bf c}\\otimes)^6 , \\] where \\(N\\) is the total number of grains (here assuming equal grain weight/size/mass for simplicity). In terms of the distribution of \\({\\bf c}\\) axes, \\(n(\\theta,\\phi)\\) , the structure tensors are \\[ {\\bf a}^{(k)}=\\frac{1}{N} \\int_{S^2} ({\\bf c}\\otimes)^k n(\\theta,\\phi) \\, \\mathrm{d}\\Omega , \\] where \\(N=\\int_{S^2} n(\\theta,\\phi) \\, \\mathrm{d}\\Omega\\) and \\(\\mathrm{d}\\Omega = \\mathrm{d}\\theta \\mathrm{d}\\phi\\) is the infinitesimal solid angle. Converting between spectral and tensorial representations is a linear problem in the sense that \\[ {\\bf a}^{(2)} = {\\bf f}(\\hat{n}_2^{m}) ,\\quad {\\bf a}^{(4)} = {\\bf g}(\\hat{n}_0^0, \\hat{n}_2^{m}, \\hat{n}_4^{m}) ,\\quad {\\bf a}^{(6)} = {\\bf h}(\\hat{n}_2^{m}, \\hat{n}_4^{m}, \\hat{n}_6^{m}) , \\qquad\\text{(for all $m$)} \\] where \\({\\bf f}\\) , \\({\\bf g}\\) , \\({\\bf h}\\) are linear in their arguments, and \\[ \\hat{n}_l^m \\equiv n_l^m/n_0^0 . \\]","title":"Structure tensors"},{"location":"cpo-structuretensors/#example","text":"The following example shows how to convert between the representations: import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(6) # L=6 truncation is sufficient in this case nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients ### a2 to nlm a2 = np.diag([0.0,0.25,0.75]) # any second-order structure tensor (not necessarily diagonal) nlm[:6] = sf.a2_to_nlm(a2) # Determine l=2 expansion coefficients of ODF (a2 is normalized) a2 = sf.a2(nlm) # nlm back to a2 print('a2 is: ', a2) ### a4 to nlm p = np.array([0,0,1]) # unidirectional fabric where all c-axes are aligned with the z-direction a4 = np.einsum('i,j,k,l', p,p,p,p) # a4 for ODF = deltafunc(r-p) nlm[:15] = sf.a4_to_nlm(a4) # Determine l=2,4 expansion coefficients of ODF (a4 is normalized) a4 = sf.a4(nlm) # nlm back to a4 print('a4 is: ', a4) ### a6 to nlm p = np.array([0,0,1]) # unidirectional fabric where all c-axes are aligned with the z-direction a6 = np.einsum('i,j,k,l,m,n', p,p,p,p,p,p) # a6 for ODF = deltafunc(r-p) nlm[:] = sf.a6_to_nlm(a6) # Determine l=2,4,6 expansion coefficients of ODF (a6 is normalized) a6 = sf.a6(nlm) # nlm back to a6 print('a6 is: ', a6)","title":"Example"},{"location":"cpo-structuretensors/#constructing-cpos-from-measurements","text":"The spectral expansion coefficients of any CPO may be determined from discrete measurements of crystallographic axes. This requires constructing the corresponding structure tensors (for each crystallographic axis), from which the expansion coefficients may be derived.","title":"Constructing CPOs from measurements"},{"location":"cpo-structuretensors/#example_1","text":"import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(6) # Replace with your own array/list of measured c-axes # caxes = [[c1x,c1y,c1z], [c2x,c2y,c2z], ...] # Determine sixth-order structure tensor, a6 a6 = np.zeros((3,3,3,3,3,3)) for c in caxes a6 += np.einsum('i,j,k,l,m,n', c,c,c,c,c,c) # sixth outer product of c with itself a6 /= len(caxes) # normalize by number of c-axes (grains) # Determine spectral expansion coefficients nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients nlm[:] = sf.a6_to_nlm(a6) # Determine l=2,4,6 expansion coefficients of ODF (a6 is normalized) Note Constructing a6 is to be preferred over a4 and a2 since it contains more information on the fine-scale structure of the distribution; that is, \\(l\\leq 6\\) expansion coefficients as opposed to \\(l\\leq 4\\) and \\(l\\leq 2\\) coefficients, respectively.","title":"Example"},{"location":"enhancements-strainrate/","text":"Strain-rate enhancements Definition Given an anisotropic rheology \\({\\bf D}({\\bf S})\\) , where \\({\\bf D}\\) and \\({\\bf S}\\) are the strain-rate and deviatoric stress tensors, respectively, the directional strain-rate enhancement factors , \\(E_{ij}\\) , are defined as the \\(({\\bf e}_i, {\\bf e}_j)\\) -components of \\({\\bf D}\\) relative to that of the rheology in the isotropic limit (isotropic CPO): \\[ E_{ij} = \\frac{ {\\bf e}_i \\cdot {\\bf D}({\\bf S}({\\bf e}_i, {\\bf e}_j)) \\cdot {\\bf e}_j }{ {\\bf e}_i \\cdot {\\bf D}_{\\mathrm{iso}}({\\bf S}({\\bf e}_i, {\\bf e}_j)) \\cdot {\\bf e}_j } , \\qquad(1) \\] for a stress state aligned with \\(({\\bf e}_i, {\\bf e}_j)\\) : \\[ {\\bf S}({\\bf e}_i, {\\bf e}_j) = \\tau_0 \\begin{cases} {\\bf I}/3 - {\\bf e}_i \\otimes {\\bf e}_i \\;\\;\\quad\\quad\\text{if}\\quad i=j \\\\ {\\bf e}_i \\otimes {\\bf e}_j + {\\bf e}_j \\otimes {\\bf e}_i \\quad\\text{if}\\quad i\\neq j \\\\ \\end{cases} . \\] In this way: \\({E_{11}}\\) is the longitudinal strain-rate enhancement along \\({\\bf e}_{1}\\) when subject to compression along \\({\\bf e}_{1}\\) \\({E_{12}}\\) is the \\({\\bf e}_{1}\\) \u2014 \\({\\bf e}_{2}\\) shear strain-rate enhancement when subject to shear in the \\({\\bf e}_{1}\\) \u2014 \\({\\bf e}_{2}\\) plane and so on. Hard or soft \\(E_{ij}>1\\) implies the material response is softened due to fabric (compared to an isotropic CPO), whereas \\(E_{ij}<1\\) implies hardening . Eigenenhancements Eigenenhancements are defined as the enhancement factors w.r.t. the CPO symmetry axes ( \\({\\bf m}_i\\) ): \\[{\\bf e}_i = {\\bf m}_i .\\] These are the enhancements factors needed to specify the viscous anisotropy in bulk rheologies : Transversely isotropic Orthotropic Grain homogenization schemes Using (1) to calculate \\(E_{ij}\\) for a given CPO requires an effective rheology that takes the microstructure into account. In the simplest case, polycrystals may be regarded as an ensemble of interactionless grains (monocrystals) subject to either a homogeneous strain field (Taylor's hypothesis) or homogeneous stress field (Sachs's hypothesis) over the polycrystal scale. In this way, the effective rheology is simply the grain-orentation-averaged rheology, assuming homogeneous stress or strain-rate over the polycrystal scale. Any linear combination of the two homogenizations is supported: \\[ E_{ij} = (1-\\alpha)E_{ij}^{\\mathrm{Sachs}} + {\\alpha}E_{ij}^{\\mathrm{Taylor}} , \\] where \\(E_{ij}^{\\mathrm{Sachs}}\\) and \\(E_{ij}^{\\mathrm{Taylor}}\\) are calculated with (1) assuming constant \\(\\bf{S}\\) and \\(\\bf{D}\\) , respectively. Grain parameters The grain viscous parameters below should be understood as the effective polycrystal values needed to reproduce deformation experiments, and not measured values derived from experiments on single crystals. Transversely isotropic grains Monocrystal Polycrystal If grains are approximately transversely isotropic, the grain rheology can be modelled using the transversely isotropic power-law rheology . This requires specifying the grain eigenenhancements \\(E_{cc}'\\) and \\(E_{ca}'\\) , the power-law exponent \\(n'\\) , and the Taylor\u2014Sachs weight \\(\\alpha\\) . Example for glacier ice The below example for glacier ice shows how bulk \\(E_{ij}\\) may be calculated given a2 , a4 , or nlm . import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(4) # L=4 truncation is sufficient in this case ### Make synthetic ODF # Unidirectional CPO: all c-axes aligned in z-direction (ODF = deltafunc(r-m)) m = np.array([0,0,1]) nlm = np.zeros((nlm_len), dtype=np.complex64) # Array of expansion coefficients if True: # use a2 a2 = np.einsum('i,j', m,m) # Outer product nlm[:6] = sf.a2_to_nlm(a2) # Derive corresponding expansion coefficients else: # use a4 a4 = np.einsum('i,j,k,l', m,m,m,m) # Outer product nlm[:15] = sf.a4_to_nlm(a4) # Derive corresponding expansion coefficients ### Coordinate basis vectors for enhancement-factor calculations (e1,e2,e3, eigvals) = sf.frame(nlm, 'e') # a2 eigen basis #(e1,e2,e3) = (np.array([1,0,0]),np.array([0,1,0]),np.array([0,0,1])) # x,y,z cartesian basis ### Transversely isotropic monocrystal parameters for ice (Rathmann & Lilien, 2021) n_grain = 1 # Power-law exponent: n=1 => linear grain rheology, nonlinear (n>1) is unsupported. Eij_grain = (1, 1e3) # Grain eigenenhancements (Ecc,Eca) for compression along c-axis (Ecc) and for shear parallel to basal plane (Eca) alpha = 0.0125 # Taylor--Sachs weight ### Calculate enhancement factors w.r.t. e1, e2, e3 Eij = sf.Eij_tranisotropic(nlm, e1,e2,e3, Eij_grain,alpha,n_grain) # = (E11,E22,E33,E23,E13,E12) The below animation shows the directional enhancement factors for a CPO evolving under uniaxial compression along \\({\\hat {\\bf z}}\\) when subject to lattice rotation . Enhancement factors are calculated w.r.t. the spherical coordinate basis vectors \\({\\bf e}_1, {\\bf e}_2, {\\bf e}_3 = {\\hat{\\bf r}},{\\hat{\\boldsymbol \\theta}},{\\hat{\\boldsymbol \\phi}}\\) . Orthotropic grains Monocrystal Polycrystal If grains are approximately orthotropic, the grain rheology can be modelled using the orthotropic power-law rheology . This requires specifying the grain eigenenhancements ( \\(E_{11}'\\) , \\(E_{22}'\\) , \\(E_{33}'\\) , \\(E_{23}'\\) , \\(E_{13}'\\) , \\(E_{12}'\\) ), the power-law exponent \\(n'\\) , and the Taylor\u2014Sachs weight \\(\\alpha\\) . Example for olivine Not yet available.","title":"Strain-rate enhancements"},{"location":"enhancements-strainrate/#strain-rate-enhancements","text":"","title":"Strain-rate enhancements"},{"location":"enhancements-strainrate/#definition","text":"Given an anisotropic rheology \\({\\bf D}({\\bf S})\\) , where \\({\\bf D}\\) and \\({\\bf S}\\) are the strain-rate and deviatoric stress tensors, respectively, the directional strain-rate enhancement factors , \\(E_{ij}\\) , are defined as the \\(({\\bf e}_i, {\\bf e}_j)\\) -components of \\({\\bf D}\\) relative to that of the rheology in the isotropic limit (isotropic CPO): \\[ E_{ij} = \\frac{ {\\bf e}_i \\cdot {\\bf D}({\\bf S}({\\bf e}_i, {\\bf e}_j)) \\cdot {\\bf e}_j }{ {\\bf e}_i \\cdot {\\bf D}_{\\mathrm{iso}}({\\bf S}({\\bf e}_i, {\\bf e}_j)) \\cdot {\\bf e}_j } , \\qquad(1) \\] for a stress state aligned with \\(({\\bf e}_i, {\\bf e}_j)\\) : \\[ {\\bf S}({\\bf e}_i, {\\bf e}_j) = \\tau_0 \\begin{cases} {\\bf I}/3 - {\\bf e}_i \\otimes {\\bf e}_i \\;\\;\\quad\\quad\\text{if}\\quad i=j \\\\ {\\bf e}_i \\otimes {\\bf e}_j + {\\bf e}_j \\otimes {\\bf e}_i \\quad\\text{if}\\quad i\\neq j \\\\ \\end{cases} . \\] In this way: \\({E_{11}}\\) is the longitudinal strain-rate enhancement along \\({\\bf e}_{1}\\) when subject to compression along \\({\\bf e}_{1}\\) \\({E_{12}}\\) is the \\({\\bf e}_{1}\\) \u2014 \\({\\bf e}_{2}\\) shear strain-rate enhancement when subject to shear in the \\({\\bf e}_{1}\\) \u2014 \\({\\bf e}_{2}\\) plane and so on. Hard or soft \\(E_{ij}>1\\) implies the material response is softened due to fabric (compared to an isotropic CPO), whereas \\(E_{ij}<1\\) implies hardening .","title":"Definition"},{"location":"enhancements-strainrate/#eigenenhancements","text":"Eigenenhancements are defined as the enhancement factors w.r.t. the CPO symmetry axes ( \\({\\bf m}_i\\) ): \\[{\\bf e}_i = {\\bf m}_i .\\] These are the enhancements factors needed to specify the viscous anisotropy in bulk rheologies : Transversely isotropic Orthotropic","title":"Eigenenhancements"},{"location":"enhancements-strainrate/#grain-homogenization-schemes","text":"Using (1) to calculate \\(E_{ij}\\) for a given CPO requires an effective rheology that takes the microstructure into account. In the simplest case, polycrystals may be regarded as an ensemble of interactionless grains (monocrystals) subject to either a homogeneous strain field (Taylor's hypothesis) or homogeneous stress field (Sachs's hypothesis) over the polycrystal scale. In this way, the effective rheology is simply the grain-orentation-averaged rheology, assuming homogeneous stress or strain-rate over the polycrystal scale. Any linear combination of the two homogenizations is supported: \\[ E_{ij} = (1-\\alpha)E_{ij}^{\\mathrm{Sachs}} + {\\alpha}E_{ij}^{\\mathrm{Taylor}} , \\] where \\(E_{ij}^{\\mathrm{Sachs}}\\) and \\(E_{ij}^{\\mathrm{Taylor}}\\) are calculated with (1) assuming constant \\(\\bf{S}\\) and \\(\\bf{D}\\) , respectively. Grain parameters The grain viscous parameters below should be understood as the effective polycrystal values needed to reproduce deformation experiments, and not measured values derived from experiments on single crystals.","title":"Grain homogenization schemes"},{"location":"enhancements-strainrate/#transversely-isotropic-grains","text":"Monocrystal Polycrystal If grains are approximately transversely isotropic, the grain rheology can be modelled using the transversely isotropic power-law rheology . This requires specifying the grain eigenenhancements \\(E_{cc}'\\) and \\(E_{ca}'\\) , the power-law exponent \\(n'\\) , and the Taylor\u2014Sachs weight \\(\\alpha\\) .","title":"Transversely isotropic grains"},{"location":"enhancements-strainrate/#example-for-glacier-ice","text":"The below example for glacier ice shows how bulk \\(E_{ij}\\) may be calculated given a2 , a4 , or nlm . import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(4) # L=4 truncation is sufficient in this case ### Make synthetic ODF # Unidirectional CPO: all c-axes aligned in z-direction (ODF = deltafunc(r-m)) m = np.array([0,0,1]) nlm = np.zeros((nlm_len), dtype=np.complex64) # Array of expansion coefficients if True: # use a2 a2 = np.einsum('i,j', m,m) # Outer product nlm[:6] = sf.a2_to_nlm(a2) # Derive corresponding expansion coefficients else: # use a4 a4 = np.einsum('i,j,k,l', m,m,m,m) # Outer product nlm[:15] = sf.a4_to_nlm(a4) # Derive corresponding expansion coefficients ### Coordinate basis vectors for enhancement-factor calculations (e1,e2,e3, eigvals) = sf.frame(nlm, 'e') # a2 eigen basis #(e1,e2,e3) = (np.array([1,0,0]),np.array([0,1,0]),np.array([0,0,1])) # x,y,z cartesian basis ### Transversely isotropic monocrystal parameters for ice (Rathmann & Lilien, 2021) n_grain = 1 # Power-law exponent: n=1 => linear grain rheology, nonlinear (n>1) is unsupported. Eij_grain = (1, 1e3) # Grain eigenenhancements (Ecc,Eca) for compression along c-axis (Ecc) and for shear parallel to basal plane (Eca) alpha = 0.0125 # Taylor--Sachs weight ### Calculate enhancement factors w.r.t. e1, e2, e3 Eij = sf.Eij_tranisotropic(nlm, e1,e2,e3, Eij_grain,alpha,n_grain) # = (E11,E22,E33,E23,E13,E12) The below animation shows the directional enhancement factors for a CPO evolving under uniaxial compression along \\({\\hat {\\bf z}}\\) when subject to lattice rotation . Enhancement factors are calculated w.r.t. the spherical coordinate basis vectors \\({\\bf e}_1, {\\bf e}_2, {\\bf e}_3 = {\\hat{\\bf r}},{\\hat{\\boldsymbol \\theta}},{\\hat{\\boldsymbol \\phi}}\\) .","title":"Example for glacier ice"},{"location":"enhancements-strainrate/#orthotropic-grains","text":"Monocrystal Polycrystal If grains are approximately orthotropic, the grain rheology can be modelled using the orthotropic power-law rheology . This requires specifying the grain eigenenhancements ( \\(E_{11}'\\) , \\(E_{22}'\\) , \\(E_{33}'\\) , \\(E_{23}'\\) , \\(E_{13}'\\) , \\(E_{12}'\\) ), the power-law exponent \\(n'\\) , and the Taylor\u2014Sachs weight \\(\\alpha\\) .","title":"Orthotropic grains"},{"location":"enhancements-strainrate/#example-for-olivine","text":"Not yet available.","title":"Example for olivine"},{"location":"radar-derived-PP/","text":"Radar-derived physical properties of glacier ice Introduction The dielectric permittivity of a single ice crystal is approximately transversely isotropic w.r.t. the crystal \\(c\\) -axis: $$ \\epsilon_{ij} = \\frac{2\\epsilon_{\\perp} + \\epsilon_{\\parallel}}{3} + (\\epsilon_{\\parallel}-\\epsilon_{\\perp})(c_i c_j - \\delta_{ij}/3), $$ where \\(\\epsilon_{\\parallel}\\) and \\(\\epsilon_{\\perp}\\) are the permittivities parallel and perpendicular to the \\(c\\) -axis, which depend on ice temperature and EM-wave frequency ( Fujita et al., 2000 ). If EM-wave lengths are much longer than the average grain size, the bulk permittivity tensor of polycrystalline ice may be approximated as the grain-average permittivity tensor, constructed by averaging over all grain orientations (over the CPO): \\[ \\langle\\epsilon_{ij}\\rangle = \\frac{2\\epsilon_{\\perp} + \\epsilon_{\\parallel}}{3} + (\\epsilon_{\\parallel}-\\epsilon_{\\perp})( \\langle c_i c_j \\rangle - \\delta_{ij}/3) , \\] where \\(\\langle c_i c_j \\rangle\\) is the second-order structure tensor ( a2 in specfab), defined as the average outer product of grain \\(c\\) -axes (assuming grain sizes are uncorrelated with orientation): \\[ \\langle c_i c_j \\rangle = \\frac{1}{N}\\sum_{k=1}^N { c_i^{(k)} c_j^{(k)} }. \\] Here, the Cartesian components of \\(\\langle c_i c_j \\rangle\\) are written as \\[ \\langle c_i c_j \\rangle = \\left[\\begin{matrix} a_{xx} & a_{xy} & a_{xz}\\\\ a_{xy} & a_{yy} & a_{yz}\\\\ a_{xz} & a_{yz} & a_{zz} \\end{matrix}\\right] . \\] Properties like EM-wave speed and radar return-power anomalies depend on the bulk permittivity tensor \\(\\langle\\epsilon_{ij}\\rangle\\) , and therefore, given measurements of such quantities, information about \\(\\langle c_i c_j \\rangle\\) can be inferred (see e.g. Gerber et al., 2023 , and references therein). Radar measurements \\(\\rightarrow\\) CPO A useful approximation over large parts of ice sheets is that \\(\\langle c_i c_j \\rangle\\) has a vertical ( \\({\\bf z}\\) ) eigenvector, and hence \\[ \\langle c_i c_j \\rangle = \\left[\\begin{matrix} a_{xx} & a_{xy} & 0\\\\ a_{xy} & a_{yy} & 0\\\\ 0 & 0 & a_{zz} \\end{matrix}\\right] . \\] In this tutorial, we consider the common case where the difference in horizontal eigenvalues of \\(\\langle c_i c_j \\rangle\\) can be inferred from ice-penetrating radar, that is $$ \\Delta \\lambda = \\lambda_2 - \\lambda_1, $$ where \\({\\bf m}_1\\) and \\({\\bf m}_2\\) are the corresponding (horizontal) eigenvectors, and the eigenvalues are sorted such that \\(\\lambda_1 \\leq \\lambda_2\\) , or more precisely \\[ 0 \\leq \\lambda_1 \\leq 1/3 \\leq \\lambda_2 \\leq 1. \\] In this eigenframe ( \\({\\bf m}_1, {\\bf m}_2, {\\bf z}\\) ), the structure tensor can therefore be written as \\[ \\langle c_i c_j \\rangle = \\left[\\begin{matrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_1 + \\Delta\\lambda & 0 \\\\ 0 & 0 & 1 - \\Delta \\lambda - 2\\lambda_1 \\end{matrix}\\right] , \\] where \\(\\operatorname{tr}(\\langle c_i c_j \\rangle) = 1\\) was used. Gerber's approximation Since \\(\\lambda_1\\) is unknown, the problem can be closed by making different assumptions about \\(\\lambda_1\\) given the local/upstream flow regime, such as proposed by Gerber et al. (2023) . Suppose \\(\\Delta\\lambda\\) is measured in region where \\(c\\) -axes are suspected, to a good approximation, to be distributed on the \\({\\bf m}_2\\) \u2014 \\({\\bf z}\\) plane because the smallest eigenvalue is vanishing, \\(\\lambda_1 \\rightarrow 0\\) . In this case, \\(\\Delta \\lambda = 0\\) represents a perfect single-maximum along \\({\\bf z}\\) , \\(\\Delta \\lambda = 0.5\\) a perfect girdle in the \\({\\bf m}_2\\) \u2014 \\({\\bf z}\\) plane, and \\(\\Delta \\lambda = 1\\) a perfect single-maximum along \\({\\bf m}_2\\) , respectively: The above plot was generated from the normalized spectral expansion coefficients \\(\\hat{n}_l^m \\equiv n_l^m/n_0^0\\) for \\(l\\leq 2\\) , derived from \\[ \\langle c_i c_j\\rangle = \\frac{{\\bf I}}{3} + \\sqrt{\\frac{2}{15}} \\left[\\begin{matrix} \\operatorname{Re}[\\hat{n}_2^2] - \\dfrac{1}{2}\\sqrt{\\dfrac{2}{3}} \\hat{n}_2^0 & -\\operatorname{Im}[\\hat{n}_2^2] & -\\operatorname{Re}[\\hat{n}_2^1] \\\\ & -\\operatorname{Re}[\\hat{n}_2^2] - \\dfrac{1}{2}\\sqrt{\\dfrac{2}{3}} \\hat{n}_2^0 & \\operatorname{Im}[\\hat{n}_2^1] \\\\ \\mathrm{sym.} & & \\sqrt{\\dfrac{2}{3}} \\hat{n}_2^0 \\end{matrix}\\right] . \\] CPO \\(\\rightarrow\\) Enhancement factors If \\(\\langle c_i c_j \\rangle\\) can be inferred from radar sounding following the above method, so can the bulk strain-rate enhancement factors, \\(E_{ij}\\) , in the same eigenframe (i.e. eigenenhancements ). The eigenenhancements depend, however, also on the fourth-order structure tensor, \\(\\langle c_i c_j c_k c_l \\rangle\\) , but the bulk permittivity \\(\\langle\\epsilon_{ij}\\rangle\\) \u2014 and therefore radar-sounding methods \u2014 is insensitive to \\(\\langle c_i c_j c_k c_l \\rangle\\) . To overcome this, a simple empirical correlation exists that allows determining \\(\\langle c_i c_j c_k c_l \\rangle\\) given \\(\\langle c_i c_j\\rangle\\) if the CPO has an approximate rotational symmetry axis. Correlation between \\(\\langle c_i c_j c_k c_l \\rangle\\) and \\(\\langle c_i c_j\\rangle\\) If the CPO rotational symmetry axis is rotated into the vertical direction, \\(\\langle c_i c_j\\rangle\\) depends only on \\(\\hat{n}_2^0\\equiv n_2^0/n_0^0:\\) \\[ \\langle c_i c_j\\rangle = \\frac{{\\bf I}}{3} + \\frac{2\\sqrt{5}}{15} \\hat{n}_2^0 \\left[\\begin{matrix} -1/2 & 0 & 0 \\\\ 0 & -1/2 & 0 \\\\ 0 & 0 & 1 \\end{matrix}\\right] , \\] and \\(\\langle c_i c_j c_k c_l \\rangle\\) only on \\(\\hat{n}_2^0\\) and \\(\\hat{n}_4^0\\equiv n_4^0/n_0^0\\) (not shown). The figure below shows the empirical correlation between these two components based on ice-core samples. Thus, if \\(\\hat{n}_2^0\\) is extracted from \\(\\langle c_i c_j\\rangle\\) in this frame, \\(\\hat{n}_4^0\\) can be derived and hence \\(\\langle c_i c_j c_k c_l \\rangle\\) constructed. To pose the CPO in the original, unrotated eigenframe ( \\({\\bf m}_1, {\\bf m}_2, {\\bf z}\\) ), the resulting expansion series is rotated back. Code example The following code demonstrates how to take each step with specfab: import numpy as np from scipy.spatial.transform import Rotation from specfabpy import specfabpy as sf lm, nlm_len = sf.init(4) # L=4 is sufficient here ### Determine <c_i c_j> from radar-derived Delta lambda l1 = 0 # lambda_1 = 0 (Gerber's approximation) dl = 0.5 # Delta lambda = lambda_2 - lambda_1 a2 = np.diag([l1, l1+dl, 1-dl-2*l1]) # second-order structure tensor, <c_i c_j>, in eigenframe m1, m2, z = np.array([1,0,0]), np.array([0,1,0]), np.array([0,0,1]) # eigenvectors ### Rotate <c_i c_j> into a rotationally-symmetric frame about z Rm1 = Rotation.from_rotvec(np.pi/2 * m1).as_matrix() # Rotate 90 deg about m1 eigenvector Rm2 = Rotation.from_rotvec(np.pi/2 * m2).as_matrix() # Rotate 90 deg.about m2 eigenvector if dl < 0.4: a2_vs = a2 # Already in rotationally-symmetric frame about z if 0.4 <= dl <= 0.6: a2_vs = np.matmul(Rm2,np.matmul(a2,Rm2.T)) # Rotate vertical (m2--z) girdle into horizontal (m1--m2) girdle if dl > 0.6: a2_vs = np.matmul(Rm1,np.matmul(a2,Rm1.T)) # Rotate horizontal (m2) single-maximum into vertical (z) single-maximum ### Determine \\hat{n}_4^0 (= n_4^0/n_0^0) from \\hat{n}_2^0 (= n_2^0/n_0^0) in rotationally-symmetric frame about z nhat20 = (a2_vs[2,2]- 1/3)/(2/15*np.sqrt(5)) # azz -> nhat20 nhat40 = sf.nhat40_empcorr_ice(nhat20) ### Construct nlm (spectral CPO state vector) in rotationally-symmetric frame about z nlm_vs = np.zeros(nlm_len, dtype=np.complex128) n00 = 1/np.sqrt(4*np.pi) # only grain-number normalized distribution is known, so must integrate to 1 over S^2. nlm_vs[0] = n00 nlm_vs[3] = nhat20*n00 nlm_vs[10] = nhat40*n00 ### Rotate spectral CPO state back to original (m1,m2,z) eigenframe if dl < 0.4: nlm = nlm_vs # Already in vertical symmetric frame if 0.4 <= dl <= 0.6: nlm = sf.rotate_nlm(nlm_vs, -np.pi/2, 0) # Rotate horizontal (m1--m2) girdle back into vertical (m2--z) girdle if dl > 0.6: nlm = sf.rotate_nlm(sf.rotate_nlm(nlm_vs, -np.pi/2, 0), 0 ,-np.pi/2) # Rotate vertical (z) single-maximum back into horizontal (m2) single-maximum ### Calculate eigenenhancements # Transversely isotropic monocrystal parameters for ice (Rathmann & Lilien, 2021) n_grain = 1 # Power-law exponent: n=1 => linear grain rheology, nonlinear (n>1) is unsupported Eij_grain = (1, 1e3) # Grain eigenenhancements (Ecc,Eca) for compression along c-axis (Ecc) and for shear parallel to basal plane (Eca) alpha = 0.0125 # Taylor--Sachs weight # Tuple of eigenenhancements (bulk enhancement factors w.r.t. m1, m2, z) e1, e2, e3 = m1, m2, z Eij = sf.Eij_tranisotropic(nlm, e1,e2,e3, Eij_grain,alpha,n_grain) print(Eij) # (E_{m1,m1},E_{m2,m2},E_{zz},E_{m2,z),E_{m1,z},E_{m1,m2}) # To calculate bulk enhancement factors w.r.t. other axes of deformation/stress, change (e1,e2,e3) accordingly. For reference, the below plots show the different CPOs at each step for \\(\\Delta\\lambda=0.5\\) and \\(\\Delta\\lambda=1\\) . \\(\\Delta\\lambda = 0.5\\) \\(\\Delta\\lambda = 1.0\\)","title":"Radar-derived physical properties"},{"location":"radar-derived-PP/#radar-derived-physical-properties-of-glacier-ice","text":"","title":"Radar-derived physical properties of glacier ice"},{"location":"radar-derived-PP/#introduction","text":"The dielectric permittivity of a single ice crystal is approximately transversely isotropic w.r.t. the crystal \\(c\\) -axis: $$ \\epsilon_{ij} = \\frac{2\\epsilon_{\\perp} + \\epsilon_{\\parallel}}{3} + (\\epsilon_{\\parallel}-\\epsilon_{\\perp})(c_i c_j - \\delta_{ij}/3), $$ where \\(\\epsilon_{\\parallel}\\) and \\(\\epsilon_{\\perp}\\) are the permittivities parallel and perpendicular to the \\(c\\) -axis, which depend on ice temperature and EM-wave frequency ( Fujita et al., 2000 ). If EM-wave lengths are much longer than the average grain size, the bulk permittivity tensor of polycrystalline ice may be approximated as the grain-average permittivity tensor, constructed by averaging over all grain orientations (over the CPO): \\[ \\langle\\epsilon_{ij}\\rangle = \\frac{2\\epsilon_{\\perp} + \\epsilon_{\\parallel}}{3} + (\\epsilon_{\\parallel}-\\epsilon_{\\perp})( \\langle c_i c_j \\rangle - \\delta_{ij}/3) , \\] where \\(\\langle c_i c_j \\rangle\\) is the second-order structure tensor ( a2 in specfab), defined as the average outer product of grain \\(c\\) -axes (assuming grain sizes are uncorrelated with orientation): \\[ \\langle c_i c_j \\rangle = \\frac{1}{N}\\sum_{k=1}^N { c_i^{(k)} c_j^{(k)} }. \\] Here, the Cartesian components of \\(\\langle c_i c_j \\rangle\\) are written as \\[ \\langle c_i c_j \\rangle = \\left[\\begin{matrix} a_{xx} & a_{xy} & a_{xz}\\\\ a_{xy} & a_{yy} & a_{yz}\\\\ a_{xz} & a_{yz} & a_{zz} \\end{matrix}\\right] . \\] Properties like EM-wave speed and radar return-power anomalies depend on the bulk permittivity tensor \\(\\langle\\epsilon_{ij}\\rangle\\) , and therefore, given measurements of such quantities, information about \\(\\langle c_i c_j \\rangle\\) can be inferred (see e.g. Gerber et al., 2023 , and references therein).","title":"Introduction"},{"location":"radar-derived-PP/#radar-measurements-rightarrow-cpo","text":"A useful approximation over large parts of ice sheets is that \\(\\langle c_i c_j \\rangle\\) has a vertical ( \\({\\bf z}\\) ) eigenvector, and hence \\[ \\langle c_i c_j \\rangle = \\left[\\begin{matrix} a_{xx} & a_{xy} & 0\\\\ a_{xy} & a_{yy} & 0\\\\ 0 & 0 & a_{zz} \\end{matrix}\\right] . \\] In this tutorial, we consider the common case where the difference in horizontal eigenvalues of \\(\\langle c_i c_j \\rangle\\) can be inferred from ice-penetrating radar, that is $$ \\Delta \\lambda = \\lambda_2 - \\lambda_1, $$ where \\({\\bf m}_1\\) and \\({\\bf m}_2\\) are the corresponding (horizontal) eigenvectors, and the eigenvalues are sorted such that \\(\\lambda_1 \\leq \\lambda_2\\) , or more precisely \\[ 0 \\leq \\lambda_1 \\leq 1/3 \\leq \\lambda_2 \\leq 1. \\] In this eigenframe ( \\({\\bf m}_1, {\\bf m}_2, {\\bf z}\\) ), the structure tensor can therefore be written as \\[ \\langle c_i c_j \\rangle = \\left[\\begin{matrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_1 + \\Delta\\lambda & 0 \\\\ 0 & 0 & 1 - \\Delta \\lambda - 2\\lambda_1 \\end{matrix}\\right] , \\] where \\(\\operatorname{tr}(\\langle c_i c_j \\rangle) = 1\\) was used.","title":"Radar measurements \\(\\rightarrow\\) CPO"},{"location":"radar-derived-PP/#gerbers-approximation","text":"Since \\(\\lambda_1\\) is unknown, the problem can be closed by making different assumptions about \\(\\lambda_1\\) given the local/upstream flow regime, such as proposed by Gerber et al. (2023) . Suppose \\(\\Delta\\lambda\\) is measured in region where \\(c\\) -axes are suspected, to a good approximation, to be distributed on the \\({\\bf m}_2\\) \u2014 \\({\\bf z}\\) plane because the smallest eigenvalue is vanishing, \\(\\lambda_1 \\rightarrow 0\\) . In this case, \\(\\Delta \\lambda = 0\\) represents a perfect single-maximum along \\({\\bf z}\\) , \\(\\Delta \\lambda = 0.5\\) a perfect girdle in the \\({\\bf m}_2\\) \u2014 \\({\\bf z}\\) plane, and \\(\\Delta \\lambda = 1\\) a perfect single-maximum along \\({\\bf m}_2\\) , respectively: The above plot was generated from the normalized spectral expansion coefficients \\(\\hat{n}_l^m \\equiv n_l^m/n_0^0\\) for \\(l\\leq 2\\) , derived from \\[ \\langle c_i c_j\\rangle = \\frac{{\\bf I}}{3} + \\sqrt{\\frac{2}{15}} \\left[\\begin{matrix} \\operatorname{Re}[\\hat{n}_2^2] - \\dfrac{1}{2}\\sqrt{\\dfrac{2}{3}} \\hat{n}_2^0 & -\\operatorname{Im}[\\hat{n}_2^2] & -\\operatorname{Re}[\\hat{n}_2^1] \\\\ & -\\operatorname{Re}[\\hat{n}_2^2] - \\dfrac{1}{2}\\sqrt{\\dfrac{2}{3}} \\hat{n}_2^0 & \\operatorname{Im}[\\hat{n}_2^1] \\\\ \\mathrm{sym.} & & \\sqrt{\\dfrac{2}{3}} \\hat{n}_2^0 \\end{matrix}\\right] . \\]","title":"Gerber's approximation"},{"location":"radar-derived-PP/#cpo-rightarrow-enhancement-factors","text":"If \\(\\langle c_i c_j \\rangle\\) can be inferred from radar sounding following the above method, so can the bulk strain-rate enhancement factors, \\(E_{ij}\\) , in the same eigenframe (i.e. eigenenhancements ). The eigenenhancements depend, however, also on the fourth-order structure tensor, \\(\\langle c_i c_j c_k c_l \\rangle\\) , but the bulk permittivity \\(\\langle\\epsilon_{ij}\\rangle\\) \u2014 and therefore radar-sounding methods \u2014 is insensitive to \\(\\langle c_i c_j c_k c_l \\rangle\\) . To overcome this, a simple empirical correlation exists that allows determining \\(\\langle c_i c_j c_k c_l \\rangle\\) given \\(\\langle c_i c_j\\rangle\\) if the CPO has an approximate rotational symmetry axis.","title":"CPO \\(\\rightarrow\\) Enhancement factors"},{"location":"radar-derived-PP/#correlation-between-langle-c_i-c_j-c_k-c_l-rangle-and-langle-c_i-c_jrangle","text":"If the CPO rotational symmetry axis is rotated into the vertical direction, \\(\\langle c_i c_j\\rangle\\) depends only on \\(\\hat{n}_2^0\\equiv n_2^0/n_0^0:\\) \\[ \\langle c_i c_j\\rangle = \\frac{{\\bf I}}{3} + \\frac{2\\sqrt{5}}{15} \\hat{n}_2^0 \\left[\\begin{matrix} -1/2 & 0 & 0 \\\\ 0 & -1/2 & 0 \\\\ 0 & 0 & 1 \\end{matrix}\\right] , \\] and \\(\\langle c_i c_j c_k c_l \\rangle\\) only on \\(\\hat{n}_2^0\\) and \\(\\hat{n}_4^0\\equiv n_4^0/n_0^0\\) (not shown). The figure below shows the empirical correlation between these two components based on ice-core samples. Thus, if \\(\\hat{n}_2^0\\) is extracted from \\(\\langle c_i c_j\\rangle\\) in this frame, \\(\\hat{n}_4^0\\) can be derived and hence \\(\\langle c_i c_j c_k c_l \\rangle\\) constructed. To pose the CPO in the original, unrotated eigenframe ( \\({\\bf m}_1, {\\bf m}_2, {\\bf z}\\) ), the resulting expansion series is rotated back.","title":"Correlation between \\(\\langle c_i c_j c_k c_l \\rangle\\) and \\(\\langle c_i c_j\\rangle\\)"},{"location":"radar-derived-PP/#code-example","text":"The following code demonstrates how to take each step with specfab: import numpy as np from scipy.spatial.transform import Rotation from specfabpy import specfabpy as sf lm, nlm_len = sf.init(4) # L=4 is sufficient here ### Determine <c_i c_j> from radar-derived Delta lambda l1 = 0 # lambda_1 = 0 (Gerber's approximation) dl = 0.5 # Delta lambda = lambda_2 - lambda_1 a2 = np.diag([l1, l1+dl, 1-dl-2*l1]) # second-order structure tensor, <c_i c_j>, in eigenframe m1, m2, z = np.array([1,0,0]), np.array([0,1,0]), np.array([0,0,1]) # eigenvectors ### Rotate <c_i c_j> into a rotationally-symmetric frame about z Rm1 = Rotation.from_rotvec(np.pi/2 * m1).as_matrix() # Rotate 90 deg about m1 eigenvector Rm2 = Rotation.from_rotvec(np.pi/2 * m2).as_matrix() # Rotate 90 deg.about m2 eigenvector if dl < 0.4: a2_vs = a2 # Already in rotationally-symmetric frame about z if 0.4 <= dl <= 0.6: a2_vs = np.matmul(Rm2,np.matmul(a2,Rm2.T)) # Rotate vertical (m2--z) girdle into horizontal (m1--m2) girdle if dl > 0.6: a2_vs = np.matmul(Rm1,np.matmul(a2,Rm1.T)) # Rotate horizontal (m2) single-maximum into vertical (z) single-maximum ### Determine \\hat{n}_4^0 (= n_4^0/n_0^0) from \\hat{n}_2^0 (= n_2^0/n_0^0) in rotationally-symmetric frame about z nhat20 = (a2_vs[2,2]- 1/3)/(2/15*np.sqrt(5)) # azz -> nhat20 nhat40 = sf.nhat40_empcorr_ice(nhat20) ### Construct nlm (spectral CPO state vector) in rotationally-symmetric frame about z nlm_vs = np.zeros(nlm_len, dtype=np.complex128) n00 = 1/np.sqrt(4*np.pi) # only grain-number normalized distribution is known, so must integrate to 1 over S^2. nlm_vs[0] = n00 nlm_vs[3] = nhat20*n00 nlm_vs[10] = nhat40*n00 ### Rotate spectral CPO state back to original (m1,m2,z) eigenframe if dl < 0.4: nlm = nlm_vs # Already in vertical symmetric frame if 0.4 <= dl <= 0.6: nlm = sf.rotate_nlm(nlm_vs, -np.pi/2, 0) # Rotate horizontal (m1--m2) girdle back into vertical (m2--z) girdle if dl > 0.6: nlm = sf.rotate_nlm(sf.rotate_nlm(nlm_vs, -np.pi/2, 0), 0 ,-np.pi/2) # Rotate vertical (z) single-maximum back into horizontal (m2) single-maximum ### Calculate eigenenhancements # Transversely isotropic monocrystal parameters for ice (Rathmann & Lilien, 2021) n_grain = 1 # Power-law exponent: n=1 => linear grain rheology, nonlinear (n>1) is unsupported Eij_grain = (1, 1e3) # Grain eigenenhancements (Ecc,Eca) for compression along c-axis (Ecc) and for shear parallel to basal plane (Eca) alpha = 0.0125 # Taylor--Sachs weight # Tuple of eigenenhancements (bulk enhancement factors w.r.t. m1, m2, z) e1, e2, e3 = m1, m2, z Eij = sf.Eij_tranisotropic(nlm, e1,e2,e3, Eij_grain,alpha,n_grain) print(Eij) # (E_{m1,m1},E_{m2,m2},E_{zz},E_{m2,z),E_{m1,z},E_{m1,m2}) # To calculate bulk enhancement factors w.r.t. other axes of deformation/stress, change (e1,e2,e3) accordingly. For reference, the below plots show the different CPOs at each step for \\(\\Delta\\lambda=0.5\\) and \\(\\Delta\\lambda=1\\) . \\(\\Delta\\lambda = 0.5\\) \\(\\Delta\\lambda = 1.0\\)","title":"Code example"},{"location":"wavepropagation-elastic/","text":"Elastic wave propagation Elastic P and S plan-wave velocities, permitted in a polycrystal with an arbitrary CPO, can be determined for any linear combination of the Voigt and Reuss homogenization schemes by solving for the eigenvalues of the acoustic tensor : $$ {\\bf {Q}}= (1-\\alpha){\\bf Q_{\\mathrm{Reuss}}} + \\alpha{\\bf Q_{\\mathrm{Voigt}}}, $$ which depends on the CPO, grain elastic parameters, and direction of propagation. Voigt and Reuss homogenizations The Voigt scheme ( \\(\\alpha=1\\) ) assumes the strain field is homogeneous over the polycrystal scale, whereas the Reuss scheme ( \\(\\alpha=0\\) ) assumes the stress is homogeneous. Moreover, in these homogenizations, grains are assumed interactionless and the bulk elastic behaviour is therefore simply the grain-orientation-averaged elastic behaviour subject to either homogeneous stress or strain assumptions over the polycrystal scale. Grain parameters The grain elastic parameters should be understood as the effective polycrystal values needed to reproduce experimental results, and not measured values derived from experiments on single crystals. Transversely isotropic grains Monocrystal Polycrystal If grains are approximately transversely isotropic, the grain elastic behaviour can be modelled using the transversely isotropic elastic constitutive equation . This requires specifying the grain elastic parameters \\(\\lambda'\\) , \\(\\mu'\\) , \\(\\hat{\\lambda}'\\) , \\(\\hat{\\mu}'\\) , \\(\\hat{\\gamma}'\\) , and the Voigt\u2014Reuss weight \\(\\alpha\\) . Example for glacier ice The below example for glacier ice shows how bulk phase velocities may be calculated given a2 , a4 , or nlm . import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(4) # L=4 truncation is sufficient in this case nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients # c-axis number distribution (nlm) from fourth-order structure tensor (a4) p = np.array([0,0,1]) # preferred c-axis direction a4 = np.einsum('i,j,k,l', p,p,p,p) # a4 if ODF = deltafunc(r-p) nlm[:] = sf.a4_to_nlm(a4) # l=2,4 expansion coefficients for corresponding ODF (a4 is normalized) # Physical parameters rho = 917 # density of ice C11,C33,C55,C12,C13 = 14.060e9, 15.240e9, 3.060e9, 7.150e9, 5.880e9 # Bennett (1968) parameters lam,mu,Elam,Emu,Egam = sf.Cij_to_Lame_tranisotropic(C11,C33,C55,C12,C13) # Homogenization scheme alpha = 0.5 # Voigt--Reuss weight, where 0.5 = Hill average # Propagation directions of interest theta, phi = np.deg2rad([90,70,]), np.deg2rad([0,10,]) # wave-vector directions (theta is colatitude, phi is longitude) # Calculate phase velocities Vi = sf.Vi_elastic_tranisotropic(nlm, alpha, lam,mu,Elam,Emu,Egam, rho, theta,phi) # phase velocities are V_S1=vi[0,:], V_S2=vi[1,:], V_P=vi[2,:] The below animation shows directional P- and S-wave velocities for a CPO evolving under uniaxial compression along \\({\\hat {\\bf z}}\\) , relative to an isotropic CPO, when subject to lattice rotation . Orthotropic grains Monocrystal Polycrystal If grains are approximately orthotropic, the grain elastic behaviour can be modelled using the orthotropic elastic constitutive equation . This requires specifying the grain elastic parameters \\(\\lambda_{11}'\\) , \\(\\lambda_{22}'\\) , \\(\\lambda_{33}'\\) , \\(\\lambda_{23}'\\) , \\(\\lambda_{13}'\\) , \\(\\lambda_{12}'\\) , \\(\\mu_{1}'\\) , \\(\\mu_{2}'\\) , \\(\\mu_{3}'\\) , and the Voigt\u2014Reuss weight \\(\\alpha\\) . Example for olivine Not yet available.","title":"Wave propagation"},{"location":"wavepropagation-elastic/#elastic-wave-propagation","text":"Elastic P and S plan-wave velocities, permitted in a polycrystal with an arbitrary CPO, can be determined for any linear combination of the Voigt and Reuss homogenization schemes by solving for the eigenvalues of the acoustic tensor : $$ {\\bf {Q}}= (1-\\alpha){\\bf Q_{\\mathrm{Reuss}}} + \\alpha{\\bf Q_{\\mathrm{Voigt}}}, $$ which depends on the CPO, grain elastic parameters, and direction of propagation. Voigt and Reuss homogenizations The Voigt scheme ( \\(\\alpha=1\\) ) assumes the strain field is homogeneous over the polycrystal scale, whereas the Reuss scheme ( \\(\\alpha=0\\) ) assumes the stress is homogeneous. Moreover, in these homogenizations, grains are assumed interactionless and the bulk elastic behaviour is therefore simply the grain-orientation-averaged elastic behaviour subject to either homogeneous stress or strain assumptions over the polycrystal scale. Grain parameters The grain elastic parameters should be understood as the effective polycrystal values needed to reproduce experimental results, and not measured values derived from experiments on single crystals.","title":"Elastic wave propagation"},{"location":"wavepropagation-elastic/#transversely-isotropic-grains","text":"Monocrystal Polycrystal If grains are approximately transversely isotropic, the grain elastic behaviour can be modelled using the transversely isotropic elastic constitutive equation . This requires specifying the grain elastic parameters \\(\\lambda'\\) , \\(\\mu'\\) , \\(\\hat{\\lambda}'\\) , \\(\\hat{\\mu}'\\) , \\(\\hat{\\gamma}'\\) , and the Voigt\u2014Reuss weight \\(\\alpha\\) .","title":"Transversely isotropic grains"},{"location":"wavepropagation-elastic/#example-for-glacier-ice","text":"The below example for glacier ice shows how bulk phase velocities may be calculated given a2 , a4 , or nlm . import numpy as np from specfabpy import specfabpy as sf lm, nlm_len = sf.init(4) # L=4 truncation is sufficient in this case nlm = np.zeros((nlm_len), dtype=np.complex64) # array of expansion coefficients # c-axis number distribution (nlm) from fourth-order structure tensor (a4) p = np.array([0,0,1]) # preferred c-axis direction a4 = np.einsum('i,j,k,l', p,p,p,p) # a4 if ODF = deltafunc(r-p) nlm[:] = sf.a4_to_nlm(a4) # l=2,4 expansion coefficients for corresponding ODF (a4 is normalized) # Physical parameters rho = 917 # density of ice C11,C33,C55,C12,C13 = 14.060e9, 15.240e9, 3.060e9, 7.150e9, 5.880e9 # Bennett (1968) parameters lam,mu,Elam,Emu,Egam = sf.Cij_to_Lame_tranisotropic(C11,C33,C55,C12,C13) # Homogenization scheme alpha = 0.5 # Voigt--Reuss weight, where 0.5 = Hill average # Propagation directions of interest theta, phi = np.deg2rad([90,70,]), np.deg2rad([0,10,]) # wave-vector directions (theta is colatitude, phi is longitude) # Calculate phase velocities Vi = sf.Vi_elastic_tranisotropic(nlm, alpha, lam,mu,Elam,Emu,Egam, rho, theta,phi) # phase velocities are V_S1=vi[0,:], V_S2=vi[1,:], V_P=vi[2,:] The below animation shows directional P- and S-wave velocities for a CPO evolving under uniaxial compression along \\({\\hat {\\bf z}}\\) , relative to an isotropic CPO, when subject to lattice rotation .","title":"Example for glacier ice"},{"location":"wavepropagation-elastic/#orthotropic-grains","text":"Monocrystal Polycrystal If grains are approximately orthotropic, the grain elastic behaviour can be modelled using the orthotropic elastic constitutive equation . This requires specifying the grain elastic parameters \\(\\lambda_{11}'\\) , \\(\\lambda_{22}'\\) , \\(\\lambda_{33}'\\) , \\(\\lambda_{23}'\\) , \\(\\lambda_{13}'\\) , \\(\\lambda_{12}'\\) , \\(\\mu_{1}'\\) , \\(\\mu_{2}'\\) , \\(\\mu_{3}'\\) , and the Voigt\u2014Reuss weight \\(\\alpha\\) .","title":"Orthotropic grains"},{"location":"wavepropagation-elastic/#example-for-olivine","text":"Not yet available.","title":"Example for olivine"}]}